<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Zahlenbereiche und Zahlensysteme – Mathe kapieren mit Python</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="../site_libs/quarto-contrib/videojs/video.min.js"></script>
<link href="../site_libs/quarto-contrib/videojs/video-js.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Keine Treffer",
    "search-matching-documents-text": "Treffer",
    "search-copy-link-title": "Link in die Suche kopieren",
    "search-hide-matches-text": "Zusätzliche Treffer verbergen",
    "search-more-match-text": "weitere Treffer in diesem Dokument",
    "search-more-matches-text": "weitere Treffer in diesem Dokument",
    "search-clear-button-title": "Zurücksetzen",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Abbrechen",
    "search-submit-button-title": "Abschicken",
    "search-label": "Suchen"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../arithmetik/1-rechenregeln.html">Arithmetik</a></li><li class="breadcrumb-item"><a href="../arithmetik/3-mengen.html">Zahlenbereiche und Zahlensysteme</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Suchen" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Mathe kapieren mit Python</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Suchen"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Arithmetik</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../arithmetik/1-rechenregeln.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Grundlegende Rechenregeln</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../arithmetik/2-teiler.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Teiler und Vielfache</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../arithmetik/3-mengen.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Zahlenbereiche und Zahlensysteme</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../arithmetik/4-bruchrechnung.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Bruchrechnung</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../arithmetik/5-logarithmen.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Potenzen, Wurzeln, Logarithmen</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../arithmetik/6-rekursion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Rekursion</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Auf dieser Seite</h2>
   
  <ul>
  <li><a href="#sec-mengen" id="toc-sec-mengen" class="nav-link active" data-scroll-target="#sec-mengen"><span class="header-section-number">1</span> Elementare Mengenlehre</a></li>
  <li><a href="#zahlenbereiche" id="toc-zahlenbereiche" class="nav-link" data-scroll-target="#zahlenbereiche"><span class="header-section-number">2</span> Zahlenbereiche</a>
  <ul class="collapse">
  <li><a href="#natürliche-zahlen" id="toc-natürliche-zahlen" class="nav-link" data-scroll-target="#natürliche-zahlen"><span class="header-section-number">2.1</span> Natürliche Zahlen</a></li>
  <li><a href="#sec-zahlen" id="toc-sec-zahlen" class="nav-link" data-scroll-target="#sec-zahlen"><span class="header-section-number">2.2</span> Ganze Zahlen</a></li>
  <li><a href="#rationale-zahlen" id="toc-rationale-zahlen" class="nav-link" data-scroll-target="#rationale-zahlen"><span class="header-section-number">2.3</span> Rationale Zahlen</a></li>
  <li><a href="#reelle-zahlen" id="toc-reelle-zahlen" class="nav-link" data-scroll-target="#reelle-zahlen"><span class="header-section-number">2.4</span> Reelle Zahlen</a></li>
  </ul></li>
  <li><a href="#zahlensysteme" id="toc-zahlensysteme" class="nav-link" data-scroll-target="#zahlensysteme"><span class="header-section-number">3</span> Zahlensysteme</a>
  <ul class="collapse">
  <li><a href="#römische-zahlen" id="toc-römische-zahlen" class="nav-link" data-scroll-target="#römische-zahlen"><span class="header-section-number">3.1</span> Römische Zahlen</a></li>
  <li><a href="#sec-dezimal" id="toc-sec-dezimal" class="nav-link" data-scroll-target="#sec-dezimal"><span class="header-section-number">3.2</span> Dezimalsystem</a></li>
  <li><a href="#dualsystem" id="toc-dualsystem" class="nav-link" data-scroll-target="#dualsystem"><span class="header-section-number">3.3</span> Dualsystem</a></li>
  </ul></li>
  <li><a href="#übungen" id="toc-übungen" class="nav-link" data-scroll-target="#übungen"><span class="header-section-number">4</span> Übungen</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../arithmetik/1-rechenregeln.html">Arithmetik</a></li><li class="breadcrumb-item"><a href="../arithmetik/3-mengen.html">Zahlenbereiche und Zahlensysteme</a></li></ol></nav>
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Zahlenbereiche und Zahlensysteme</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Bisher haben wir wie selbstverständlich von natürlichen und reellen Zahlen gesprochen, ohne überhaupt genau zu wissen, was wir darunter verstehen wollen.</p>
<p>In dieser Lektion werden wir uns den Zahlenbegriff, so wie er der gesamten Mathematik zugrunde liegt, näher anschauen. Dafür werden wir zunächst die Grundbegriffe der Mengenlehre kennenlernen und die Zahlen in Zahlenbereiche einteilen. Schließlich wollen wir auch noch verschiedene Zahlensysteme erkunden.</p>
<section id="sec-mengen" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="sec-mengen"><span class="header-section-number">1</span> Elementare Mengenlehre</h2>
<p>In der Mathematik wird jede Zusammenfassung von bestimmten, wohlunterscheidbaren Objekten zu einer <em>Gesamtheit</em> eine <strong>Menge</strong> genannt. Eine Menge ist definiert, wenn feststeht, welche Objekte zu dieser Menge gehören und welche nicht. Die zur Menge gehörenden Objekte heißen ihre <em>Elemente</em>. Mengen werden meistens mit großen lateinischen Buchstaben bezeichnet und die Elemente mit kleinen Buchstaben.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition von Mengen
</div>
</div>
<div class="callout-body-container callout-body">
<p>Es gibt zwei Möglichkeiten, Mengen zu definieren:</p>
<ul>
<li>Durch Aufzählen ihrer Elemente, die in beliebiger Reihenfolge zwischen geschweiften Klammern (Mengenklammern) gesetzt sind und durch Komma getrennt werden: <span class="math inline">\(\{x_1, x_2, x_3, \dots\}\)</span></li>
<li>Durch Angabe einer die Elemente charakteresierenden Eigenschaft: <span class="math inline">\(\{x \mid \mathrm{Eigenschaft}\}\)</span>. Der vertikale Strich <span class="math inline">\(\mid\)</span> wird gelesen als “für die gilt”.</li>
</ul>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Beispiele für Mengendefinitionen
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><span class="math inline">\(A=\{1,2,3\}\)</span>: die Menge <span class="math inline">\(A\)</span> besteht aus den Elementen 1, 2 und 3.</li>
<li><span class="math inline">\(B=\{x \mid x^2-1=0\}\)</span>: die Menge <span class="math inline">\(B\)</span> besteht aus den Elementen <span class="math inline">\(x\)</span>, für die <span class="math inline">\(x^2-1=0\)</span> gilt.</li>
<li><span class="math inline">\(B=\{1,-1\}\)</span>: da die Gleichung <span class="math inline">\(x^2-1=0\)</span> die Lösungen <span class="math inline">\(x_1= 1\)</span> und <span class="math inline">\(x_2=-1\)</span> besitzt, kann man die Menge <span class="math inline">\(B\)</span> auch in dieser Form schreiben.</li>
</ul>
</div>
</div>
<p>Gehört ein Objekt <span class="math inline">\(a\)</span> einer Menge <span class="math inline">\(M\)</span> an, so schreibt man <span class="math inline">\(a \in M\)</span> (gelesen als: <span class="math inline">\(a\)</span> ist Element von <span class="math inline">\(M\)</span>). Gehört <span class="math inline">\(a\)</span> nicht zu <span class="math inline">\(M\)</span>, so schreibt man <span class="math inline">\(a \notin M\)</span>.</p>
<p>Wenn jedes Element einer Menge <span class="math inline">\(M\)</span> auch Element einer Menge <span class="math inline">\(N\)</span> ist, so nennt man <span class="math inline">\(M\)</span> Teilmenge von <span class="math inline">\(N\)</span> und schreibt <span class="math inline">\(M \subset N\)</span>. Diese Schreibweise bedeutet auch, dass <span class="math inline">\(M\)</span> eine <em>echte</em> Teilmenge von <span class="math inline">\(N\)</span> ist; es gilt also <span class="math inline">\(M\neq N\)</span>. Wollte man zulassen, dass <span class="math inline">\(M\)</span> auch gleich <span class="math inline">\(N\)</span> sein könnte, also <span class="math inline">\(M=N\)</span>, dann würde man <span class="math inline">\(M\subseteq N\)</span> schreiben.<br>
Die leere Menge <span class="math inline">\(\emptyset=\{\}\)</span> enthält kein Element.</p>
<p>Die Zugehörigkeit von Objekten zu Mengen kann man auch grafisch in einem <em>Mengendiagramm</em> darstellen, wobei Mengen als Kreise oder Ellipsen dargestellt werden, und Elemente, die zur Menge gehören, in den Kreis geschrieben werden.</p>
<div id="fig-euler" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-euler-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="media/images/euler/euler-diagramm.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-euler-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;1: Euler-Diagramm: Zugehörigkeit zu Mengen
</figcaption>
</figure>
</div>
<p>Auf Mengen sind folgende Operationen definiert, deren Ergebnis jeweils wieder eine Menge ist:</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Vereinigungsmenge
</div>
</div>
<div class="callout-body-container callout-body">
<p>Die Vereinigung <span class="math inline">\(A \cup B\)</span> zweier Mengen <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> besteht aus denjenigen Elementen, die in <span class="math inline">\(A\)</span> oder in <span class="math inline">\(B\)</span>, also in mindestens einer der beiden Mengen <span class="math inline">\(A, B\)</span> enthalten sind: <span class="math display">\[
A \cup B = \{x \mid x \in A \ \mathrm{oder} \ x \in B\}
\]</span></p>
</div>
</div>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Schnittmenge
</div>
</div>
<div class="callout-body-container callout-body">
<p>Die Durchschnitt <span class="math inline">\(A\cap B\)</span> zweier Mengen <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> besteht aus denjenigen Elementen, die sowohl in <span class="math inline">\(A\)</span> als auch in <span class="math inline">\(B\)</span>, also gleichzeitig in beiden Mengen <span class="math inline">\(A, B\)</span> enthalten sind: <span class="math display">\[
A \cap B = \{x \mid x \in A \ \mathrm{und} \ x \in B\}
\]</span></p>
</div>
</div>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Differenz
</div>
</div>
<div class="callout-body-container callout-body">
<p>Die Differenz <span class="math inline">\(A \backslash B\)</span> zweier Mengen <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> besteht aus denjenigen Elementen, die in <span class="math inline">\(A\)</span>, aber nicht in <span class="math inline">\(B\)</span> enthalten sind: <span class="math display">\[
A \backslash B = \{x \mid x \in A \ \mathrm{und} \ x \notin B\}
\]</span></p>
</div>
</div>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Symmetrische Differenz
</div>
</div>
<div class="callout-body-container callout-body">
<p>Die symmetrische Differenz <span class="math inline">\(A \Delta B\)</span> zweier Mengen <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> besteht aus denjenigen Elementen, die in <span class="math inline">\(A\)</span> oder <span class="math inline">\(B\)</span> enthalten sind, aber nicht in der Schnittmenge von <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span>: <span class="math display">\[
A \Delta B = (A \cup B) \backslash (A \cap B)=(A \backslash B) \cup (B \backslash A)
\]</span></p>
</div>
</div>
<p>Diese Mengenoperationen können mit einem sogenannten <em>Venn-Diagramm</em> veranschaulicht werden, in dem die Ergebnismenge einer Operation entsprechend eingefärbt wird (in diesem Beispiel in Rot):</p>
<div id="fig-venn" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-venn-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="media/images/venn/venn-diagramm.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-venn-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;2: Venn-Diagramm der Operationen auf Mengen
</figcaption>
</figure>
</div>
<p>Wir können auch in Python mit Mengen rechnen (wir beschränken uns dabei auf ganze Zahlen). Dazu müssen wir die Zahlen, die zu einer Menge gehören sollen, in einem Datentyp <code>set</code> zusammenfassen, der weitgehend unserem Mengenbegriff entpricht. Da alle Schlüsselwörter in Python (und damit auch die Bezeichnungen der Datentypen) in englischer Sprache angegeben werden, verwenden wir in diesem Tutorial ausschließlich die englischen Bezeichnungen.</p>
<div id="a2ea8e26" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="annotated-cell-1"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-1-1" class="code-annotation-target"><a href="#annotated-cell-1-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>}</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-1-2" class="code-annotation-target"><a href="#annotated-cell-1-2" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> <span class="bu">set</span>()</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-1-3" class="code-annotation-target"><a href="#annotated-cell-1-3" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> (<span class="bu">len</span>(A), <span class="bu">len</span>(B)) <span class="op">==</span> (<span class="dv">3</span>, <span class="dv">0</span>)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-1" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="1" data-code-annotation="1">Definition eines <code>set</code> A mit Mengenklammern</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="2" data-code-annotation="2">Definition eines leeren <code>set</code> B</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="3" data-code-annotation="3">Die Anzahl der Elemente eines <code>set</code> (auch die Kardinalität einer Menge genannt) wird mit der Funktion <code>len()</code> berechnet. Wir haben hier auf der linken und rechten Seite des <code>==</code> jeweils zwei Werte zu einem sogenannten <code>tuple</code> zusammengeführt, einem anderen Datentyp, bei dem die Elemente in runden Klammern angegeben werden. Auch ein <code>tuple</code> kann offensichtlich auf Gleichheit getestet werden.</span>
</dd>
</dl>
</div>
</div>
<p>Der Test auf Mitgliedschaft in einer Menge (<span class="math inline">\(\in\)</span>) wird mit dem Schlüsselwort <code>in</code> durchgeführt, das Gegenstück (<span class="math inline">\(\notin\)</span>) mit <code>not in</code>, wobei <code>not</code> ein sogenannter <em>Bool’scher Operator</em> ist, der das gegebene Argument verneint:</p>
<div id="4f47f3f3" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="dv">1</span> <span class="kw">in</span> A</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="dv">1</span> <span class="kw">not</span> <span class="kw">in</span> B</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Die beiden anderen Bool’schen Operatoren in Python sind <code>and</code> und <code>or</code> mit denen wir zwei Wahrheitsaussagen verknüpfen können:</p>
<div id="cdcbc10f" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="annotated-cell-3"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-3-1" class="code-annotation-target"><a href="#annotated-cell-3-1" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> (<span class="dv">1</span> <span class="kw">in</span> A) <span class="kw">or</span> (<span class="dv">1</span> <span class="kw">in</span> B)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-3-2" class="code-annotation-target"><a href="#annotated-cell-3-2" aria-hidden="true" tabindex="-1"></a>B.add(<span class="dv">1</span>)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-3-3" class="code-annotation-target"><a href="#annotated-cell-3-3" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> (<span class="dv">1</span> <span class="kw">in</span> A) <span class="kw">and</span> (<span class="dv">1</span> <span class="kw">in</span> B)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-3" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="1" data-code-annotation="1">Wenn (mindestens) eine der beiden Aussagen wahr ist, dann ist auch die mit <code>or</code> verknüpfte Aussage wahr.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="2" data-code-annotation="2">Wir fügen dem <code>set</code> B das Element 1 hinzu.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="3" data-code-annotation="3">Nur wenn beide Aussagen wahr sind, dann ist auch die mit <code>and</code> verknüpfte Aussage wahr.</span>
</dd>
</dl>
</div>
</div>
<p>Ob ein <code>set</code> B eine <em>echte</em> Teilmenge vom <code>set</code> A ist (<span class="math inline">\(B\subset A\)</span>), kann mit dem Operator <code>B &lt; A</code> getstet werden. Das ist dann gleichbedeutend mit <code>A &gt; B</code>, d.h. A ist die <em>Obermenge</em> von B:</p>
<div id="a396ce5e" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> B <span class="op">&lt;</span> A</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> A <span class="op">&gt;</span> B</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Und schließlich können wir auch die Mengenoperationen auf <code>set</code> A und B ausführen:</p>
<div id="c4e27ba5" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>B.add(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"A = "</span>, A)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"B = "</span>, B)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Vereinigungsmenge A ∪ B</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"A ∪ B = "</span>, A.union(B))</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> A.union(B) <span class="op">==</span> A <span class="op">|</span> B</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Schnittmenge A ∩ B</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"A ∩ B = "</span>, A.intersection(B))</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> A.intersection(B) <span class="op">==</span> A <span class="op">&amp;</span> B</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Differenz A \ B</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"A </span><span class="ch">\\</span><span class="st"> B = "</span>, A.difference(B))</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> A.difference(B) <span class="op">==</span> A <span class="op">-</span> B</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Symmetrische Differenz A ∆ B</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"A ∆ B = "</span>, A.symmetric_difference(B))</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> A.symmetric_difference(B) <span class="op">==</span> A <span class="op">^</span> B</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>A =  {1, 2, 3}
B =  {1, -1}
A ∪ B =  {1, 2, 3, -1}
A ∩ B =  {1}
A \ B =  {2, 3}
A ∆ B =  {2, 3, -1}</code></pre>
</div>
</div>
</section>
<section id="zahlenbereiche" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="zahlenbereiche"><span class="header-section-number">2</span> Zahlenbereiche</h2>
<p>Die Zahlen, mit denen wir rechnen, lassen sich in Teilmengen einteilen, die <strong>Zahlenbereiche</strong> genannt werden und üblicherweise in Mengenschreibweise dargestellt werden.</p>
<div id="fig-zahlenbereiche" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-zahlenbereiche-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="media/images/zahlenbereiche/zahlenbereiche.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-zahlenbereiche-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;3: Die Zahlenbereiche in Mengendarstellung
</figcaption>
</figure>
</div>
<section id="natürliche-zahlen" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="natürliche-zahlen"><span class="header-section-number">2.1</span> Natürliche Zahlen</h3>
<p>Die einfachsten Zahlen sind die, mit denen wir als Kind zählen gelernt haben: die Menge der <strong>natürlichen Zahlen</strong>. Wir benutzen diese Zahlen, um die <em>Anzahl</em> von Objekten einer Menge zu bestimmen, also zum <em>Zählen</em>.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Natürliche Zahlen
</div>
</div>
<div class="callout-body-container callout-body">
<p>Die Menge der natürlichen Zahlen sind die ganzen positiven Zahlen: <span class="math display">\[
\mathbb{N} = \{1,2,3,\dots\},
\]</span> wobei die drei Punkte anzeigen, dass die Folge der Zahlen nach dem gegeben Muster fortgeführt wird.</p>
</div>
</div>
</section>
<section id="sec-zahlen" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="sec-zahlen"><span class="header-section-number">2.2</span> Ganze Zahlen</h3>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Ganze Zahlen
</div>
</div>
<div class="callout-body-container callout-body">
<p>Die Menge der ganzen Zahlen ist wie folgt definiert: <span class="math display">\[
\mathbb{Z}=\{\dots,-3,-2,-1,0,1,2,3,\dots\}
\]</span> Das lässt sich dann unter Verwendung von Eigenschaften so schreiben: <span class="math display">\[
\mathbb{Z}=\{z \mid abs(z) \in \mathbb{N}\} \cup \{0\},
\]</span> wobei <span class="math inline">\(abs(z)\)</span> für den absoluten Wert von <span class="math inline">\(z\)</span> steht, also <span class="math inline">\(z\)</span> ohne Vorzeichen.</p>
</div>
</div>
<p>Es hat in Europa bis zum Ende des Mittelalters gedauert, bis sich die Verwendung von 0 als Zahl und die Rechnung mit negativen Zahlen durchgesetzt hat. Das erscheint auf den ersten Blick verwunderlich, da wir heute ganz selbstverständlich mit negativen Zahlen rechnen. Folgender Witz illustriert, was für ein großer intellektueller Schritt das war:</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Mathematiker Witz
</div>
</div>
<div class="callout-body-container callout-body">
<p>Stehen ein Theologe, ein Physiker und ein Mathematiker vor einem leeren Raum. Gemeinsam beobachten sie, wie drei Personen den Raum betreten und kurze Zeit fünf Personen wieder herauskommen.<br>
“Ein Wunder!”, ruft der Theologe.<br>
“Muss sich um einen Messfehler handeln”, murmelt der Physiker.<br>
Der Mathematiker entgegnet nur trocken: “Jetzt müssen nur zwei Leute wieder hineingehen, damit der Raum wieder leer ist”.</p>
</div>
</div>
<p>Mit der Mengenschreibweise können wir jetzt auch etwas komliziertere Mengen darstellen, zum Beispiel:</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Gerade und ungerade Zahlen
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Menge der geraden natürlichen Zahlen: <span class="math inline">\(\{2n \mid n \in \mathbb{N}\}\)</span></li>
<li>Menge der ungeraden ganzen Zahlen: <span class="math inline">\(\{2z-1 \mid z \in \mathbb{Z}\}\)</span></li>
</ul>
</div>
</div>
<p>Solche Zahlenmengen lassen sich auch in Python mit sogenannten <em>set comprehensions</em> erstellen, die eng an die mathematische Schreibweise von Mengen angelehnt sind:</p>
<div id="c05976ff" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Menge der geraden natürlichen Zahlen bis 20</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>}</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>{<span class="dv">2</span><span class="op">*</span>n <span class="cf">for</span> n <span class="kw">in</span> N}</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>{2, 4, 6, 8, 10, 12, 14, 16, 18, 20}</code></pre>
</div>
</div>
<p>Hier haben wir gegenüber der mathematischen Notation lediglich den vertikalen Strich <span class="math inline">\(\mid\)</span> durch das Schlüsselwort <code>for</code> ersetzt, und die Menge der natürlichen Zahlen, für die die Anweisung gelten soll, zuvor explizit als <code>set</code> definiert.</p>
<p>Natürlich ist es etwas umständlich, die Elemente der Ausgangsmenge konkret aufzuzählen; Python bieter daher eine <code>range()</code> Funktion an, die zwei ganze Zahlen als Argumente akzeptiert und daraus ein Intervall berechnet, das als Ausgangsmenge dienen kann:</p>
<div id="489913e9" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Menge der ungeraden Zahlen im Intervall [-5, 17)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>{<span class="dv">2</span><span class="op">*</span>z<span class="op">-</span><span class="dv">1</span> <span class="cf">for</span> z <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">9</span>)}</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>{-5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15}</code></pre>
</div>
</div>
<p>Um zu verstehen was hier passiert, müssen wir uns mit der Intervallschreibweise von Zahlenmengen vertraut machen:</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Intervalle
</div>
</div>
<div class="callout-body-container callout-body">
<p>Zahlenmengen können mit Hilfe von Intervallen beschrieben werden. Wenn die Intervallgrenzen mit den ganzen Zahlen <span class="math inline">\(a,b\)</span> angegeben werden, dann besteht ein Intervall aus allen ganzen Zahlen <span class="math inline">\(x\)</span>, die zwischen diesen Grenzen liegen. Für so beschränkte Intervalle gelten folgende Regeln:</p>
<ul>
<li><span class="math inline">\([a,b]= \{x \mid x \in \mathbb{Z} \ \mathrm{und} \ a \leq x \leq b\}\)</span> (geschlossenes Intervall)</li>
<li><span class="math inline">\((a,b)= \{x \mid x \in \mathbb{Z} \ \mathrm{und} \ a &lt; x &lt; b\}\)</span> (offenes Intervall)</li>
</ul>
</div>
</div>
<p>Eckige Klammern <span class="math inline">\([]\)</span> bedeuten also, dass der jeweilige Begrenzer mit zur Menge gehört, runde Klammern <span class="math inline">\(()\)</span>dagegen, dass der Begrenzer nicht mehr zur Menge gehört. In Python erzeugt der Aufruf von <code>range(a, b)</code> immer ein halboffenes Intervall in der Form <span class="math inline">\([a, b)\)</span>, so dass also <code>a</code> zur Menge gehört, <code>b</code> aber nicht. Das erklärt, warum im letzten Code-Beispiel das Intervall <span class="math inline">\([-5, 17)\)</span> angegeben wurde, mit dem Ergebnis <span class="math inline">\(\{-5,-3,\dots,13,15\}\)</span>, da 17 nicht mehr zum Intervall gehört.</p>
<p>Die Angabe der <em>range</em> mit <code>range(-2, 9)</code> ist trotzdem etwas verwirrend, liegt aber daran, dass <span class="math inline">\(2\cdot -2-1=-5\)</span> und <span class="math inline">\(2\cdot 8-1=15\)</span> ist (die 9 in der <code>range</code> gehört nicht mehr zum Intervall und Python wählt den nächstkleineren Wert 8).<br>
Um diese Verwirrung auszuschließen, können wir eine <em>set comprehension</em> auch anders definieren, und zwar indem wir die Forderung für <em>ungerade</em> als zusätzliche Bedingung formulieren:</p>
<div id="98d67143" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Menge der ungeraden Zahlen im Intervall [-5, 17)</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>{z <span class="cf">for</span> z <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">5</span>, <span class="dv">17</span>) <span class="cf">if</span> z <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span>}</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>{-5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15}</code></pre>
</div>
</div>
<p>Hier haben wir den Modulo Operator <code>%</code> verwendet, der den Rest einer <a href="../arithmetik/2-teiler.html#sec-division">ganzzahligen Division</a> ausgibt, um zu testen, ob <code>z</code> eine ungerade Zahl ist.</p>
</section>
<section id="rationale-zahlen" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="rationale-zahlen"><span class="header-section-number">2.3</span> Rationale Zahlen</h3>
<p>Eine <strong>rationale Zahl</strong> ist eine Zahl, die als Verhältnis (lateinisch <em>ratio</em>) zweier ganzer Zahlen dargestellt werden kann. Um die Menge aller rationalen Zahlen zu bezeichnen, wird das Zeichen <span class="math inline">\(\mathbb{Q}\)</span> verwendet (von <em>Quotient</em>). <span class="math inline">\(\mathbb{Q}\)</span> umfasst alle Zahlen, die sich als Bruch darstellen lassen, der sowohl im Zähler als auch im Nenner ganze Zahlen enthält.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Rationale Zahlen
</div>
</div>
<div class="callout-body-container callout-body">
<p>Die Menge der rationalen Zahlen ist wie folgt definiert: <span class="math display">\[
\mathbb{Q}=\left\{\frac{m}{n} \mid m, n \in \mathbb{Z}, n \neq 0\right\}
\]</span></p>
</div>
</div>
<p>Der Nenner darf dabei nicht Null sein, da die Division durch 0 nicht definiert ist. Wir werden im Rahmen der Lektion <a href="">Bruchrechnung</a> näher auf das Rechnen mit Brüchen und damit auf das Rechnen mit rationalen Zahlen eingehen.</p>
<p>Jede rationale Zahl kann als endlicher oder unendlich periodischer Dezimalbruch dargestellt werden.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Dezimalbruch
</div>
</div>
<div class="callout-body-container callout-body">
<p>Der Dezimalbruch einer rationalen Zahl ist die Darstellung der rationalen Zahl als Dezimalzahl, aslo als Zahl mit Stellen hinter dem Komma. Bei einem endlichen Dezimalbruch ist die Anzahl der Stellen hinter dem Komma endlich, bei einem periodischen Dezimalbruch wiederholen sich die Stellen nach dem Komma nach einem gewissen Muster (Periode).</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Beispiele für Dezimalbrüche
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><span class="math inline">\(\frac{3}{2}=1,5\)</span></li>
<li><span class="math inline">\(-\frac{1}{8}=-0,125\)</span></li>
<li><span class="math inline">\(\frac{4}{3}=1,33333=1,\overline{3}\)</span> (der periodische Teil wird überstrichen)</li>
<li><span class="math inline">\(-\frac{16}{11}=-1,454545=-1,\overline{45}\)</span></li>
</ul>
</div>
</div>
<p>In Python erzeugt der Divisionsoperator <code>/</code> eine Dezimalzahl, die hier allerdings <em>floating point number</em> genannt wird und dem Datentyp <code>float</code> zugeordnet ist. Beachte den <strong>point</strong> in der englischen Bezeichnung: das deutsche <em>Dezimalkomma</em> wird zum <em>Dezimalpunkt</em> im gesamten englischen Sprachraum: <span class="math inline">\(1,5 (de)= 1.5(en)\)</span>.</p>
<div id="0344997d" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"3/2 ="</span>, <span class="dv">3</span> <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"-1/8 ="</span>, <span class="op">-</span><span class="dv">1</span> <span class="op">/</span> <span class="dv">8</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"4/3 ="</span>, <span class="dv">4</span> <span class="op">/</span> <span class="dv">3</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co"># eine periodische Darstellung ist nicht möglich, aber wir können runden</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"-16/11 ="</span>, <span class="bu">round</span>(<span class="op">-</span><span class="dv">16</span><span class="op">/</span><span class="dv">11</span>, <span class="dv">2</span>)) <span class="co"># runden auf 2 Stellen nach dem Punkt</span></span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>3/2 = 1.5
-1/8 = -0.125
4/3 = 1.3333333333333333
-16/11 = -1.45</code></pre>
</div>
</div>
</section>
<section id="reelle-zahlen" class="level3" data-number="2.4">
<h3 data-number="2.4" class="anchored" data-anchor-id="reelle-zahlen"><span class="header-section-number">2.4</span> Reelle Zahlen</h3>
<p>Die Menge der <strong>reellen Zahlen</strong> erweitert den Zahlenbereich der <em>rationalen Zahlen</em> um die <strong>irrationalen Zahlen</strong>, also Zahlen, die sich nicht als Bruch zweier ganzer Zahlen darstellen lassen, und damit auch nicht als endliche oder periodische Dezimalzahl. Die Menge der reellen Zahlen wird mit <span class="math inline">\(\mathbb{R}\)</span> bezeichnet.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Irrationale Zahlen
</div>
</div>
<div class="callout-body-container callout-body">
<p>Als irrationale Zahlen bezeichnen wir die Menge aller Elemente von <span class="math inline">\(\mathbb{R}\)</span>, die nicht in <span class="math inline">\(\mathbb{Q}\)</span> liegen: <span class="math display">\[
\mathrm{irrationale \ Zahlen:} \quad \mathbb{R} \ \backslash \ \mathbb{Q}
\]</span></p>
</div>
</div>
<p>In der Antike hatten die <em>Pythagoräer</em> (die Schüler des berühmten Mathematikers <em>Pythagoras</em>) angenommen, dass sich alles im Universum mit rationalen Zahlen darstellen lässt. Betrachtet man aber ein Quadrat der Seitenlänge eins, so sollte die Länge <span class="math inline">\(x\)</span> von dessen Diagonale, folgend dem <em>Satz des Pythagoras</em>, die Gleichung <span class="math inline">\(x^2 = 2\)</span> erfüllen, und damit <span class="math inline">\(x=\sqrt{2}\)</span>.<br>
Aus rein geometrischen Überlegungen sollte es also eine Zahl geben, die diese Darstellung besitzt. Tragischerweise hat ausgerechnet <em>Hippasos</em>, ein Schüler des <em>Pythagoras</em>, mit Hilfe dessen Satzes bewiesen, dass <span class="math inline">\(\sqrt{2}\)</span> keine rationale Zahl sein kann. (siehe ???).</p>
<p>Die erste bekannte irrationale Zahl ist also <span class="math inline">\(\sqrt{2}\)</span>; aus der Wurzelrechnung ??? folgt aber, dass es noch unendlich viele weitere solcher irrationaler Zahlen gibt, die auch als <em>algebraische</em> irrationale Zahlen bezeichnet werden.<br>
<em>Algebraisch</em> deshalb, weil sie als Lösung einer “gewöhnlichen” algebraischen Gleichung angegben werden können, zum Beispiel ist <span class="math inline">\(\sqrt{5}\)</span> die Lösung der Gleichung <span class="math inline">\(x^2=5\)</span>.</p>
<p>Es gibt aber auch irrationale Zahlen, die nicht als Lösung einer algebraischen Gleichung angegeben werden können, man sagt, sie “übersteigen” (<em>transzendieren</em>) die Möglichkeiten der Algebra, und nennt sie daher <em>transzendente Zahlen</em>. Die bekanntesten dieser <em>transzendenten</em> Zahlen sind die Kreiszahl <span class="math inline">\(\pi\)</span> und die eulersche Zahl <span class="math inline">\(e\)</span>.</p>
<p>Die Zahlen in <span class="math inline">\(\mathbb{R}\)</span> können in einer <em>Zahlengeraden</em> veranschaulicht werden, die verdeutlicht, dass die Menge der reelen Zahlen über die Vergleiche <span class="math inline">\(&lt; \mathrm{und}&gt;\)</span> eine <em>lineare Ordnung</em> bildet. Das beudeutet, dass wir für zwei verschiedene reelle Zahlen immer sagen können, welche von beiden größer bzw. kleiner ist:</p>
<div id="fig-gerade" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-gerade-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="media/images/zahlengerade/zahlengerade.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-gerade-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4: Ausschnitt der Zahlengeraden der reellen Zahlen
</figcaption>
</figure>
</div>
<p>Infolge dieser <em>linearen Ordung</em> sind Intervalle (siehe <a href="#sec-zahlen" class="quarto-xref">Kapitel&nbsp;2.2</a>) auch in <span class="math inline">\(\mathbb{R}\)</span> eindeutig definiert, z.B. enthält das Intervall <span class="math inline">\((e, \pi)\)</span> alle reellen Zahlen, die größer als <span class="math inline">\(e\)</span> und kleiner als <span class="math inline">\(\pi\)</span> sind.</p>
</section>
</section>
<section id="zahlensysteme" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="zahlensysteme"><span class="header-section-number">3</span> Zahlensysteme</h2>
<p>Es gibt verschiedene Möglichkeiten zur Darstellung von <em>Zahlen</em>. Die einzelnen Zeichen zur Darstellung von Zahlen sind die <em>Ziffern</em>. Grundsätzlich unterscheidet man zwischen sogenannten Positionssystemen und Additionssystemen.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Positions- und Additionssysteme
</div>
</div>
<div class="callout-body-container callout-body">
<p>Bei einem <em>Positionssystem</em> (auch <em>Stellenwertsystem</em> genannt) ist der Wert einer Ziffer abhängig von der <em>Position</em> dieser Ziffer innerhalb der Zahl.<br>
Bei <em>Additionssystemen</em> wird der Wert aller Ziffern einfach addiert, um den Wert der Zahl festzulegen.</p>
</div>
</div>
<section id="römische-zahlen" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="römische-zahlen"><span class="header-section-number">3.1</span> Römische Zahlen</h3>
<p><strong>Römische Zahlen</strong> sind ein Beispiel eines Additionssytems. Die Ziffern sind hier lateinische Großbuchstaben, denen ein fester Wert zugewiesen wird:</p>
<div id="tbl-ziffern" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-ziffern-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Tabelle&nbsp;1: Römische Ziffern
</figcaption>
<div aria-describedby="tbl-ziffern-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<thead>
<tr class="header">
<th>Buchstabe</th>
<th><code>I</code></th>
<th><code>V</code></th>
<th><code>X</code></th>
<th><code>L</code></th>
<th><code>C</code></th>
<th><code>D</code></th>
<th><code>M</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Wert</td>
<td>1</td>
<td>5</td>
<td>10</td>
<td>50</td>
<td>100</td>
<td>500</td>
<td>1000</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Da die Werte der Ziffern bei einem Additionssystem einfach zusammengezählt werden, ist z.B. der Wert der römischen Zahl <code>XVII</code> gleich 17.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Subtraktionsregel
</div>
</div>
<div class="callout-body-container callout-body">
<p>Die Subtraktionsregel ist eine übliche, verkürzende Schreibweise, mit der vermieden wird, vier gleiche Ziffern in direkter Aufeinanderfolge zu schreiben.<br>
Die Subtraktionsregel besagt, dass die Ziffern <code>I</code>, <code>X</code> und <code>C</code> einer ihrer beiden jeweils nächstgrößeren Ziffern vorangestellt werden dürfen und dann in ihrem Zahlwert von dessen Wert abzuziehen sind:</p>
<ul>
<li><code>I</code> vor <code>V</code> oder <code>X</code>: <code>IV</code> = 4, <code>IX</code> = 9</li>
<li><code>X</code> vor <code>L</code> oder <code>C</code>: <code>XL</code> = 40, <code>XC</code> = 90</li>
<li><code>C</code> vor <code>D</code> oder <code>M</code>: <code>CD</code> = 400, <code>CM</code> = 900</li>
</ul>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Der Wert der römischen Zahl <code>MCMLXXXIV</code>
</div>
</div>
<div class="callout-body-container callout-body">
<p><code>MCMLXXXIV</code> = <span class="math inline">\(1000+(1000-100)+50+(3\cdot10)+(5-1)=1984\)</span></p>
</div>
</div>
<p>Das Rechnen mit römischen Zahlen ist allerdings recht schwierig; hierfür wurden Hilfsmittel wie das <a href="https://de.wikipedia.org/wiki/Rechnen_auf_Linien">Rechenbrett</a> und der <a href="https://de.wikipedia.org/wiki/Abakus_(Rechenhilfsmittel)">Abakus</a> verwendet. Dabei werden die römischen Zahlen in ein Positionssystem überführt und Werten in der Form von Rechenmünzen oder Kugeln zugeordnet, mit denen dann die Rechenoperationen durchgeführt werden. Das Rechnen mit Rechenbrett und Abakus war bis zum Ende des Mittelalters weit verbreitet und wurde erst durch die Einführung der indischen Zahlenschrift und des heute gebräuchlichen Dezimalsystems (siehe <a href="#sec-dezimal" class="quarto-xref">Kapitel&nbsp;3.2</a>) abgelöst.</p>
<p>Wir wollen aber nicht mit dem Abakus rechnen, sondern mit Python; dazu entwickeln wir eine Funktion, die römische Zahlen in das Dezimalsystem überführt. Als ersten Schritt definieren wir hierzu ein <em>dictionary</em>, ein Objekt mit dem Datentyp <code>dict</code>:</p>
<div id="81aa7744" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>rom <span class="op">=</span> {<span class="st">'I'</span>: <span class="dv">1</span>, <span class="st">'V'</span>: <span class="dv">5</span>, <span class="st">'X'</span>: <span class="dv">10</span>, <span class="st">'L'</span>: <span class="dv">50</span>, <span class="st">'C'</span>: <span class="dv">100</span>, <span class="st">'D'</span>: <span class="dv">500</span>, <span class="st">'M'</span>: <span class="dv">1000</span>}</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Ein <code>dict</code> ist ein Objekt, dessen Elemente sogenannte <em>key-value pairs</em> sind, also Paare von Schlüsseln und zugehörigen Werten. Diese Paare werden in Mengenklammern geschrieben und mit einem Komma voneinander getrennt. Ein einzelnes Paar wird dabei in Form <code>k: v</code> geschrieben, also Schlüssel, gefolgt von Doppelpunkt, gefolgt von zugeordnetem Wert. Das Leerzeichen ist optional und kann weggelassen werden. Wir haben unser <em>dictionary</em> <code>rom</code> mit den Werten aus <a href="#tbl-ziffern" class="quarto-xref">Tabelle&nbsp;1</a> initialisiert.</p>
<p>Die Elemente können dann in einer <code>for</code> Schleife durchlaufen und ausgegeben oder manipuliert werden:</p>
<div id="1fc748d1" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (k, v) <span class="kw">in</span> rom.items():</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">"Schlüssel: "</span>, k, <span class="st">", "</span>,<span class="st">"Wert: "</span>, v)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Schlüssel:  I ,  Wert:  1
Schlüssel:  V ,  Wert:  5
Schlüssel:  X ,  Wert:  10
Schlüssel:  L ,  Wert:  50
Schlüssel:  C ,  Wert:  100
Schlüssel:  D ,  Wert:  500
Schlüssel:  M ,  Wert:  1000</code></pre>
</div>
</div>
<p>Damit können wir dann die eigentliche Funktion definieren:</p>
<div id="843e6f77" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="annotated-cell-12"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><a class="code-annotation-anchor" data-target-cell="annotated-cell-12" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-12-1" class="code-annotation-target"><a href="#annotated-cell-12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> roman_to_decimal(roman):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-12" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-12-2" class="code-annotation-target"><a href="#annotated-cell-12-2" aria-hidden="true" tabindex="-1"></a>  res <span class="op">=</span> <span class="dv">0</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-12" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-12-3" class="code-annotation-target"><a href="#annotated-cell-12-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(roman)):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-12" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-12-4" class="code-annotation-target"><a href="#annotated-cell-12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> rom[roman[i]] <span class="op">&gt;</span> rom[roman[i<span class="op">-</span><span class="dv">1</span>]]:</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-12" data-target-annotation="5" onclick="event.preventDefault();">5</a><span id="annotated-cell-12-5" class="code-annotation-target"><a href="#annotated-cell-12-5" aria-hidden="true" tabindex="-1"></a>      res <span class="op">+=</span> rom[roman[i]] <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> rom[roman[i<span class="op">-</span><span class="dv">1</span>]]</span>
<span id="annotated-cell-12-6"><a href="#annotated-cell-12-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-12" data-target-annotation="6" onclick="event.preventDefault();">6</a><span id="annotated-cell-12-7" class="code-annotation-target"><a href="#annotated-cell-12-7" aria-hidden="true" tabindex="-1"></a>      res <span class="op">+=</span> rom[roman[i]]</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-12" data-target-annotation="7" onclick="event.preventDefault();">7</a><span id="annotated-cell-12-8" class="code-annotation-target"><a href="#annotated-cell-12-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> res</span>
<span id="annotated-cell-12-9"><a href="#annotated-cell-12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-12-10"><a href="#annotated-cell-12-10" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> roman_to_decimal(<span class="st">"MCMLXXXIV"</span>) <span class="op">==</span> <span class="dv">1984</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-12" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-12" data-code-lines="1" data-code-annotation="1">Signatur der Funktion <code>roman_to_decimal</code>. Wir könnten die Bezeichner in Python auch in Deutsch angeben. Um nicht deutschsprachigen Entwicklern aber die Möglichkeit zu geben, unsere Programme zu verstehen, verwenden wie lieber aussagekräftige englische Bezeichner. Der Python Konvention folgend, verwenden wir dabei für zusammengesetzte Wörter die sogenannte <em>snake case</em> Schreibweise, bei der die einzelnen Worte mit Unterstich verbunden werden.</span>
</dd>
<dt data-target-cell="annotated-cell-12" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-12" data-code-lines="2" data-code-annotation="2">Initialisierung des Ergebnisses mit <code>0</code>. Wir verwenden hier den Bezeichner <code>res</code>, als Kurzform des englischen <em>result</em>.</span>
</dd>
<dt data-target-cell="annotated-cell-12" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-12" data-code-lines="3" data-code-annotation="3">Beginn der <code>for</code> Schleife: wenn wir uns in der Schleife auf den Index des zu durchlaufenden Objekts beziehen (also auf die Position des aktuellen Wertes in dem Objekt), dann bezeichen wir die Schleifenvariable meist mit <code>i</code>. Das zu durchlaufende Objekt ist in diesem Fall eine <code>range</code>, also ein Intervall. Wenn die <code>range()</code> Funktion mit nur einem Argument <span class="math inline">\(a\)</span> aufgerufen wird (hier die Länge der Zeichenkette (engl. <em>string</em>) <code>roman</code>), dann erzeugt Python ein Intervall <span class="math inline">\([0, a)\)</span>.</span>
</dd>
<dt data-target-cell="annotated-cell-12" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-12" data-code-lines="4" data-code-annotation="4">Wir testen, ob der Wert der aktuellen Ziffer größer ist als der Wert der vorhergehenden Ziffer. In diesem Fall müssen wir die Subtraktionsregel anwenden. Der Test wird nicht für die erste Ziffer durchgeführt.</span>
</dd>
<dt data-target-cell="annotated-cell-12" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-12" data-code-lines="5" data-code-annotation="5">Wenn die Subtraktionsregel greift, dann ziehen wir zweimal den Wert der vorhergehenden Ziffer vom bisherigen Resultat ab. Wir müssen zweimal abziehen, da im vorangehenden Schleifendurchlauf dieser Wert fälschlicherweise addiert statt subtrahiert wurde.</span>
</dd>
<dt data-target-cell="annotated-cell-12" data-target-annotation="6">6</dt>
<dd>
<span data-code-cell="annotated-cell-12" data-code-lines="7" data-code-annotation="6">Wenn die Subtraktionsregel nicht greift, dann addieren wir einfach den Wert der aktuellen Ziffer zum bisherigen Ergebnis.</span>
</dd>
<dt data-target-cell="annotated-cell-12" data-target-annotation="7">7</dt>
<dd>
<span data-code-cell="annotated-cell-12" data-code-lines="8" data-code-annotation="7">Rückgabe des Ergebnisses als Wert der Funktion.</span>
</dd>
</dl>
</div>
</div>
</section>
<section id="sec-dezimal" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="sec-dezimal"><span class="header-section-number">3.2</span> Dezimalsystem</h3>
<p>Das <strong>Dezimalsystem</strong> ist ein Positionssystem mit zehn Ziffern (von lateinisch <em>decem</em>, zehn) und ist die heute gebräuchliche Darstellung der Zahlen. Das Dezimalsystem hat sich aus dem indischen Zahlensystem entwickelt, das bereits ab dem 3. Jahrhundert v. Chr. in Indien in Gebrauch war. Im Jahr 628 n.&nbsp;Chr. führte der indische Mathematiker <em>Brahmagupta</em> die 0 als vollwertige Ziffer ein.</p>
<p>Wir verwenden heute aber nicht indische, sondern arabischen Ziffern. Das liegt daran, das sich das indische Zahlensystem im Mittelalter über den arabischen Sprachraum nach Europa ausgebreitet hat. Die Regeln für das Rechnen mit arabischen Zahlen wurden in Europa erstmals von dem italienischen Mathematiker <em>Leonardo da Pisa</em> (besser bekannt als <em>Fibonacci</em>) beschrieben, die er in seinem “Rechenbuch” <em>Liber abbaci</em> im Jahr 1201 zusammengefasst hat.</p>
<p>Der Wert einer Ziffer in einer Dezimalzahl ergibt sich durch die Position der Ziffer innerhalb der Zahl. Um diesen Wert zu bestimmen, multiplizieren wir die Ziffer mit einer Zehnerpotenz <span class="math inline">\(10^i\)</span>, wobei <span class="math inline">\(i\)</span> die Position der Ziffer in der Zahl ist. Bei ganzen Zahlen wird dabei der Einerstelle (die letzte Ziffer ganz rechts in der Zahl) der Wert <span class="math inline">\(i=0\)</span> zugeordnet, der Zehnerstelle der Wert <span class="math inline">\(i=1\)</span>, der Hunderterstelle der Wert <span class="math inline">\(i=2\)</span>, usw. Die sich daraus ergebenden Werte werden dann addiert:</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Berechnung des Wertes einer ganzen Zahl
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math inline">\(1984 = 4\cdot10^0+8\cdot 10^1+9\cdot10^2+1\cdot10^3=4+80+900+1000\)</span></p>
</div>
</div>
<p>Die Berechnung des Wertes eines Dezimalbruchs (einer Dezimalzahl mit Stellen nach dem Komma) erfolgt analog: der Wert einer Ziffer innerhalb der Zahl ergibt sich dadurch, dass die <span class="math inline">\(n\)</span>-te Stelle vor dem Komma mit <span class="math inline">\(10^{n-1}\)</span> und die <span class="math inline">\(m\)</span>-te Stelle nach dem Komma mit <span class="math inline">\(10^{-m}\)</span> multipliziert wird.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Der Wert einer Dezimalzahl
</div>
</div>
<div class="callout-body-container callout-body">
<p>Ist <span class="math inline">\(a\)</span> eine Zahl mit den Ziffern <span class="math inline">\(a_n,a_{n-1},\cdots,a_1,a_0\)</span> vor dem Komma und den Ziffern <span class="math inline">\(a_{-1},a_{-2},\cdots,a_{-m}\)</span> nach dem Komma, dann gilt: <span id="eq-dezimalzahl"><span class="math display">\[
a=\sum_{i=-m}^n a_i\cdot 10^i
\tag{1}\]</span></span> Die Stellen mit <span class="math inline">\(i \geq 0\)</span> bilden den ganzen Teil, die mit <span class="math inline">\(i&lt;0\)</span> den gebrochenen Teil der Zahl.</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Berechnung des Wertes einer Dezimalzahl
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math display">\[
\begin{align}
486,25 &amp;= 4\cdot10^2+8\cdot10^1+6\cdot10^0+2\cdot10^{-1}+5\cdot10^{-2}\\
&amp;= 400+80+6+0,2+0,05
\end{align}
\]</span></p>
</div>
</div>
<p>Aus diesem gleichförmigen Aufbau der Dezimalzahlen ergeben sich dann die einfachen Rechenoperationen, die wir schon aus der Grundschule kennen. Zum Beispiel können wir Dezimalzahlen addieren, indem wir ihre jeweiligen Dezimalstellen addieren und bei einem Ergbnis <span class="math inline">\(\geq 10\)</span> die <span class="math inline">\(1\)</span> auf die nächste Stelle übertragen:</p>
<div id="fig-addition" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-addition-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-video"><video id="video_shortcode_videojs_video1" class="video-js vjs-default-skin vjs-fluid" controls="" preload="auto" data-setup="{}" title=""><source src="media/videos/addition/480p15/addition.mp4"></video></div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-addition-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;5: Addition mit Übertrag
</figcaption>
</figure>
</div>
<p>Hier sehen wir auch die besondere Rolle der <span class="math inline">\(0\)</span>: obwohl sie selbst keinen Wert besitzt, ist sie doch als Platzhalter in einem Positionssystem unentbehrlich.</p>
</section>
<section id="dualsystem" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="dualsystem"><span class="header-section-number">3.3</span> Dualsystem</h3>
<p>Das <strong>Dualsystem</strong> ist ein Positionssystem zur Basis 2, es gibt also nur zwei Ziffern <span class="math inline">\(0,1\)</span>. Es wird deshalb auch <em>Binärsystem</em> oder <em>Zweiersystem</em> genannt.</p>
<p>Das Dualsystem spielt eine entscheidende Rolle in der Digitaltechnik, in der Zahlen durch elektrische Zustände dargestellt werden. In einem elektronischen Schaltkreis gibt es nur zwei Zustände: entweder es liegt ein Signal vor (Strom an), oder eben nicht (Strom aus). Diese Zustände werden zu Binärzahlen kombiniert, mit denen dann ein Computer “rechnet”.<br>
<em>Informatiker</em> (Menschen, die Computerwissenschaften studiert haben) erzählen sich gerne folgenden Witz:</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Informatiker Witz
</div>
</div>
<div class="callout-body-container callout-body">
<p>Es gibt 10 Arten von Menschen:</p>
<ul>
<li>diejenigen, die das Binärsystem verstanden haben</li>
<li>diejenigen, die es <em>nicht</em> verstanden haben</li>
</ul>
</div>
</div>
<p>Wenn du darüber lachen kannst, dann hast du es verstanden.</p>
<p>Auch Python rechnet intern mit Binärzahlen, d.h. jede Eingabe von Dezimalzahlen wird in Binärzahlen umgewandelt, mit denen die notwendigen Berechnungen durchgeführt werden. Bei der Ausgabe des Ergebnisses werden diese Binärzahlen dann wieder zurück ins Dezimalsystem konvertiert.</p>
<p>Dieser Vorgang ist für den Anwender <em>transparent</em>, d.h. wir als Programmierer merken nichts von der internen Umwandlung. Für die Berechnung des Wertes einer ganzen Binärzahl gelten die Regeln aus <a href="#sec-dezimal" class="quarto-xref">Kapitel&nbsp;3.2</a> analog, nur dass wir jede Ziffer nun mit einer Zweierpotenz <span class="math inline">\(2^i\)</span> multiplizieren; jede Ziffer hat dann den doppelten Stellenwert der ihr rechts folgenden Ziffer:</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Berechnung des Wertes einer Dualzahl
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math display">\[
\begin{align}
0100\ 1101_2&amp;=0\cdot2^7+1\cdot2^6+0\cdot2^5+0\cdot2^4+1\cdot2^3+1\cdot2^2+0\cdot2^1+1\cdot2^0\\
&amp;=0+64+0+0+8+4+0+1=77_{10}
\end{align}
\]</span></p>
</div>
</div>
<p>Werden mehrere Zahlensysteme gleichzeitig benutzt, so ist es zur Vermeidung von Irrtümern üblich, die Basis als Index anzuhängen. Dualzahlen stellen wir zur besseren Lesbarkeit in Vierer-Blöcken dar.</p>
<p>Die Berechnung reeller Zahlen im Dualsystem erfolgt analog zu <a href="#eq-dezimalzahl" class="quarto-xref">Gleichung&nbsp;1</a>. Der Wert einer Ziffer im Dualsytem (engl. <em>bit</em>, als Kurzform für <em>binary digit</em>) ergibt sich dadurch, dass die <span class="math inline">\(n\)</span>-te Stelle mit <span class="math inline">\(2^{n-1}\)</span> und die <span class="math inline">\(m\)</span>-te Stelle nach dem Komma mit <span class="math inline">\(2^{-m}\)</span> multipliziert wird:</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Der Wert einer Dualzahl
</div>
</div>
<div class="callout-body-container callout-body">
<p><span id="eq-dualzahl"><span class="math display">\[
b=\sum_{i=-m}^n b_i\cdot 2^i
\tag{2}\]</span></span></p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Berechnung einer reellen Zahl im Dualsystem
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math display">\[
\begin{align}
1011,01_2&amp;=1\cdot2^3+0\cdot2^2+1\cdot2^1+1\cdot2^0+0\cdot2^{-1}+1\cdot2^{-2}\\
&amp;=8+2+1+\frac{1}{4}=11,25_{10}
\end{align}
\]</span></p>
</div>
</div>
<p>Mit der Berechnung des Wertes einer Dualzahl haben wir diese Zahl in eine Dezimalzahl umgerechnet; dies wird auch als <em>Konvertierung</em> bezeichnet. Mit diesen Regeln können wir jetzt eine Dualzahl mit Python in eine Dezimalzahl konvertieren:</p>
<div id="d135f2d6" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="annotated-cell-13"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-13-1"><a href="#annotated-cell-13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bin_to_dec(binary):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-13" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-13-2" class="code-annotation-target"><a href="#annotated-cell-13-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">assert</span> <span class="bu">type</span>(binary) <span class="op">==</span> <span class="bu">str</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-13" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-13-3" class="code-annotation-target"><a href="#annotated-cell-13-3" aria-hidden="true" tabindex="-1"></a>  s <span class="op">=</span> binary.split(<span class="st">','</span>)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-13" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-13-4" class="code-annotation-target"><a href="#annotated-cell-13-4" aria-hidden="true" tabindex="-1"></a>  n <span class="op">=</span> <span class="bu">len</span>(s[<span class="dv">0</span>])</span>
<span id="annotated-cell-13-5"><a href="#annotated-cell-13-5" aria-hidden="true" tabindex="-1"></a>  m <span class="op">=</span> <span class="dv">1</span></span>
<span id="annotated-cell-13-6"><a href="#annotated-cell-13-6" aria-hidden="true" tabindex="-1"></a>  decimal <span class="op">=</span> <span class="dv">0</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-13" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-13-7" class="code-annotation-target"><a href="#annotated-cell-13-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> bit <span class="kw">in</span> s[<span class="dv">0</span>]:</span>
<span id="annotated-cell-13-8"><a href="#annotated-cell-13-8" aria-hidden="true" tabindex="-1"></a>    decimal <span class="op">+=</span> <span class="bu">int</span>(bit) <span class="op">*</span> <span class="dv">2</span><span class="op">**</span>(n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="annotated-cell-13-9"><a href="#annotated-cell-13-9" aria-hidden="true" tabindex="-1"></a>    n <span class="op">-=</span> <span class="dv">1</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-13" data-target-annotation="5" onclick="event.preventDefault();">5</a><span id="annotated-cell-13-10" class="code-annotation-target"><a href="#annotated-cell-13-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> bit <span class="kw">in</span> s[<span class="dv">1</span>]:</span>
<span id="annotated-cell-13-11"><a href="#annotated-cell-13-11" aria-hidden="true" tabindex="-1"></a>    decimal <span class="op">+=</span> <span class="bu">int</span>(bit) <span class="op">*</span> <span class="dv">2</span><span class="op">**</span>(<span class="op">-</span>m)</span>
<span id="annotated-cell-13-12"><a href="#annotated-cell-13-12" aria-hidden="true" tabindex="-1"></a>    m <span class="op">+=</span> <span class="dv">1</span></span>
<span id="annotated-cell-13-13"><a href="#annotated-cell-13-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> decimal</span>
<span id="annotated-cell-13-14"><a href="#annotated-cell-13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-13-15"><a href="#annotated-cell-13-15" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> bin_to_dec(<span class="st">"1011,01"</span>) <span class="op">==</span> <span class="fl">11.25</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-13" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-13" data-code-lines="2" data-code-annotation="1">Wir erwarten, dass die Funktion mit einem Argument vom Typ <code>str</code> (also einer Zeichenkette) aufgerufen wird. Wenn nicht, dann ergeben die nachfolgenden Berechnungen keinen Sinn, und wir brechen das Programm ab.</span>
</dd>
<dt data-target-cell="annotated-cell-13" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-13" data-code-lines="3" data-code-annotation="2">Teilen des Eingabestrings in zwei Hälften, den Teil vor dem Komma und den Teil nach dem Komma. Das Ergebnis ist eine Liste mit zwei Teilstrings.</span>
</dd>
<dt data-target-cell="annotated-cell-13" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-13" data-code-lines="4" data-code-annotation="3">Belegen der Variablen <code>n</code> mit der Länge des ersten Teilstrings (zur Erinnerung: der Index in Python beginnt mit 0).</span>
</dd>
<dt data-target-cell="annotated-cell-13" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-13" data-code-lines="7" data-code-annotation="4">Wir durchlaufen die Zeichen im ersten Teilstring (die Ziffern vor dem Komma) und berechnen den Wert der jeweiligen Ziffer nach der Formel von <a href="#eq-dualzahl" class="quarto-xref">Gleichung&nbsp;2</a>. Die Schleifenvariable haben wir hier <code>bit</code> genannt. Nach jedem Durchlauf verringern wir den Wert von <code>n</code> um 1.</span>
</dd>
<dt data-target-cell="annotated-cell-13" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-13" data-code-lines="10" data-code-annotation="5">Berechnung der Werte für die <em>bits</em> nach dem Komma. Hier erhöhen wir den Wert von <code>m</code> nach jedem Durchlauf um 1.</span>
</dd>
</dl>
</div>
</div>
<p>Für das Rechnen mit Binärzahlen stellt Python sogenannte <em>bitwise operations</em> bereit:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Operation</th>
<th style="text-align: left;">Ergebnis</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>x | y</code></td>
<td style="text-align: left;">bitwise <em>or</em> &nbsp;von <code>x</code> und <code>y</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>x ^ y</code></td>
<td style="text-align: left;">bitwise <em>exclusive or</em> &nbsp;von <code>x</code> und <code>y</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>x &amp; y</code></td>
<td style="text-align: left;">bitwise <em>and</em> &nbsp;von <code>x</code> und <code>y</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>x &lt;&lt; n</code></td>
<td style="text-align: left;"><code>x</code> um <code>n</code> bits nach links verschoben</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>x &gt;&gt; n</code></td>
<td style="text-align: left;"><code>x</code> um <code>n</code> bits nach rechts verschoben</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>~x</code></td>
<td style="text-align: left;">bitwise <em>not</em> &nbsp;: die bits von <code>x</code> umgekehrt</td>
</tr>
</tbody>
</table>
<p>Binärzahlen werden in der Regel zu Einheiten von acht <em>bits</em> zusammengefasst, die wir dann <em>byte</em> nennen. Wenn wir ein <em>byte</em> in der Form <span class="math inline">\(b=b_7 \ b_6 \ b_5 \ b_4 \ b_3 \ b_2 \ b_1 \ b_0\)</span> darstellen, dann können wir die <em>bitwise operations</em> als Mengenoperationen (siehe <a href="#sec-mengen" class="quarto-xref">Kapitel&nbsp;1</a>) auf <em>bytes</em> begreifen, indem wir jedes gesetzte <em>bit</em> über seinen Index darstellen:</p>
<div id="b5815449" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="annotated-cell-14"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><a class="code-annotation-anchor" data-target-cell="annotated-cell-14" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-14-1" class="code-annotation-target"><a href="#annotated-cell-14-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="bn">0b10000010</span></span>
<span id="annotated-cell-14-2"><a href="#annotated-cell-14-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="bn">0b10010000</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-14" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-14-3" class="code-annotation-target"><a href="#annotated-cell-14-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"x = </span><span class="sc">{</span>x<span class="sc">:#0b}</span><span class="ss">"</span>, <span class="st">"= {7, 1}"</span>)</span>
<span id="annotated-cell-14-4"><a href="#annotated-cell-14-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"y = </span><span class="sc">{</span>y<span class="sc">:#0b}</span><span class="ss">"</span>, <span class="st">"= {7, 4}"</span>)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-14" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-14" data-code-lines="1" data-code-annotation="1">Definition von <code>x</code> als Binärzahl: wir verwenden hierzu das Präfix <code>0b</code>.</span>
</dd>
<dt data-target-cell="annotated-cell-14" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-14" data-code-lines="3" data-code-annotation="2">Ausgabe von <code>x</code> im Binärformat und der Menge der gesetzten Indizes, das sind die Stellen der Binärzahl, an denen ein <em>bit</em> auf 1 gesetzt ist. Wir verwenden hierzu einen sogenannten <code>f-string</code> für engl. <em>formatted string</em>.</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>x = 0b10000010 = {7, 1}
y = 0b10010000 = {7, 4}</code></pre>
</div>
</div>
<p>Die Mengenoperationen können dann so ausgeführt werden:</p>
<div id="152d21f5" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># bitwise or</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Vereinigungsmenge (x|y): </span><span class="sc">{</span>x<span class="op">|</span>y<span class="sc">:#0b}</span><span class="ss">"</span>, <span class="st">"= {7, 4, 1}"</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="co"># bitwise and</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Schnittmenge (x&amp;y): </span><span class="sc">{</span>x<span class="op">&amp;</span>y<span class="sc">:#0b}</span><span class="ss">"</span>, <span class="st">"= </span><span class="sc">{7}</span><span class="st">"</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="co"># bit clear (and not)</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Differenz (x&amp;~y): </span><span class="sc">{</span>x<span class="op">&amp;~</span>y<span class="sc">:#0b}</span><span class="ss">"</span>, <span class="st">"= </span><span class="sc">{1}</span><span class="st">"</span>)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="co"># bitwise xor</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Symmetrische Differenz (x^y): </span><span class="sc">{</span>x<span class="op">^</span>y<span class="sc">:#0b}</span><span class="ss">"</span>, <span class="st">"= {4, 1}"</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Vereinigungsmenge (x|y): 0b10010010 = {7, 4, 1}
Schnittmenge (x&amp;y): 0b10000000 = {7}
Differenz (x&amp;~y): 0b10 = {1}
Symmetrische Differenz (x^y): 0b10010 = {4, 1}</code></pre>
</div>
</div>
<p>Die <em>shift</em> Operatoren <code>&lt;&lt;</code> und <code>&gt;&gt;</code> verschieben die <em>bits</em> einer Binärzahl um <span class="math inline">\(n\)</span> Stellen nach links bzw. rechts. Dabei wird die Zahl bei <em>links-shift</em> mit <code>&lt;&lt;</code> von rechts mit 0-<em>bits</em> aufgefüllt, der Wert der Zahl verdoppelt sich also mit jedem <em>shift</em>. Demnach ist z.B. <code>x &lt;&lt; 3</code> gleichbedeutend mit <span class="math inline">\(x\cdot2^3\)</span>.</p>
<div id="e673c562" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"a = </span><span class="sc">{</span>a<span class="sc">:#0b}</span><span class="ss"> = </span><span class="sc">{</span>a<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> a <span class="op">&lt;&lt;</span> <span class="dv">3</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"b = </span><span class="sc">{</span>b<span class="sc">:#0b}</span><span class="ss"> = </span><span class="sc">{</span>b<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> b <span class="op">==</span> a <span class="op">*</span> <span class="dv">2</span><span class="op">**</span><span class="dv">3</span></span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>a = 0b101 = 5
b = 0b101000 = 40</code></pre>
</div>
</div>
<p>Bei einem rechts-<em>shift</em> mit <code>x &gt;&gt; n</code> werden <code>n</code> Stellen am rechten Ende von <code>x</code> abgeschnitten, der Wert der Zahl halbiert sich also mit jedem <em>shift</em>. Wenn das letzte bit <span class="math inline">\(b_0\)</span> dabei gesetzt ist, die Zahl also ungerade ist, dann geht der Rest der Division durch 2 dabei verloren; es gilt also: <code>x &gt;&gt; 1</code> ist gleichbedeutend mit <code>x // 2</code>.</p>
<div id="b53bbbfb" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"a = </span><span class="sc">{</span>a<span class="sc">:#0b}</span><span class="ss"> = </span><span class="sc">{</span>a<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> a <span class="op">&gt;&gt;</span> <span class="dv">1</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"c = </span><span class="sc">{</span>c<span class="sc">:#0b}</span><span class="ss"> = </span><span class="sc">{</span>c<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> c <span class="op">==</span> a <span class="op">//</span> <span class="dv">2</span></span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>a = 0b101 = 5
c = 0b10 = 2</code></pre>
</div>
</div>
</section>
</section>
<section id="übungen" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="übungen"><span class="header-section-number">4</span> Übungen</h2>
<p>Die Übungen dieser Lektion findest du im Notebook <code>arithmetik/_mengen.ipynb</code>. Öffne diese Datei in <em>Jupyter</em> und erforsche des Rechnen mit verschiedenen Zahlensystemen.</p>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Kopiert");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Kopiert");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/okrischer\.github\.io\/matheKapierenMitPython\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Quellcode</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb23" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Zahlenbereiche und Zahlensysteme"</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>Bisher haben wir wie selbstverständlich von natürlichen und reellen Zahlen gesprochen, ohne überhaupt genau zu wissen, was wir darunter verstehen wollen.</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>In dieser Lektion werden wir uns den Zahlenbegriff, so wie er der gesamten Mathematik zugrunde liegt, näher anschauen.</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>Dafür werden wir zunächst die Grundbegriffe der Mengenlehre kennenlernen und die Zahlen in Zahlenbereiche einteilen.</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>Schließlich wollen wir auch noch verschiedene Zahlensysteme erkunden.</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="fu">## Elementare Mengenlehre {#sec-mengen}</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>In der Mathematik wird jede Zusammenfassung von bestimmten, wohlunterscheidbaren Objekten zu einer *Gesamtheit* eine **Menge** genannt.</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>Eine Menge ist definiert, wenn feststeht, welche Objekte zu dieser Menge gehören und welche nicht.</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>Die zur Menge gehörenden Objekte heißen ihre *Elemente*.</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>Mengen werden meistens mit großen lateinischen Buchstaben bezeichnet und die Elemente mit kleinen Buchstaben.</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a><span class="fu">## Definition von Mengen</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>Es gibt zwei Möglichkeiten, Mengen zu definieren:</span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Durch Aufzählen ihrer Elemente, die in beliebiger Reihenfolge zwischen geschweiften Klammern (Mengenklammern) gesetzt sind und durch Komma getrennt werden: $<span class="sc">\{</span>x_1, x_2, x_3, \dots<span class="sc">\}</span>$</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Durch Angabe einer die Elemente charakteresierenden Eigenschaft: $<span class="sc">\{</span>x \mid \mathrm{Eigenschaft}<span class="sc">\}</span>$.</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>Der vertikale Strich $\mid$ wird gelesen als "für die gilt".</span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a><span class="fu">## Beispiele für Mengendefinitionen</span></span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$A=<span class="sc">\{</span>1,2,3<span class="sc">\}</span>$: die Menge $A$ besteht aus den Elementen 1, 2 und 3.</span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$B=<span class="sc">\{</span>x \mid x^2-1=0<span class="sc">\}</span>$: die Menge $B$ besteht aus den Elementen $x$, für die $x^2-1=0$ gilt.</span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$B=<span class="sc">\{</span>1,-1<span class="sc">\}</span>$: da die Gleichung $x^2-1=0$ die Lösungen $x_1= 1$ und $x_2=-1$ besitzt, kann man die Menge $B$ auch in dieser Form schreiben.</span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>Gehört ein Objekt $a$ einer Menge $M$ an, so schreibt man $a \in M$ (gelesen als: $a$ ist Element von $M$).</span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a>Gehört $a$ nicht zu $M$, so schreibt man $a \notin M$.</span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a>Wenn jedes Element einer Menge $M$ auch Element einer Menge $N$ ist, so nennt man $M$ Teilmenge von $N$ und schreibt $M \subset N$.</span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a>Diese Schreibweise bedeutet auch, dass $M$ eine *echte* Teilmenge von $N$ ist; es gilt also $M\neq N$.</span>
<span id="cb23-39"><a href="#cb23-39" aria-hidden="true" tabindex="-1"></a>Wollte man zulassen, dass $M$ auch gleich $N$ sein könnte, also $M=N$, dann würde man $M\subseteq N$ schreiben.\</span>
<span id="cb23-40"><a href="#cb23-40" aria-hidden="true" tabindex="-1"></a>Die leere Menge $\emptyset=<span class="sc">\{\}</span>$ enthält kein Element.</span>
<span id="cb23-41"><a href="#cb23-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-42"><a href="#cb23-42" aria-hidden="true" tabindex="-1"></a>Die Zugehörigkeit von Objekten zu Mengen kann man auch grafisch in einem *Mengendiagramm* darstellen, wobei Mengen als Kreise oder Ellipsen dargestellt werden, und Elemente, die zur Menge gehören, in den Kreis geschrieben werden.</span>
<span id="cb23-43"><a href="#cb23-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-44"><a href="#cb23-44" aria-hidden="true" tabindex="-1"></a><span class="al">![Euler-Diagramm: Zugehörigkeit zu Mengen](media/images/euler/euler-diagramm.png)</span>{#fig-euler}</span>
<span id="cb23-45"><a href="#cb23-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-46"><a href="#cb23-46" aria-hidden="true" tabindex="-1"></a>Auf Mengen sind folgende Operationen definiert, deren Ergebnis jeweils wieder eine Menge ist:</span>
<span id="cb23-47"><a href="#cb23-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-48"><a href="#cb23-48" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb23-49"><a href="#cb23-49" aria-hidden="true" tabindex="-1"></a><span class="fu">## Vereinigungsmenge</span></span>
<span id="cb23-50"><a href="#cb23-50" aria-hidden="true" tabindex="-1"></a>Die Vereinigung $A \cup B$ zweier Mengen $A$ und $B$ besteht aus denjenigen Elementen, die in $A$ oder in $B$, also in mindestens einer der beiden Mengen $A, B$ enthalten sind:</span>
<span id="cb23-51"><a href="#cb23-51" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-52"><a href="#cb23-52" aria-hidden="true" tabindex="-1"></a>A \cup B = <span class="sc">\{</span>x \mid x \in A \ \mathrm{oder} \ x \in B<span class="sc">\}</span></span>
<span id="cb23-53"><a href="#cb23-53" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-54"><a href="#cb23-54" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-55"><a href="#cb23-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-56"><a href="#cb23-56" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb23-57"><a href="#cb23-57" aria-hidden="true" tabindex="-1"></a><span class="fu">## Schnittmenge</span></span>
<span id="cb23-58"><a href="#cb23-58" aria-hidden="true" tabindex="-1"></a>Die Durchschnitt $A\cap B$ zweier Mengen $A$ und $B$ besteht aus denjenigen Elementen, die sowohl in $A$ als auch in $B$, also gleichzeitig in beiden Mengen $A, B$ enthalten sind:</span>
<span id="cb23-59"><a href="#cb23-59" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-60"><a href="#cb23-60" aria-hidden="true" tabindex="-1"></a>A \cap B = <span class="sc">\{</span>x \mid x \in A \ \mathrm{und} \ x \in B<span class="sc">\}</span></span>
<span id="cb23-61"><a href="#cb23-61" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-62"><a href="#cb23-62" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-63"><a href="#cb23-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-64"><a href="#cb23-64" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb23-65"><a href="#cb23-65" aria-hidden="true" tabindex="-1"></a><span class="fu">## Differenz</span></span>
<span id="cb23-66"><a href="#cb23-66" aria-hidden="true" tabindex="-1"></a>Die Differenz $A \backslash B$ zweier Mengen $A$ und $B$ besteht aus denjenigen Elementen, die in $A$, aber nicht in $B$ enthalten sind:</span>
<span id="cb23-67"><a href="#cb23-67" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-68"><a href="#cb23-68" aria-hidden="true" tabindex="-1"></a>A \backslash B = <span class="sc">\{</span>x \mid x \in A \ \mathrm{und} \ x \notin B<span class="sc">\}</span></span>
<span id="cb23-69"><a href="#cb23-69" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-70"><a href="#cb23-70" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-71"><a href="#cb23-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-72"><a href="#cb23-72" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb23-73"><a href="#cb23-73" aria-hidden="true" tabindex="-1"></a><span class="fu">## Symmetrische Differenz</span></span>
<span id="cb23-74"><a href="#cb23-74" aria-hidden="true" tabindex="-1"></a>Die symmetrische Differenz $A \Delta B$ zweier Mengen $A$ und $B$ besteht aus denjenigen Elementen, die in $A$ oder $B$ enthalten sind, aber nicht in der Schnittmenge von $A$ und $B$:</span>
<span id="cb23-75"><a href="#cb23-75" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-76"><a href="#cb23-76" aria-hidden="true" tabindex="-1"></a>A \Delta B = (A \cup B) \backslash (A \cap B)=(A \backslash B) \cup (B \backslash A)</span>
<span id="cb23-77"><a href="#cb23-77" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-78"><a href="#cb23-78" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-79"><a href="#cb23-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-80"><a href="#cb23-80" aria-hidden="true" tabindex="-1"></a>Diese Mengenoperationen können mit einem sogenannten *Venn-Diagramm* veranschaulicht werden, in dem die Ergebnismenge einer Operation entsprechend eingefärbt wird (in diesem Beispiel in Rot):</span>
<span id="cb23-81"><a href="#cb23-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-82"><a href="#cb23-82" aria-hidden="true" tabindex="-1"></a><span class="al">![Venn-Diagramm der Operationen auf Mengen](media/images/venn/venn-diagramm.png)</span>{#fig-venn}</span>
<span id="cb23-83"><a href="#cb23-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-84"><a href="#cb23-84" aria-hidden="true" tabindex="-1"></a>Wir können auch in Python mit Mengen rechnen (wir beschränken uns dabei auf ganze Zahlen).</span>
<span id="cb23-85"><a href="#cb23-85" aria-hidden="true" tabindex="-1"></a>Dazu müssen wir die Zahlen, die zu einer Menge gehören sollen, in einem Datentyp <span class="in">`set`</span>  zusammenfassen, der weitgehend unserem Mengenbegriff entpricht.</span>
<span id="cb23-86"><a href="#cb23-86" aria-hidden="true" tabindex="-1"></a>Da alle Schlüsselwörter in Python (und damit auch die Bezeichnungen der Datentypen) in englischer Sprache angegeben werden, verwenden wir in diesem Tutorial ausschließlich die englischen Bezeichnungen.</span>
<span id="cb23-87"><a href="#cb23-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-90"><a href="#cb23-90" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-91"><a href="#cb23-91" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>}                         <span class="co"># &lt;1&gt;</span></span>
<span id="cb23-92"><a href="#cb23-92" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> <span class="bu">set</span>()                           <span class="co"># &lt;2&gt;</span></span>
<span id="cb23-93"><a href="#cb23-93" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> (<span class="bu">len</span>(A), <span class="bu">len</span>(B)) <span class="op">==</span> (<span class="dv">3</span>, <span class="dv">0</span>)   <span class="co"># &lt;3&gt;</span></span>
<span id="cb23-94"><a href="#cb23-94" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-95"><a href="#cb23-95" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Definition eines <span class="in">`set`</span> A mit Mengenklammern</span>
<span id="cb23-96"><a href="#cb23-96" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Definition eines leeren <span class="in">`set`</span> B</span>
<span id="cb23-97"><a href="#cb23-97" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Die Anzahl der Elemente eines <span class="in">`set`</span> (auch die Kardinalität einer Menge genannt) wird mit der Funktion <span class="in">`len()`</span> berechnet.</span>
<span id="cb23-98"><a href="#cb23-98" aria-hidden="true" tabindex="-1"></a>Wir haben hier auf der linken und rechten Seite des <span class="in">`==`</span> jeweils zwei Werte zu einem sogenannten <span class="in">`tuple`</span> zusammengeführt, einem anderen Datentyp, bei dem die Elemente in runden Klammern angegeben werden. Auch ein <span class="in">`tuple`</span> kann offensichtlich auf Gleichheit getestet werden.</span>
<span id="cb23-99"><a href="#cb23-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-100"><a href="#cb23-100" aria-hidden="true" tabindex="-1"></a>Der Test auf Mitgliedschaft in einer Menge ($\in$) wird mit dem Schlüsselwort <span class="in">`in`</span> durchgeführt, das Gegenstück ($\notin$) mit <span class="in">`not in`</span>, wobei <span class="in">`not`</span> ein sogenannter *Bool'scher Operator* ist, der das gegebene Argument verneint:</span>
<span id="cb23-101"><a href="#cb23-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-104"><a href="#cb23-104" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-105"><a href="#cb23-105" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="dv">1</span> <span class="kw">in</span> A</span>
<span id="cb23-106"><a href="#cb23-106" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="dv">1</span> <span class="kw">not</span> <span class="kw">in</span> B</span>
<span id="cb23-107"><a href="#cb23-107" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-108"><a href="#cb23-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-109"><a href="#cb23-109" aria-hidden="true" tabindex="-1"></a>Die beiden anderen Bool'schen Operatoren in Python sind <span class="in">`and`</span> und <span class="in">`or`</span> mit denen wir zwei Wahrheitsaussagen verknüpfen können:</span>
<span id="cb23-110"><a href="#cb23-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-113"><a href="#cb23-113" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-114"><a href="#cb23-114" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> (<span class="dv">1</span> <span class="kw">in</span> A) <span class="kw">or</span> (<span class="dv">1</span> <span class="kw">in</span> B)         <span class="co"># &lt;1&gt;</span></span>
<span id="cb23-115"><a href="#cb23-115" aria-hidden="true" tabindex="-1"></a>B.add(<span class="dv">1</span>)                            <span class="co"># &lt;2&gt;</span></span>
<span id="cb23-116"><a href="#cb23-116" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> (<span class="dv">1</span> <span class="kw">in</span> A) <span class="kw">and</span> (<span class="dv">1</span> <span class="kw">in</span> B)        <span class="co"># &lt;3&gt;</span></span>
<span id="cb23-117"><a href="#cb23-117" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-118"><a href="#cb23-118" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Wenn (mindestens) eine der beiden Aussagen wahr ist, dann ist auch die mit <span class="in">`or`</span> verknüpfte Aussage wahr.</span>
<span id="cb23-119"><a href="#cb23-119" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Wir fügen dem <span class="in">`set`</span> B das Element 1 hinzu.</span>
<span id="cb23-120"><a href="#cb23-120" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Nur wenn beide Aussagen wahr sind, dann ist auch die mit <span class="in">`and`</span> verknüpfte Aussage wahr.</span>
<span id="cb23-121"><a href="#cb23-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-122"><a href="#cb23-122" aria-hidden="true" tabindex="-1"></a>Ob ein <span class="in">`set`</span> B eine *echte* Teilmenge vom `set` A ist ($B\subset A$), kann mit dem Operator `B &lt; A` getstet werden. Das ist dann gleichbedeutend mit `A &gt; B`, d.h. A ist die *Obermenge* von B:</span>
<span id="cb23-123"><a href="#cb23-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-126"><a href="#cb23-126" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-127"><a href="#cb23-127" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> B <span class="op">&lt;</span> A</span>
<span id="cb23-128"><a href="#cb23-128" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> A <span class="op">&gt;</span> B</span>
<span id="cb23-129"><a href="#cb23-129" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-130"><a href="#cb23-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-131"><a href="#cb23-131" aria-hidden="true" tabindex="-1"></a>Und schließlich können wir auch die Mengenoperationen auf <span class="in">`set`</span> A und B ausführen:</span>
<span id="cb23-132"><a href="#cb23-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-135"><a href="#cb23-135" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-136"><a href="#cb23-136" aria-hidden="true" tabindex="-1"></a>B.add(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb23-137"><a href="#cb23-137" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"A = "</span>, A)</span>
<span id="cb23-138"><a href="#cb23-138" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"B = "</span>, B)</span>
<span id="cb23-139"><a href="#cb23-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-140"><a href="#cb23-140" aria-hidden="true" tabindex="-1"></a><span class="co"># Vereinigungsmenge A ∪ B</span></span>
<span id="cb23-141"><a href="#cb23-141" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"A ∪ B = "</span>, A.union(B))</span>
<span id="cb23-142"><a href="#cb23-142" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> A.union(B) <span class="op">==</span> A <span class="op">|</span> B</span>
<span id="cb23-143"><a href="#cb23-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-144"><a href="#cb23-144" aria-hidden="true" tabindex="-1"></a><span class="co"># Schnittmenge A ∩ B</span></span>
<span id="cb23-145"><a href="#cb23-145" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"A ∩ B = "</span>, A.intersection(B))</span>
<span id="cb23-146"><a href="#cb23-146" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> A.intersection(B) <span class="op">==</span> A <span class="op">&amp;</span> B</span>
<span id="cb23-147"><a href="#cb23-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-148"><a href="#cb23-148" aria-hidden="true" tabindex="-1"></a><span class="co"># Differenz A \ B</span></span>
<span id="cb23-149"><a href="#cb23-149" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"A </span><span class="ch">\\</span><span class="st"> B = "</span>, A.difference(B))</span>
<span id="cb23-150"><a href="#cb23-150" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> A.difference(B) <span class="op">==</span> A <span class="op">-</span> B</span>
<span id="cb23-151"><a href="#cb23-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-152"><a href="#cb23-152" aria-hidden="true" tabindex="-1"></a><span class="co"># Symmetrische Differenz A ∆ B</span></span>
<span id="cb23-153"><a href="#cb23-153" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"A ∆ B = "</span>, A.symmetric_difference(B))</span>
<span id="cb23-154"><a href="#cb23-154" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> A.symmetric_difference(B) <span class="op">==</span> A <span class="op">^</span> B</span>
<span id="cb23-155"><a href="#cb23-155" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-156"><a href="#cb23-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-157"><a href="#cb23-157" aria-hidden="true" tabindex="-1"></a><span class="fu">## Zahlenbereiche</span></span>
<span id="cb23-158"><a href="#cb23-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-159"><a href="#cb23-159" aria-hidden="true" tabindex="-1"></a>Die Zahlen, mit denen wir rechnen, lassen sich in Teilmengen einteilen, die **Zahlenbereiche** genannt werden und üblicherweise in Mengenschreibweise dargestellt werden.</span>
<span id="cb23-160"><a href="#cb23-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-161"><a href="#cb23-161" aria-hidden="true" tabindex="-1"></a><span class="al">![Die Zahlenbereiche in Mengendarstellung](media/images/zahlenbereiche/zahlenbereiche.png)</span>{#fig-zahlenbereiche}</span>
<span id="cb23-162"><a href="#cb23-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-163"><a href="#cb23-163" aria-hidden="true" tabindex="-1"></a><span class="fu">### Natürliche Zahlen</span></span>
<span id="cb23-164"><a href="#cb23-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-165"><a href="#cb23-165" aria-hidden="true" tabindex="-1"></a>Die einfachsten Zahlen sind die, mit denen wir als Kind zählen gelernt haben: die Menge der **natürlichen Zahlen**.</span>
<span id="cb23-166"><a href="#cb23-166" aria-hidden="true" tabindex="-1"></a>Wir benutzen diese Zahlen, um die *Anzahl* von Objekten einer Menge zu bestimmen, also zum *Zählen*.</span>
<span id="cb23-167"><a href="#cb23-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-168"><a href="#cb23-168" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb23-169"><a href="#cb23-169" aria-hidden="true" tabindex="-1"></a><span class="fu">## Natürliche Zahlen</span></span>
<span id="cb23-170"><a href="#cb23-170" aria-hidden="true" tabindex="-1"></a>Die Menge der natürlichen Zahlen sind die ganzen positiven Zahlen:</span>
<span id="cb23-171"><a href="#cb23-171" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-172"><a href="#cb23-172" aria-hidden="true" tabindex="-1"></a>\mathbb{N} = <span class="sc">\{</span>1,2,3,\dots<span class="sc">\}</span>,</span>
<span id="cb23-173"><a href="#cb23-173" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-174"><a href="#cb23-174" aria-hidden="true" tabindex="-1"></a>wobei die drei Punkte anzeigen, dass die Folge der Zahlen nach dem gegeben Muster fortgeführt wird.</span>
<span id="cb23-175"><a href="#cb23-175" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-176"><a href="#cb23-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-177"><a href="#cb23-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-178"><a href="#cb23-178" aria-hidden="true" tabindex="-1"></a><span class="fu">### Ganze Zahlen {#sec-zahlen}</span></span>
<span id="cb23-179"><a href="#cb23-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-180"><a href="#cb23-180" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb23-181"><a href="#cb23-181" aria-hidden="true" tabindex="-1"></a><span class="fu">## Ganze Zahlen</span></span>
<span id="cb23-182"><a href="#cb23-182" aria-hidden="true" tabindex="-1"></a>Die Menge der ganzen Zahlen ist wie folgt definiert:</span>
<span id="cb23-183"><a href="#cb23-183" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-184"><a href="#cb23-184" aria-hidden="true" tabindex="-1"></a>\mathbb{Z}=<span class="sc">\{</span>\dots,-3,-2,-1,0,1,2,3,\dots<span class="sc">\}</span></span>
<span id="cb23-185"><a href="#cb23-185" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-186"><a href="#cb23-186" aria-hidden="true" tabindex="-1"></a>Das lässt sich dann unter Verwendung von Eigenschaften so schreiben:</span>
<span id="cb23-187"><a href="#cb23-187" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-188"><a href="#cb23-188" aria-hidden="true" tabindex="-1"></a>\mathbb{Z}=<span class="sc">\{</span>z \mid abs(z) \in \mathbb{N}<span class="sc">\}</span> \cup <span class="sc">\{</span>0<span class="sc">\}</span>,</span>
<span id="cb23-189"><a href="#cb23-189" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-190"><a href="#cb23-190" aria-hidden="true" tabindex="-1"></a>wobei $abs(z)$ für den absoluten Wert von $z$ steht, also $z$ ohne Vorzeichen.</span>
<span id="cb23-191"><a href="#cb23-191" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-192"><a href="#cb23-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-193"><a href="#cb23-193" aria-hidden="true" tabindex="-1"></a>Es hat in Europa bis zum Ende des Mittelalters gedauert, bis sich die Verwendung von 0 als Zahl und die Rechnung mit negativen Zahlen durchgesetzt hat.</span>
<span id="cb23-194"><a href="#cb23-194" aria-hidden="true" tabindex="-1"></a>Das erscheint auf den ersten Blick verwunderlich, da wir heute ganz selbstverständlich mit negativen Zahlen rechnen.</span>
<span id="cb23-195"><a href="#cb23-195" aria-hidden="true" tabindex="-1"></a>Folgender Witz illustriert, was für ein großer intellektueller Schritt das war:</span>
<span id="cb23-196"><a href="#cb23-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-197"><a href="#cb23-197" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb23-198"><a href="#cb23-198" aria-hidden="true" tabindex="-1"></a><span class="fu">## Mathematiker Witz</span></span>
<span id="cb23-199"><a href="#cb23-199" aria-hidden="true" tabindex="-1"></a>Stehen ein Theologe, ein Physiker und ein Mathematiker vor einem leeren Raum.</span>
<span id="cb23-200"><a href="#cb23-200" aria-hidden="true" tabindex="-1"></a>Gemeinsam beobachten sie, wie drei Personen den Raum betreten und kurze Zeit fünf Personen wieder herauskommen.\</span>
<span id="cb23-201"><a href="#cb23-201" aria-hidden="true" tabindex="-1"></a>"Ein Wunder!", ruft der Theologe.\</span>
<span id="cb23-202"><a href="#cb23-202" aria-hidden="true" tabindex="-1"></a>"Muss sich um einen Messfehler handeln", murmelt der Physiker.\</span>
<span id="cb23-203"><a href="#cb23-203" aria-hidden="true" tabindex="-1"></a>Der Mathematiker entgegnet nur trocken: "Jetzt müssen nur zwei Leute wieder hineingehen, damit der Raum wieder leer ist".</span>
<span id="cb23-204"><a href="#cb23-204" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-205"><a href="#cb23-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-206"><a href="#cb23-206" aria-hidden="true" tabindex="-1"></a>Mit der Mengenschreibweise können wir jetzt auch etwas komliziertere Mengen darstellen, zum Beispiel:</span>
<span id="cb23-207"><a href="#cb23-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-208"><a href="#cb23-208" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb23-209"><a href="#cb23-209" aria-hidden="true" tabindex="-1"></a><span class="fu">## Gerade und ungerade Zahlen</span></span>
<span id="cb23-210"><a href="#cb23-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-211"><a href="#cb23-211" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Menge der geraden natürlichen Zahlen: $<span class="sc">\{</span>2n \mid n \in \mathbb{N}<span class="sc">\}</span>$</span>
<span id="cb23-212"><a href="#cb23-212" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Menge der ungeraden ganzen Zahlen: $<span class="sc">\{</span>2z-1 \mid z \in \mathbb{Z}<span class="sc">\}</span>$</span>
<span id="cb23-213"><a href="#cb23-213" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-214"><a href="#cb23-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-215"><a href="#cb23-215" aria-hidden="true" tabindex="-1"></a>Solche Zahlenmengen lassen sich auch in Python mit sogenannten *set comprehensions* erstellen, die eng an die mathematische Schreibweise von Mengen angelehnt sind:</span>
<span id="cb23-216"><a href="#cb23-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-219"><a href="#cb23-219" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-220"><a href="#cb23-220" aria-hidden="true" tabindex="-1"></a><span class="co"># Menge der geraden natürlichen Zahlen bis 20</span></span>
<span id="cb23-221"><a href="#cb23-221" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>}</span>
<span id="cb23-222"><a href="#cb23-222" aria-hidden="true" tabindex="-1"></a>{<span class="dv">2</span><span class="op">*</span>n <span class="cf">for</span> n <span class="kw">in</span> N}</span>
<span id="cb23-223"><a href="#cb23-223" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-224"><a href="#cb23-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-225"><a href="#cb23-225" aria-hidden="true" tabindex="-1"></a>Hier haben wir gegenüber der mathematischen Notation lediglich den vertikalen Strich $\mid$ durch das Schlüsselwort <span class="in">`for`</span> ersetzt, und die Menge der natürlichen Zahlen, für die die Anweisung gelten soll, zuvor explizit als <span class="in">`set`</span> definiert.</span>
<span id="cb23-226"><a href="#cb23-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-227"><a href="#cb23-227" aria-hidden="true" tabindex="-1"></a>Natürlich ist es etwas umständlich, die Elemente der Ausgangsmenge konkret aufzuzählen; Python bieter daher eine <span class="in">`range()`</span> Funktion an, die zwei ganze Zahlen als Argumente akzeptiert und daraus ein Intervall berechnet, das als Ausgangsmenge dienen kann: </span>
<span id="cb23-228"><a href="#cb23-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-231"><a href="#cb23-231" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-232"><a href="#cb23-232" aria-hidden="true" tabindex="-1"></a><span class="co"># Menge der ungeraden Zahlen im Intervall [-5, 17)</span></span>
<span id="cb23-233"><a href="#cb23-233" aria-hidden="true" tabindex="-1"></a>{<span class="dv">2</span><span class="op">*</span>z<span class="op">-</span><span class="dv">1</span> <span class="cf">for</span> z <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">9</span>)}</span>
<span id="cb23-234"><a href="#cb23-234" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-235"><a href="#cb23-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-236"><a href="#cb23-236" aria-hidden="true" tabindex="-1"></a>Um zu verstehen was hier passiert, müssen wir uns mit der Intervallschreibweise von Zahlenmengen vertraut machen:</span>
<span id="cb23-237"><a href="#cb23-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-238"><a href="#cb23-238" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb23-239"><a href="#cb23-239" aria-hidden="true" tabindex="-1"></a><span class="fu">## Intervalle</span></span>
<span id="cb23-240"><a href="#cb23-240" aria-hidden="true" tabindex="-1"></a>Zahlenmengen können mit Hilfe von Intervallen beschrieben werden.</span>
<span id="cb23-241"><a href="#cb23-241" aria-hidden="true" tabindex="-1"></a>Wenn die Intervallgrenzen mit den ganzen Zahlen $a,b$ angegeben werden, dann besteht ein Intervall aus allen ganzen Zahlen $x$, die zwischen diesen Grenzen liegen.</span>
<span id="cb23-242"><a href="#cb23-242" aria-hidden="true" tabindex="-1"></a>Für so beschränkte Intervalle gelten folgende Regeln:</span>
<span id="cb23-243"><a href="#cb23-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-244"><a href="#cb23-244" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$<span class="co">[</span><span class="ot">a,b</span><span class="co">]</span>= <span class="sc">\{</span>x \mid x \in \mathbb{Z} \ \mathrm{und} \ a \leq x \leq b<span class="sc">\}</span>$ (geschlossenes Intervall)</span>
<span id="cb23-245"><a href="#cb23-245" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$(a,b)= <span class="sc">\{</span>x \mid x \in \mathbb{Z} \ \mathrm{und} \ a &lt; x &lt; b<span class="sc">\}</span>$ (offenes Intervall)</span>
<span id="cb23-246"><a href="#cb23-246" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-247"><a href="#cb23-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-248"><a href="#cb23-248" aria-hidden="true" tabindex="-1"></a>Eckige Klammern $[]$ bedeuten also, dass der jeweilige Begrenzer mit zur Menge gehört, runde Klammern $()$dagegen, dass der Begrenzer nicht mehr zur Menge gehört.</span>
<span id="cb23-249"><a href="#cb23-249" aria-hidden="true" tabindex="-1"></a>In Python erzeugt der Aufruf von <span class="in">`range(a, b)`</span> immer ein halboffenes Intervall in der Form $[a, b)$, so dass also <span class="in">`a`</span> zur Menge gehört, <span class="in">`b`</span> aber nicht.</span>
<span id="cb23-250"><a href="#cb23-250" aria-hidden="true" tabindex="-1"></a>Das erklärt, warum im letzten Code-Beispiel das Intervall $[-5, 17)$ angegeben wurde, mit dem Ergebnis $<span class="sc">\{</span>-5,-3,\dots,13,15<span class="sc">\}</span>$, da 17 nicht mehr zum Intervall gehört.</span>
<span id="cb23-251"><a href="#cb23-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-252"><a href="#cb23-252" aria-hidden="true" tabindex="-1"></a>Die Angabe der *range* mit <span class="in">`range(-2, 9)`</span> ist trotzdem etwas verwirrend, liegt aber daran, dass $2\cdot -2-1=-5$ und $2\cdot 8-1=15$ ist (die 9 in der <span class="in">`range`</span> gehört nicht mehr zum Intervall und Python wählt den nächstkleineren Wert 8).\</span>
<span id="cb23-253"><a href="#cb23-253" aria-hidden="true" tabindex="-1"></a>Um diese Verwirrung auszuschließen, können wir eine *set comprehension* auch anders definieren, und zwar indem wir die Forderung für *ungerade* als zusätzliche Bedingung formulieren:</span>
<span id="cb23-254"><a href="#cb23-254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-257"><a href="#cb23-257" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-258"><a href="#cb23-258" aria-hidden="true" tabindex="-1"></a><span class="co"># Menge der ungeraden Zahlen im Intervall [-5, 17)</span></span>
<span id="cb23-259"><a href="#cb23-259" aria-hidden="true" tabindex="-1"></a>{z <span class="cf">for</span> z <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">5</span>, <span class="dv">17</span>) <span class="cf">if</span> z <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span>}</span>
<span id="cb23-260"><a href="#cb23-260" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-261"><a href="#cb23-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-262"><a href="#cb23-262" aria-hidden="true" tabindex="-1"></a>Hier haben wir den Modulo Operator <span class="in">`%`</span> verwendet, der den Rest einer <span class="co">[</span><span class="ot">ganzzahligen Division</span><span class="co">](2-teiler.qmd#sec-division)</span> ausgibt, um zu testen, ob <span class="in">`z`</span> eine ungerade Zahl ist.</span>
<span id="cb23-263"><a href="#cb23-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-264"><a href="#cb23-264" aria-hidden="true" tabindex="-1"></a><span class="fu">### Rationale Zahlen</span></span>
<span id="cb23-265"><a href="#cb23-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-266"><a href="#cb23-266" aria-hidden="true" tabindex="-1"></a>Eine **rationale Zahl** ist eine Zahl, die als Verhältnis (lateinisch *ratio*) zweier ganzer Zahlen dargestellt werden kann.</span>
<span id="cb23-267"><a href="#cb23-267" aria-hidden="true" tabindex="-1"></a>Um die Menge aller rationalen Zahlen zu bezeichnen, wird das Zeichen $\mathbb{Q}$ verwendet (von *Quotient*).</span>
<span id="cb23-268"><a href="#cb23-268" aria-hidden="true" tabindex="-1"></a>$\mathbb{Q}$ umfasst alle Zahlen, die sich als Bruch darstellen lassen, der sowohl im Zähler als auch im Nenner ganze Zahlen enthält.</span>
<span id="cb23-269"><a href="#cb23-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-270"><a href="#cb23-270" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb23-271"><a href="#cb23-271" aria-hidden="true" tabindex="-1"></a><span class="fu">## Rationale Zahlen</span></span>
<span id="cb23-272"><a href="#cb23-272" aria-hidden="true" tabindex="-1"></a>Die Menge der rationalen Zahlen ist wie folgt definiert:</span>
<span id="cb23-273"><a href="#cb23-273" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-274"><a href="#cb23-274" aria-hidden="true" tabindex="-1"></a>\mathbb{Q}=\left<span class="sc">\{</span>\frac{m}{n} \mid m, n \in \mathbb{Z}, n \neq 0\right<span class="sc">\}</span></span>
<span id="cb23-275"><a href="#cb23-275" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-276"><a href="#cb23-276" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-277"><a href="#cb23-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-278"><a href="#cb23-278" aria-hidden="true" tabindex="-1"></a>Der Nenner darf dabei nicht Null sein, da die Division durch 0 nicht definiert ist.</span>
<span id="cb23-279"><a href="#cb23-279" aria-hidden="true" tabindex="-1"></a>Wir werden im Rahmen der Lektion <span class="co">[</span><span class="ot">Bruchrechnung</span><span class="co">]()</span> näher auf das Rechnen mit Brüchen und damit auf das Rechnen mit rationalen Zahlen eingehen.</span>
<span id="cb23-280"><a href="#cb23-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-281"><a href="#cb23-281" aria-hidden="true" tabindex="-1"></a>Jede rationale Zahl kann als endlicher oder unendlich periodischer Dezimalbruch dargestellt werden.</span>
<span id="cb23-282"><a href="#cb23-282" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-283"><a href="#cb23-283" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb23-284"><a href="#cb23-284" aria-hidden="true" tabindex="-1"></a><span class="fu">## Dezimalbruch</span></span>
<span id="cb23-285"><a href="#cb23-285" aria-hidden="true" tabindex="-1"></a>Der Dezimalbruch einer rationalen Zahl ist die Darstellung der rationalen Zahl als Dezimalzahl, aslo als Zahl mit Stellen hinter dem Komma.</span>
<span id="cb23-286"><a href="#cb23-286" aria-hidden="true" tabindex="-1"></a>Bei einem endlichen Dezimalbruch ist die Anzahl der Stellen hinter dem Komma endlich, bei einem periodischen Dezimalbruch wiederholen sich die Stellen nach dem Komma nach einem gewissen Muster (Periode).</span>
<span id="cb23-287"><a href="#cb23-287" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-288"><a href="#cb23-288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-289"><a href="#cb23-289" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb23-290"><a href="#cb23-290" aria-hidden="true" tabindex="-1"></a><span class="fu">## Beispiele für Dezimalbrüche</span></span>
<span id="cb23-291"><a href="#cb23-291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-292"><a href="#cb23-292" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\frac{3}{2}=1,5$</span>
<span id="cb23-293"><a href="#cb23-293" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$-\frac{1}{8}=-0,125$</span>
<span id="cb23-294"><a href="#cb23-294" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\frac{4}{3}=1,33333=1,\overline{3}$ (der periodische Teil wird überstrichen)</span>
<span id="cb23-295"><a href="#cb23-295" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$-\frac{16}{11}=-1,454545=-1,\overline{45}$</span>
<span id="cb23-296"><a href="#cb23-296" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-297"><a href="#cb23-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-298"><a href="#cb23-298" aria-hidden="true" tabindex="-1"></a>In Python erzeugt der Divisionsoperator <span class="in">`/`</span> eine Dezimalzahl, die hier allerdings *floating point number* genannt wird und dem Datentyp <span class="in">`float`</span> zugeordnet ist.</span>
<span id="cb23-299"><a href="#cb23-299" aria-hidden="true" tabindex="-1"></a>Beachte den **point** in der englischen Bezeichnung: das deutsche *Dezimalkomma* wird zum *Dezimalpunkt* im gesamten englischen Sprachraum: $1,5 (de)= 1.5(en)$.</span>
<span id="cb23-300"><a href="#cb23-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-303"><a href="#cb23-303" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-304"><a href="#cb23-304" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"3/2 ="</span>, <span class="dv">3</span> <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb23-305"><a href="#cb23-305" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"-1/8 ="</span>, <span class="op">-</span><span class="dv">1</span> <span class="op">/</span> <span class="dv">8</span>)</span>
<span id="cb23-306"><a href="#cb23-306" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"4/3 ="</span>, <span class="dv">4</span> <span class="op">/</span> <span class="dv">3</span>)</span>
<span id="cb23-307"><a href="#cb23-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-308"><a href="#cb23-308" aria-hidden="true" tabindex="-1"></a><span class="co"># eine periodische Darstellung ist nicht möglich, aber wir können runden</span></span>
<span id="cb23-309"><a href="#cb23-309" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"-16/11 ="</span>, <span class="bu">round</span>(<span class="op">-</span><span class="dv">16</span><span class="op">/</span><span class="dv">11</span>, <span class="dv">2</span>)) <span class="co"># runden auf 2 Stellen nach dem Punkt</span></span>
<span id="cb23-310"><a href="#cb23-310" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-311"><a href="#cb23-311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-312"><a href="#cb23-312" aria-hidden="true" tabindex="-1"></a><span class="fu">### Reelle Zahlen</span></span>
<span id="cb23-313"><a href="#cb23-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-314"><a href="#cb23-314" aria-hidden="true" tabindex="-1"></a>Die Menge der **reellen Zahlen** erweitert den Zahlenbereich der *rationalen Zahlen* um die **irrationalen Zahlen**, also Zahlen, die sich nicht als Bruch zweier ganzer Zahlen darstellen lassen, und damit auch nicht als endliche oder periodische Dezimalzahl.</span>
<span id="cb23-315"><a href="#cb23-315" aria-hidden="true" tabindex="-1"></a>Die Menge der reellen Zahlen wird mit $\mathbb{R}$ bezeichnet.</span>
<span id="cb23-316"><a href="#cb23-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-317"><a href="#cb23-317" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb23-318"><a href="#cb23-318" aria-hidden="true" tabindex="-1"></a><span class="fu">## Irrationale Zahlen</span></span>
<span id="cb23-319"><a href="#cb23-319" aria-hidden="true" tabindex="-1"></a>Als irrationale Zahlen bezeichnen wir die Menge aller Elemente von $\mathbb{R}$, die nicht in $\mathbb{Q}$ liegen:</span>
<span id="cb23-320"><a href="#cb23-320" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-321"><a href="#cb23-321" aria-hidden="true" tabindex="-1"></a>\mathrm{irrationale \ Zahlen:} \quad \mathbb{R} \ \backslash \ \mathbb{Q}</span>
<span id="cb23-322"><a href="#cb23-322" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-323"><a href="#cb23-323" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-324"><a href="#cb23-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-325"><a href="#cb23-325" aria-hidden="true" tabindex="-1"></a>In der Antike hatten die *Pythagoräer* (die Schüler des berühmten Mathematikers *Pythagoras*) angenommen, dass sich alles im Universum mit rationalen Zahlen darstellen lässt.</span>
<span id="cb23-326"><a href="#cb23-326" aria-hidden="true" tabindex="-1"></a>Betrachtet man aber ein Quadrat der Seitenlänge eins, so sollte die Länge $x$ von dessen Diagonale, folgend dem *Satz des Pythagoras*, die Gleichung $x^2 = 2$ erfüllen, und damit $x=\sqrt{2}$.\</span>
<span id="cb23-327"><a href="#cb23-327" aria-hidden="true" tabindex="-1"></a>Aus rein geometrischen Überlegungen sollte es also eine Zahl geben, die diese Darstellung besitzt.</span>
<span id="cb23-328"><a href="#cb23-328" aria-hidden="true" tabindex="-1"></a>Tragischerweise hat ausgerechnet *Hippasos*, ein Schüler des *Pythagoras*, mit Hilfe dessen Satzes bewiesen, dass $\sqrt{2}$ keine rationale Zahl sein kann. (siehe ???).</span>
<span id="cb23-329"><a href="#cb23-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-330"><a href="#cb23-330" aria-hidden="true" tabindex="-1"></a>Die erste bekannte irrationale Zahl ist also $\sqrt{2}$; aus der Wurzelrechnung ??? folgt aber, dass es noch unendlich viele weitere solcher irrationaler Zahlen gibt, die auch als *algebraische* irrationale Zahlen bezeichnet werden.\</span>
<span id="cb23-331"><a href="#cb23-331" aria-hidden="true" tabindex="-1"></a>*Algebraisch* deshalb, weil sie als Lösung einer "gewöhnlichen" algebraischen Gleichung angegben werden können, zum Beispiel ist $\sqrt{5}$ die Lösung der Gleichung $x^2=5$.</span>
<span id="cb23-332"><a href="#cb23-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-333"><a href="#cb23-333" aria-hidden="true" tabindex="-1"></a>Es gibt aber auch irrationale Zahlen, die nicht als Lösung einer algebraischen Gleichung angegeben werden können, man sagt, sie "übersteigen" (*transzendieren*) die Möglichkeiten der Algebra, und nennt sie daher *transzendente Zahlen*.</span>
<span id="cb23-334"><a href="#cb23-334" aria-hidden="true" tabindex="-1"></a>Die bekanntesten dieser *transzendenten* Zahlen sind die Kreiszahl $\pi$ und die eulersche Zahl $e$.</span>
<span id="cb23-335"><a href="#cb23-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-336"><a href="#cb23-336" aria-hidden="true" tabindex="-1"></a>Die Zahlen in $\mathbb{R}$ können in einer *Zahlengeraden* veranschaulicht werden, die verdeutlicht, dass die Menge der reelen Zahlen über die Vergleiche $&lt; \mathrm{und}&gt;$ eine *lineare Ordnung* bildet.</span>
<span id="cb23-337"><a href="#cb23-337" aria-hidden="true" tabindex="-1"></a>Das beudeutet, dass wir für zwei verschiedene reelle Zahlen immer sagen können, welche von beiden größer bzw. kleiner ist:</span>
<span id="cb23-338"><a href="#cb23-338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-339"><a href="#cb23-339" aria-hidden="true" tabindex="-1"></a><span class="al">![Ausschnitt der Zahlengeraden der reellen Zahlen](media/images/zahlengerade/zahlengerade.png)</span>{#fig-gerade}</span>
<span id="cb23-340"><a href="#cb23-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-341"><a href="#cb23-341" aria-hidden="true" tabindex="-1"></a>Infolge dieser *linearen Ordung* sind Intervalle (siehe @sec-zahlen) auch in $\mathbb{R}$ eindeutig definiert, z.B. enthält das Intervall $(e, \pi)$ alle reellen Zahlen, die größer als $e$ und kleiner als $\pi$ sind.</span>
<span id="cb23-342"><a href="#cb23-342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-343"><a href="#cb23-343" aria-hidden="true" tabindex="-1"></a><span class="fu">## Zahlensysteme</span></span>
<span id="cb23-344"><a href="#cb23-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-345"><a href="#cb23-345" aria-hidden="true" tabindex="-1"></a>Es gibt verschiedene Möglichkeiten zur Darstellung von *Zahlen*.</span>
<span id="cb23-346"><a href="#cb23-346" aria-hidden="true" tabindex="-1"></a>Die einzelnen Zeichen zur Darstellung von Zahlen sind die *Ziffern*.</span>
<span id="cb23-347"><a href="#cb23-347" aria-hidden="true" tabindex="-1"></a>Grundsätzlich unterscheidet man zwischen sogenannten Positionssystemen und Additionssystemen.</span>
<span id="cb23-348"><a href="#cb23-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-349"><a href="#cb23-349" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb23-350"><a href="#cb23-350" aria-hidden="true" tabindex="-1"></a><span class="fu">## Positions- und Additionssysteme</span></span>
<span id="cb23-351"><a href="#cb23-351" aria-hidden="true" tabindex="-1"></a>Bei einem *Positionssystem* (auch *Stellenwertsystem* genannt) ist der Wert einer Ziffer abhängig von der *Position* dieser Ziffer innerhalb der Zahl.\</span>
<span id="cb23-352"><a href="#cb23-352" aria-hidden="true" tabindex="-1"></a>Bei *Additionssystemen* wird der Wert aller Ziffern einfach addiert, um den Wert der Zahl festzulegen.</span>
<span id="cb23-353"><a href="#cb23-353" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-354"><a href="#cb23-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-355"><a href="#cb23-355" aria-hidden="true" tabindex="-1"></a><span class="fu">### Römische Zahlen</span></span>
<span id="cb23-356"><a href="#cb23-356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-357"><a href="#cb23-357" aria-hidden="true" tabindex="-1"></a>**Römische Zahlen** sind ein Beispiel eines Additionssytems.</span>
<span id="cb23-358"><a href="#cb23-358" aria-hidden="true" tabindex="-1"></a>Die Ziffern sind hier lateinische Großbuchstaben, denen ein fester Wert zugewiesen wird:</span>
<span id="cb23-359"><a href="#cb23-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-360"><a href="#cb23-360" aria-hidden="true" tabindex="-1"></a>| Buchstabe | <span class="in">`I`</span> | <span class="in">`V`</span> | <span class="in">`X`</span>  | <span class="in">`L`</span>  | <span class="in">`C`</span>   | <span class="in">`D`</span>   | <span class="in">`M`</span>  |</span>
<span id="cb23-361"><a href="#cb23-361" aria-hidden="true" tabindex="-1"></a>|-----------+-----+-----+------+------+-------+-------+------|</span>
<span id="cb23-362"><a href="#cb23-362" aria-hidden="true" tabindex="-1"></a>| Wert      | 1   | 5   | 10   | 50   | 100   |   500 | 1000 |</span>
<span id="cb23-363"><a href="#cb23-363" aria-hidden="true" tabindex="-1"></a>: Römische Ziffern {#tbl-ziffern}</span>
<span id="cb23-364"><a href="#cb23-364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-365"><a href="#cb23-365" aria-hidden="true" tabindex="-1"></a>Da die Werte der Ziffern bei einem Additionssystem einfach zusammengezählt werden, ist z.B. der Wert der römischen Zahl <span class="in">`XVII`</span> gleich 17.</span>
<span id="cb23-366"><a href="#cb23-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-367"><a href="#cb23-367" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb23-368"><a href="#cb23-368" aria-hidden="true" tabindex="-1"></a><span class="fu">## Subtraktionsregel</span></span>
<span id="cb23-369"><a href="#cb23-369" aria-hidden="true" tabindex="-1"></a>Die Subtraktionsregel ist eine übliche, verkürzende Schreibweise, mit der vermieden wird, vier gleiche Ziffern in direkter Aufeinanderfolge zu schreiben.\</span>
<span id="cb23-370"><a href="#cb23-370" aria-hidden="true" tabindex="-1"></a>Die Subtraktionsregel besagt, dass die Ziffern <span class="in">`I`</span>, <span class="in">`X`</span> und <span class="in">`C`</span> einer ihrer beiden jeweils nächstgrößeren Ziffern vorangestellt werden dürfen und dann in ihrem Zahlwert von dessen Wert abzuziehen sind:</span>
<span id="cb23-371"><a href="#cb23-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-372"><a href="#cb23-372" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`I`</span> vor <span class="in">`V`</span> oder <span class="in">`X`</span>: <span class="in">`IV`</span> = 4, <span class="in">`IX`</span> = 9</span>
<span id="cb23-373"><a href="#cb23-373" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`X`</span> vor <span class="in">`L`</span> oder <span class="in">`C`</span>: <span class="in">`XL`</span> = 40, <span class="in">`XC`</span> = 90</span>
<span id="cb23-374"><a href="#cb23-374" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`C`</span> vor <span class="in">`D`</span> oder <span class="in">`M`</span>: <span class="in">`CD`</span> = 400, <span class="in">`CM`</span> = 900</span>
<span id="cb23-375"><a href="#cb23-375" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-376"><a href="#cb23-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-377"><a href="#cb23-377" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb23-378"><a href="#cb23-378" aria-hidden="true" tabindex="-1"></a><span class="fu">## Der Wert der römischen Zahl `MCMLXXXIV`</span></span>
<span id="cb23-379"><a href="#cb23-379" aria-hidden="true" tabindex="-1"></a><span class="in">`MCMLXXXIV`</span> = $1000+(1000-100)+50+(3\cdot10)+(5-1)=1984$</span>
<span id="cb23-380"><a href="#cb23-380" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-381"><a href="#cb23-381" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-382"><a href="#cb23-382" aria-hidden="true" tabindex="-1"></a>Das Rechnen mit römischen Zahlen ist allerdings recht schwierig; hierfür wurden Hilfsmittel wie das <span class="co">[</span><span class="ot">Rechenbrett</span><span class="co">](https://de.wikipedia.org/wiki/Rechnen_auf_Linien)</span> und der <span class="co">[</span><span class="ot">Abakus</span><span class="co">]</span>(https://de.wikipedia.org/wiki/Abakus_(Rechenhilfsmittel)) verwendet.</span>
<span id="cb23-383"><a href="#cb23-383" aria-hidden="true" tabindex="-1"></a>Dabei werden die römischen Zahlen in ein Positionssystem überführt und Werten in der Form von Rechenmünzen oder Kugeln zugeordnet, mit denen dann die Rechenoperationen durchgeführt werden.</span>
<span id="cb23-384"><a href="#cb23-384" aria-hidden="true" tabindex="-1"></a>Das Rechnen mit Rechenbrett und Abakus war bis zum Ende des Mittelalters weit verbreitet und wurde erst durch die Einführung der indischen Zahlenschrift und des heute gebräuchlichen Dezimalsystems (siehe @sec-dezimal) abgelöst.</span>
<span id="cb23-385"><a href="#cb23-385" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-386"><a href="#cb23-386" aria-hidden="true" tabindex="-1"></a>Wir wollen aber nicht mit dem Abakus rechnen, sondern mit Python; dazu entwickeln wir eine Funktion, die römische Zahlen in das Dezimalsystem überführt.</span>
<span id="cb23-387"><a href="#cb23-387" aria-hidden="true" tabindex="-1"></a>Als ersten Schritt definieren wir hierzu ein *dictionary*, ein Objekt mit dem Datentyp <span class="in">`dict`</span>:</span>
<span id="cb23-388"><a href="#cb23-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-391"><a href="#cb23-391" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-392"><a href="#cb23-392" aria-hidden="true" tabindex="-1"></a>rom <span class="op">=</span> {<span class="st">'I'</span>: <span class="dv">1</span>, <span class="st">'V'</span>: <span class="dv">5</span>, <span class="st">'X'</span>: <span class="dv">10</span>, <span class="st">'L'</span>: <span class="dv">50</span>, <span class="st">'C'</span>: <span class="dv">100</span>, <span class="st">'D'</span>: <span class="dv">500</span>, <span class="st">'M'</span>: <span class="dv">1000</span>}</span>
<span id="cb23-393"><a href="#cb23-393" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-394"><a href="#cb23-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-395"><a href="#cb23-395" aria-hidden="true" tabindex="-1"></a>Ein <span class="in">`dict`</span> ist ein Objekt, dessen Elemente sogenannte *key-value pairs* sind, also Paare von Schlüsseln und zugehörigen Werten.</span>
<span id="cb23-396"><a href="#cb23-396" aria-hidden="true" tabindex="-1"></a>Diese Paare werden in Mengenklammern geschrieben und mit einem Komma voneinander getrennt.</span>
<span id="cb23-397"><a href="#cb23-397" aria-hidden="true" tabindex="-1"></a>Ein einzelnes Paar wird dabei in Form <span class="in">`k: v`</span> geschrieben, also Schlüssel, gefolgt von Doppelpunkt, gefolgt von zugeordnetem Wert.</span>
<span id="cb23-398"><a href="#cb23-398" aria-hidden="true" tabindex="-1"></a>Das Leerzeichen ist optional und kann weggelassen werden.</span>
<span id="cb23-399"><a href="#cb23-399" aria-hidden="true" tabindex="-1"></a>Wir haben unser *dictionary* <span class="in">`rom`</span> mit den Werten aus @tbl-ziffern initialisiert.</span>
<span id="cb23-400"><a href="#cb23-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-401"><a href="#cb23-401" aria-hidden="true" tabindex="-1"></a>Die Elemente können dann in einer <span class="in">`for`</span> Schleife durchlaufen und ausgegeben oder manipuliert werden:</span>
<span id="cb23-402"><a href="#cb23-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-405"><a href="#cb23-405" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-406"><a href="#cb23-406" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (k, v) <span class="kw">in</span> rom.items():</span>
<span id="cb23-407"><a href="#cb23-407" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">"Schlüssel: "</span>, k, <span class="st">", "</span>,<span class="st">"Wert: "</span>, v)</span>
<span id="cb23-408"><a href="#cb23-408" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-409"><a href="#cb23-409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-410"><a href="#cb23-410" aria-hidden="true" tabindex="-1"></a>Damit können wir dann die eigentliche Funktion definieren:</span>
<span id="cb23-411"><a href="#cb23-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-414"><a href="#cb23-414" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-415"><a href="#cb23-415" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> roman_to_decimal(roman):                        <span class="co"># &lt;1&gt;</span></span>
<span id="cb23-416"><a href="#cb23-416" aria-hidden="true" tabindex="-1"></a>  res <span class="op">=</span> <span class="dv">0</span>                                           <span class="co"># &lt;2&gt;</span></span>
<span id="cb23-417"><a href="#cb23-417" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(roman)):                       <span class="co"># &lt;3&gt;</span></span>
<span id="cb23-418"><a href="#cb23-418" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> rom[roman[i]] <span class="op">&gt;</span> rom[roman[i<span class="op">-</span><span class="dv">1</span>]]:   <span class="co"># &lt;4&gt;</span></span>
<span id="cb23-419"><a href="#cb23-419" aria-hidden="true" tabindex="-1"></a>      res <span class="op">+=</span> rom[roman[i]] <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> rom[roman[i<span class="op">-</span><span class="dv">1</span>]]    <span class="co"># &lt;5&gt;</span></span>
<span id="cb23-420"><a href="#cb23-420" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb23-421"><a href="#cb23-421" aria-hidden="true" tabindex="-1"></a>      res <span class="op">+=</span> rom[roman[i]]                          <span class="co"># &lt;6&gt;</span></span>
<span id="cb23-422"><a href="#cb23-422" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> res                                        <span class="co"># &lt;7&gt;</span></span>
<span id="cb23-423"><a href="#cb23-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-424"><a href="#cb23-424" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> roman_to_decimal(<span class="st">"MCMLXXXIV"</span>) <span class="op">==</span> <span class="dv">1984</span></span>
<span id="cb23-425"><a href="#cb23-425" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-426"><a href="#cb23-426" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Signatur der Funktion <span class="in">`roman_to_decimal`</span>.</span>
<span id="cb23-427"><a href="#cb23-427" aria-hidden="true" tabindex="-1"></a>Wir könnten die Bezeichner in Python auch in Deutsch angeben.</span>
<span id="cb23-428"><a href="#cb23-428" aria-hidden="true" tabindex="-1"></a>Um nicht deutschsprachigen Entwicklern aber die Möglichkeit zu geben, unsere Programme zu verstehen, verwenden wie lieber aussagekräftige englische Bezeichner.</span>
<span id="cb23-429"><a href="#cb23-429" aria-hidden="true" tabindex="-1"></a>Der Python Konvention folgend, verwenden wir dabei für zusammengesetzte Wörter die sogenannte *snake case* Schreibweise, bei der die einzelnen Worte mit Unterstich verbunden werden.</span>
<span id="cb23-430"><a href="#cb23-430" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Initialisierung des Ergebnisses mit <span class="in">`0`</span>. Wir verwenden hier den Bezeichner <span class="in">`res`</span>, als Kurzform des englischen *result*.</span>
<span id="cb23-431"><a href="#cb23-431" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Beginn der <span class="in">`for`</span> Schleife: wenn wir uns in der Schleife auf den Index des zu durchlaufenden Objekts beziehen (also auf die Position des aktuellen Wertes in dem Objekt), dann bezeichen wir die Schleifenvariable meist mit <span class="in">`i`</span>.</span>
<span id="cb23-432"><a href="#cb23-432" aria-hidden="true" tabindex="-1"></a>Das zu durchlaufende Objekt ist in diesem Fall eine <span class="in">`range`</span>, also ein Intervall.</span>
<span id="cb23-433"><a href="#cb23-433" aria-hidden="true" tabindex="-1"></a>Wenn die <span class="in">`range()`</span> Funktion mit nur einem Argument $a$ aufgerufen wird (hier die Länge der Zeichenkette (engl. *string*) <span class="in">`roman`</span>), dann erzeugt Python ein Intervall $[0, a)$.</span>
<span id="cb23-434"><a href="#cb23-434" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Wir testen, ob der Wert der aktuellen Ziffer größer ist als der Wert der vorhergehenden Ziffer. In diesem Fall müssen wir die Subtraktionsregel anwenden. Der Test wird nicht für die erste Ziffer durchgeführt.</span>
<span id="cb23-435"><a href="#cb23-435" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>Wenn die Subtraktionsregel greift, dann ziehen wir zweimal den Wert der vorhergehenden Ziffer vom bisherigen Resultat ab.</span>
<span id="cb23-436"><a href="#cb23-436" aria-hidden="true" tabindex="-1"></a>Wir müssen zweimal abziehen, da im vorangehenden Schleifendurchlauf dieser Wert fälschlicherweise addiert statt subtrahiert wurde.</span>
<span id="cb23-437"><a href="#cb23-437" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>Wenn die Subtraktionsregel nicht greift, dann addieren wir einfach den Wert der aktuellen Ziffer zum bisherigen Ergebnis.</span>
<span id="cb23-438"><a href="#cb23-438" aria-hidden="true" tabindex="-1"></a><span class="ss">7. </span>Rückgabe des Ergebnisses als Wert der Funktion.</span>
<span id="cb23-439"><a href="#cb23-439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-440"><a href="#cb23-440" aria-hidden="true" tabindex="-1"></a><span class="fu">### Dezimalsystem {#sec-dezimal}</span></span>
<span id="cb23-441"><a href="#cb23-441" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-442"><a href="#cb23-442" aria-hidden="true" tabindex="-1"></a>Das **Dezimalsystem** ist ein Positionssystem mit zehn Ziffern (von lateinisch *decem*, zehn) und ist die heute gebräuchliche Darstellung der Zahlen.</span>
<span id="cb23-443"><a href="#cb23-443" aria-hidden="true" tabindex="-1"></a>Das Dezimalsystem hat sich aus dem indischen Zahlensystem entwickelt, das bereits ab dem 3. Jahrhundert v. Chr. in Indien in Gebrauch war.</span>
<span id="cb23-444"><a href="#cb23-444" aria-hidden="true" tabindex="-1"></a>Im Jahr 628 n. Chr. führte der indische Mathematiker *Brahmagupta* die 0 als vollwertige Ziffer ein.</span>
<span id="cb23-445"><a href="#cb23-445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-446"><a href="#cb23-446" aria-hidden="true" tabindex="-1"></a>Wir verwenden heute aber nicht indische, sondern arabischen Ziffern. Das liegt daran, das sich das indische Zahlensystem im Mittelalter über den arabischen Sprachraum nach Europa ausgebreitet hat.</span>
<span id="cb23-447"><a href="#cb23-447" aria-hidden="true" tabindex="-1"></a>Die Regeln für das Rechnen mit arabischen Zahlen wurden in Europa erstmals von dem italienischen Mathematiker *Leonardo da Pisa* (besser bekannt als *Fibonacci*) beschrieben, die er in seinem "Rechenbuch" *Liber abbaci* im Jahr 1201 zusammengefasst hat.</span>
<span id="cb23-448"><a href="#cb23-448" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-449"><a href="#cb23-449" aria-hidden="true" tabindex="-1"></a>Der Wert einer Ziffer in einer Dezimalzahl ergibt sich durch die Position der Ziffer innerhalb der Zahl.</span>
<span id="cb23-450"><a href="#cb23-450" aria-hidden="true" tabindex="-1"></a>Um diesen Wert zu bestimmen, multiplizieren wir die Ziffer mit einer Zehnerpotenz $10^i$, wobei $i$ die Position der Ziffer in der Zahl ist.</span>
<span id="cb23-451"><a href="#cb23-451" aria-hidden="true" tabindex="-1"></a>Bei ganzen Zahlen wird dabei der Einerstelle (die letzte Ziffer ganz rechts in der Zahl) der Wert $i=0$ zugeordnet, der Zehnerstelle der Wert $i=1$, der Hunderterstelle der Wert $i=2$, usw.</span>
<span id="cb23-452"><a href="#cb23-452" aria-hidden="true" tabindex="-1"></a>Die sich daraus ergebenden Werte werden dann addiert:</span>
<span id="cb23-453"><a href="#cb23-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-454"><a href="#cb23-454" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb23-455"><a href="#cb23-455" aria-hidden="true" tabindex="-1"></a><span class="fu">## Berechnung des Wertes einer ganzen Zahl</span></span>
<span id="cb23-456"><a href="#cb23-456" aria-hidden="true" tabindex="-1"></a>$1984 = 4\cdot10^0+8\cdot 10^1+9\cdot10^2+1\cdot10^3=4+80+900+1000$</span>
<span id="cb23-457"><a href="#cb23-457" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-458"><a href="#cb23-458" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-459"><a href="#cb23-459" aria-hidden="true" tabindex="-1"></a>Die Berechnung des Wertes eines Dezimalbruchs (einer Dezimalzahl mit Stellen nach dem Komma) erfolgt analog:</span>
<span id="cb23-460"><a href="#cb23-460" aria-hidden="true" tabindex="-1"></a>der Wert einer Ziffer innerhalb der Zahl ergibt sich dadurch, dass die $n$-te Stelle vor dem Komma mit $10^{n-1}$ und die $m$-te Stelle nach dem Komma mit $10^{-m}$ multipliziert wird.</span>
<span id="cb23-461"><a href="#cb23-461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-462"><a href="#cb23-462" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb23-463"><a href="#cb23-463" aria-hidden="true" tabindex="-1"></a><span class="fu">## Der Wert einer Dezimalzahl</span></span>
<span id="cb23-464"><a href="#cb23-464" aria-hidden="true" tabindex="-1"></a>Ist $a$ eine Zahl mit den Ziffern $a_n,a_{n-1},\cdots,a_1,a_0$ vor dem Komma und den Ziffern $a_{-1},a_{-2},\cdots,a_{-m}$ nach dem Komma, dann gilt:</span>
<span id="cb23-465"><a href="#cb23-465" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-466"><a href="#cb23-466" aria-hidden="true" tabindex="-1"></a>a=\sum_{i=-m}^n a_i\cdot 10^i</span>
<span id="cb23-467"><a href="#cb23-467" aria-hidden="true" tabindex="-1"></a>$$ {#eq-dezimalzahl}</span>
<span id="cb23-468"><a href="#cb23-468" aria-hidden="true" tabindex="-1"></a>Die Stellen mit $i \geq 0$ bilden den ganzen Teil, die mit $i&lt;0$ den gebrochenen Teil der Zahl.</span>
<span id="cb23-469"><a href="#cb23-469" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-470"><a href="#cb23-470" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-471"><a href="#cb23-471" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb23-472"><a href="#cb23-472" aria-hidden="true" tabindex="-1"></a><span class="fu">## Berechnung des Wertes einer Dezimalzahl</span></span>
<span id="cb23-473"><a href="#cb23-473" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-474"><a href="#cb23-474" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb23-475"><a href="#cb23-475" aria-hidden="true" tabindex="-1"></a>486,25 &amp;= 4\cdot10^2+8\cdot10^1+6\cdot10^0+2\cdot10^{-1}+5\cdot10^{-2}<span class="sc">\\</span></span>
<span id="cb23-476"><a href="#cb23-476" aria-hidden="true" tabindex="-1"></a>&amp;= 400+80+6+0,2+0,05</span>
<span id="cb23-477"><a href="#cb23-477" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb23-478"><a href="#cb23-478" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-479"><a href="#cb23-479" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-480"><a href="#cb23-480" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-481"><a href="#cb23-481" aria-hidden="true" tabindex="-1"></a>Aus diesem gleichförmigen Aufbau der Dezimalzahlen ergeben sich dann die einfachen Rechenoperationen, die wir schon aus der Grundschule kennen.</span>
<span id="cb23-482"><a href="#cb23-482" aria-hidden="true" tabindex="-1"></a>Zum Beispiel können wir Dezimalzahlen addieren, indem wir ihre jeweiligen Dezimalstellen addieren und bei einem Ergbnis $\geq 10$ die $1$ auf die nächste Stelle übertragen:</span>
<span id="cb23-483"><a href="#cb23-483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-484"><a href="#cb23-484" aria-hidden="true" tabindex="-1"></a>::: {#fig-addition}</span>
<span id="cb23-485"><a href="#cb23-485" aria-hidden="true" tabindex="-1"></a>{{&lt; video media/videos/addition/480p15/addition.mp4 &gt;}}</span>
<span id="cb23-486"><a href="#cb23-486" aria-hidden="true" tabindex="-1"></a>Addition mit Übertrag</span>
<span id="cb23-487"><a href="#cb23-487" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-488"><a href="#cb23-488" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-489"><a href="#cb23-489" aria-hidden="true" tabindex="-1"></a>Hier sehen wir auch die besondere Rolle der $0$: obwohl sie selbst keinen Wert besitzt, ist sie doch als Platzhalter in einem Positionssystem unentbehrlich.</span>
<span id="cb23-490"><a href="#cb23-490" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-491"><a href="#cb23-491" aria-hidden="true" tabindex="-1"></a><span class="fu">### Dualsystem</span></span>
<span id="cb23-492"><a href="#cb23-492" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-493"><a href="#cb23-493" aria-hidden="true" tabindex="-1"></a>Das **Dualsystem** ist ein Positionssystem zur Basis 2, es gibt also nur zwei Ziffern $0,1$.</span>
<span id="cb23-494"><a href="#cb23-494" aria-hidden="true" tabindex="-1"></a>Es wird deshalb auch *Binärsystem* oder *Zweiersystem* genannt.</span>
<span id="cb23-495"><a href="#cb23-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-496"><a href="#cb23-496" aria-hidden="true" tabindex="-1"></a>Das Dualsystem spielt eine entscheidende Rolle in der Digitaltechnik, in der Zahlen durch elektrische Zustände dargestellt werden.</span>
<span id="cb23-497"><a href="#cb23-497" aria-hidden="true" tabindex="-1"></a>In einem elektronischen Schaltkreis gibt es nur zwei Zustände: entweder es liegt ein Signal vor (Strom an), oder eben nicht (Strom aus).</span>
<span id="cb23-498"><a href="#cb23-498" aria-hidden="true" tabindex="-1"></a>Diese Zustände werden zu Binärzahlen kombiniert, mit denen dann ein Computer "rechnet".\</span>
<span id="cb23-499"><a href="#cb23-499" aria-hidden="true" tabindex="-1"></a>*Informatiker* (Menschen, die Computerwissenschaften studiert haben) erzählen sich gerne folgenden Witz:</span>
<span id="cb23-500"><a href="#cb23-500" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-501"><a href="#cb23-501" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb23-502"><a href="#cb23-502" aria-hidden="true" tabindex="-1"></a><span class="fu">## Informatiker Witz</span></span>
<span id="cb23-503"><a href="#cb23-503" aria-hidden="true" tabindex="-1"></a>Es gibt 10 Arten von Menschen:</span>
<span id="cb23-504"><a href="#cb23-504" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-505"><a href="#cb23-505" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>diejenigen, die das Binärsystem verstanden haben</span>
<span id="cb23-506"><a href="#cb23-506" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>diejenigen, die es *nicht* verstanden haben</span>
<span id="cb23-507"><a href="#cb23-507" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-508"><a href="#cb23-508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-509"><a href="#cb23-509" aria-hidden="true" tabindex="-1"></a>Wenn du darüber lachen kannst, dann hast du es verstanden.</span>
<span id="cb23-510"><a href="#cb23-510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-511"><a href="#cb23-511" aria-hidden="true" tabindex="-1"></a>Auch Python rechnet intern mit Binärzahlen, d.h. jede Eingabe von Dezimalzahlen wird in Binärzahlen umgewandelt, mit denen die notwendigen Berechnungen durchgeführt werden.</span>
<span id="cb23-512"><a href="#cb23-512" aria-hidden="true" tabindex="-1"></a>Bei der Ausgabe des Ergebnisses werden diese Binärzahlen dann wieder zurück ins Dezimalsystem konvertiert.</span>
<span id="cb23-513"><a href="#cb23-513" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-514"><a href="#cb23-514" aria-hidden="true" tabindex="-1"></a>Dieser Vorgang ist für den Anwender *transparent*, d.h. wir als Programmierer merken nichts von der internen Umwandlung.</span>
<span id="cb23-515"><a href="#cb23-515" aria-hidden="true" tabindex="-1"></a>Für die Berechnung des Wertes einer ganzen Binärzahl gelten die Regeln aus @sec-dezimal analog, nur dass wir jede Ziffer nun mit einer Zweierpotenz $2^i$ multiplizieren; jede Ziffer hat dann den doppelten Stellenwert der ihr rechts folgenden Ziffer:</span>
<span id="cb23-516"><a href="#cb23-516" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-517"><a href="#cb23-517" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb23-518"><a href="#cb23-518" aria-hidden="true" tabindex="-1"></a><span class="fu">## Berechnung des Wertes einer Dualzahl</span></span>
<span id="cb23-519"><a href="#cb23-519" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-520"><a href="#cb23-520" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb23-521"><a href="#cb23-521" aria-hidden="true" tabindex="-1"></a>0100\ 1101_2&amp;=0\cdot2^7+1\cdot2^6+0\cdot2^5+0\cdot2^4+1\cdot2^3+1\cdot2^2+0\cdot2^1+1\cdot2^0<span class="sc">\\</span></span>
<span id="cb23-522"><a href="#cb23-522" aria-hidden="true" tabindex="-1"></a>&amp;=0+64+0+0+8+4+0+1=77_{10}</span>
<span id="cb23-523"><a href="#cb23-523" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb23-524"><a href="#cb23-524" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-525"><a href="#cb23-525" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-526"><a href="#cb23-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-527"><a href="#cb23-527" aria-hidden="true" tabindex="-1"></a>Werden mehrere Zahlensysteme gleichzeitig benutzt, so ist es zur Vermeidung von Irrtümern üblich, die Basis als Index anzuhängen.</span>
<span id="cb23-528"><a href="#cb23-528" aria-hidden="true" tabindex="-1"></a>Dualzahlen stellen wir zur besseren Lesbarkeit in Vierer-Blöcken dar.</span>
<span id="cb23-529"><a href="#cb23-529" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-530"><a href="#cb23-530" aria-hidden="true" tabindex="-1"></a>Die Berechnung reeller Zahlen im Dualsystem erfolgt analog zu @eq-dezimalzahl.</span>
<span id="cb23-531"><a href="#cb23-531" aria-hidden="true" tabindex="-1"></a>Der Wert einer Ziffer im Dualsytem (engl. *bit*, als Kurzform für *binary digit*) ergibt sich dadurch, dass die $n$-te Stelle mit $2^{n-1}$ und die $m$-te Stelle nach dem Komma mit $2^{-m}$ multipliziert wird:</span>
<span id="cb23-532"><a href="#cb23-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-533"><a href="#cb23-533" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb23-534"><a href="#cb23-534" aria-hidden="true" tabindex="-1"></a><span class="fu">## Der Wert einer Dualzahl</span></span>
<span id="cb23-535"><a href="#cb23-535" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-536"><a href="#cb23-536" aria-hidden="true" tabindex="-1"></a>b=\sum_{i=-m}^n b_i\cdot 2^i</span>
<span id="cb23-537"><a href="#cb23-537" aria-hidden="true" tabindex="-1"></a>$$ {#eq-dualzahl}</span>
<span id="cb23-538"><a href="#cb23-538" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-539"><a href="#cb23-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-540"><a href="#cb23-540" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb23-541"><a href="#cb23-541" aria-hidden="true" tabindex="-1"></a><span class="fu">## Berechnung einer reellen Zahl im Dualsystem</span></span>
<span id="cb23-542"><a href="#cb23-542" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-543"><a href="#cb23-543" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb23-544"><a href="#cb23-544" aria-hidden="true" tabindex="-1"></a>1011,01_2&amp;=1\cdot2^3+0\cdot2^2+1\cdot2^1+1\cdot2^0+0\cdot2^{-1}+1\cdot2^{-2}<span class="sc">\\</span></span>
<span id="cb23-545"><a href="#cb23-545" aria-hidden="true" tabindex="-1"></a>&amp;=8+2+1+\frac{1}{4}=11,25_{10}</span>
<span id="cb23-546"><a href="#cb23-546" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb23-547"><a href="#cb23-547" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb23-548"><a href="#cb23-548" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-549"><a href="#cb23-549" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-550"><a href="#cb23-550" aria-hidden="true" tabindex="-1"></a>Mit der Berechnung des Wertes einer Dualzahl haben wir diese Zahl in eine Dezimalzahl umgerechnet; dies wird auch als *Konvertierung* bezeichnet.</span>
<span id="cb23-551"><a href="#cb23-551" aria-hidden="true" tabindex="-1"></a>Mit diesen Regeln können wir jetzt eine Dualzahl mit Python in eine Dezimalzahl konvertieren:</span>
<span id="cb23-552"><a href="#cb23-552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-555"><a href="#cb23-555" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-556"><a href="#cb23-556" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bin_to_dec(binary):</span>
<span id="cb23-557"><a href="#cb23-557" aria-hidden="true" tabindex="-1"></a>  <span class="cf">assert</span> <span class="bu">type</span>(binary) <span class="op">==</span> <span class="bu">str</span>            <span class="co"># &lt;1&gt;</span></span>
<span id="cb23-558"><a href="#cb23-558" aria-hidden="true" tabindex="-1"></a>  s <span class="op">=</span> binary.split(<span class="st">','</span>)                 <span class="co"># &lt;2&gt;</span></span>
<span id="cb23-559"><a href="#cb23-559" aria-hidden="true" tabindex="-1"></a>  n <span class="op">=</span> <span class="bu">len</span>(s[<span class="dv">0</span>])                         <span class="co"># &lt;3&gt;</span></span>
<span id="cb23-560"><a href="#cb23-560" aria-hidden="true" tabindex="-1"></a>  m <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb23-561"><a href="#cb23-561" aria-hidden="true" tabindex="-1"></a>  decimal <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb23-562"><a href="#cb23-562" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> bit <span class="kw">in</span> s[<span class="dv">0</span>]:                      <span class="co"># &lt;4&gt;</span></span>
<span id="cb23-563"><a href="#cb23-563" aria-hidden="true" tabindex="-1"></a>    decimal <span class="op">+=</span> <span class="bu">int</span>(bit) <span class="op">*</span> <span class="dv">2</span><span class="op">**</span>(n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb23-564"><a href="#cb23-564" aria-hidden="true" tabindex="-1"></a>    n <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb23-565"><a href="#cb23-565" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> bit <span class="kw">in</span> s[<span class="dv">1</span>]:                      <span class="co"># &lt;5&gt;</span></span>
<span id="cb23-566"><a href="#cb23-566" aria-hidden="true" tabindex="-1"></a>    decimal <span class="op">+=</span> <span class="bu">int</span>(bit) <span class="op">*</span> <span class="dv">2</span><span class="op">**</span>(<span class="op">-</span>m)</span>
<span id="cb23-567"><a href="#cb23-567" aria-hidden="true" tabindex="-1"></a>    m <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb23-568"><a href="#cb23-568" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> decimal</span>
<span id="cb23-569"><a href="#cb23-569" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-570"><a href="#cb23-570" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> bin_to_dec(<span class="st">"1011,01"</span>) <span class="op">==</span> <span class="fl">11.25</span></span>
<span id="cb23-571"><a href="#cb23-571" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-572"><a href="#cb23-572" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Wir erwarten, dass die Funktion mit einem Argument vom Typ <span class="in">`str`</span> (also einer Zeichenkette) aufgerufen wird.</span>
<span id="cb23-573"><a href="#cb23-573" aria-hidden="true" tabindex="-1"></a>Wenn nicht, dann ergeben die nachfolgenden Berechnungen keinen Sinn, und wir brechen das Programm ab.</span>
<span id="cb23-574"><a href="#cb23-574" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Teilen des Eingabestrings in zwei Hälften, den Teil vor dem Komma und den Teil nach dem Komma.</span>
<span id="cb23-575"><a href="#cb23-575" aria-hidden="true" tabindex="-1"></a>Das Ergebnis ist eine Liste mit zwei Teilstrings.</span>
<span id="cb23-576"><a href="#cb23-576" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Belegen der Variablen <span class="in">`n`</span> mit der Länge des ersten Teilstrings (zur Erinnerung: der Index in Python beginnt mit 0).</span>
<span id="cb23-577"><a href="#cb23-577" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Wir durchlaufen die Zeichen im ersten Teilstring (die Ziffern vor dem Komma) und berechnen den Wert der jeweiligen Ziffer nach der Formel von @eq-dualzahl.</span>
<span id="cb23-578"><a href="#cb23-578" aria-hidden="true" tabindex="-1"></a>Die Schleifenvariable haben wir hier <span class="in">`bit`</span> genannt.</span>
<span id="cb23-579"><a href="#cb23-579" aria-hidden="true" tabindex="-1"></a>Nach jedem Durchlauf verringern wir den Wert von <span class="in">`n`</span> um 1.</span>
<span id="cb23-580"><a href="#cb23-580" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>Berechnung der Werte für die *bits* nach dem Komma.</span>
<span id="cb23-581"><a href="#cb23-581" aria-hidden="true" tabindex="-1"></a>Hier erhöhen wir den Wert von <span class="in">`m`</span> nach jedem Durchlauf um 1.</span>
<span id="cb23-582"><a href="#cb23-582" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-583"><a href="#cb23-583" aria-hidden="true" tabindex="-1"></a>Für das Rechnen mit Binärzahlen stellt Python sogenannte *bitwise operations* bereit:</span>
<span id="cb23-584"><a href="#cb23-584" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-585"><a href="#cb23-585" aria-hidden="true" tabindex="-1"></a>| Operation | Ergebnis                                     |</span>
<span id="cb23-586"><a href="#cb23-586" aria-hidden="true" tabindex="-1"></a>|:---------:|:-------------------------------------------- |</span>
<span id="cb23-587"><a href="#cb23-587" aria-hidden="true" tabindex="-1"></a>| <span class="in">`x | y`</span>   | bitwise *or* \ von <span class="in">`x`</span> und <span class="in">`y`</span>               |</span>
<span id="cb23-588"><a href="#cb23-588" aria-hidden="true" tabindex="-1"></a>| <span class="in">`x ^ y`</span>   | bitwise *exclusive or* \ von <span class="in">`x`</span> und <span class="in">`y`</span>     |</span>
<span id="cb23-589"><a href="#cb23-589" aria-hidden="true" tabindex="-1"></a>| <span class="in">`x &amp; y`</span>   | bitwise *and* \ von <span class="in">`x`</span> und <span class="in">`y`</span>              |</span>
<span id="cb23-590"><a href="#cb23-590" aria-hidden="true" tabindex="-1"></a>| <span class="in">`x &lt;&lt; n`</span>  | <span class="in">`x`</span> um <span class="in">`n`</span> bits nach links verschoben        |</span>
<span id="cb23-591"><a href="#cb23-591" aria-hidden="true" tabindex="-1"></a>| <span class="in">`x &gt;&gt; n`</span>  | <span class="in">`x`</span> um <span class="in">`n`</span> bits nach rechts verschoben       |</span>
<span id="cb23-592"><a href="#cb23-592" aria-hidden="true" tabindex="-1"></a>| <span class="in">`~x`</span>      | bitwise *not* \ : die bits von <span class="in">`x`</span> umgekehrt |</span>
<span id="cb23-593"><a href="#cb23-593" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-594"><a href="#cb23-594" aria-hidden="true" tabindex="-1"></a>Binärzahlen werden in der Regel zu Einheiten von acht *bits* zusammengefasst, die wir dann *byte* nennen.</span>
<span id="cb23-595"><a href="#cb23-595" aria-hidden="true" tabindex="-1"></a>Wenn wir ein *byte* in der Form $b=b_7 \ b_6 \ b_5 \ b_4 \ b_3 \ b_2 \ b_1 \ b_0$ darstellen, dann können wir die *bitwise operations* als Mengenoperationen (siehe @sec-mengen) auf *bytes* begreifen, indem wir jedes gesetzte *bit* über seinen Index darstellen:</span>
<span id="cb23-596"><a href="#cb23-596" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-599"><a href="#cb23-599" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-600"><a href="#cb23-600" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="bn">0b10000010</span>                                   <span class="co"># &lt;1&gt;</span></span>
<span id="cb23-601"><a href="#cb23-601" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="bn">0b10010000</span></span>
<span id="cb23-602"><a href="#cb23-602" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"x = </span><span class="sc">{</span>x<span class="sc">:#0b}</span><span class="ss">"</span>, <span class="st">"= {7, 1}"</span>)                <span class="co"># &lt;2&gt;</span></span>
<span id="cb23-603"><a href="#cb23-603" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"y = </span><span class="sc">{</span>y<span class="sc">:#0b}</span><span class="ss">"</span>, <span class="st">"= {7, 4}"</span>)</span>
<span id="cb23-604"><a href="#cb23-604" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-605"><a href="#cb23-605" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Definition von <span class="in">`x`</span> als Binärzahl: wir verwenden hierzu das Präfix <span class="in">`0b`</span>.</span>
<span id="cb23-606"><a href="#cb23-606" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Ausgabe von <span class="in">`x`</span> im Binärformat und der Menge der gesetzten Indizes, das sind die Stellen der Binärzahl, an denen ein *bit* auf 1 gesetzt ist. Wir verwenden hierzu einen sogenannten `f-string` für engl. *formatted string*.</span>
<span id="cb23-607"><a href="#cb23-607" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-608"><a href="#cb23-608" aria-hidden="true" tabindex="-1"></a>Die Mengenoperationen können dann so ausgeführt werden:</span>
<span id="cb23-609"><a href="#cb23-609" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-612"><a href="#cb23-612" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-613"><a href="#cb23-613" aria-hidden="true" tabindex="-1"></a><span class="co"># bitwise or</span></span>
<span id="cb23-614"><a href="#cb23-614" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Vereinigungsmenge (x|y): </span><span class="sc">{</span>x<span class="op">|</span>y<span class="sc">:#0b}</span><span class="ss">"</span>, <span class="st">"= {7, 4, 1}"</span>)</span>
<span id="cb23-615"><a href="#cb23-615" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-616"><a href="#cb23-616" aria-hidden="true" tabindex="-1"></a><span class="co"># bitwise and</span></span>
<span id="cb23-617"><a href="#cb23-617" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Schnittmenge (x&amp;y): </span><span class="sc">{</span>x<span class="op">&amp;</span>y<span class="sc">:#0b}</span><span class="ss">"</span>, <span class="st">"= </span><span class="sc">{7}</span><span class="st">"</span>)</span>
<span id="cb23-618"><a href="#cb23-618" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-619"><a href="#cb23-619" aria-hidden="true" tabindex="-1"></a><span class="co"># bit clear (and not)</span></span>
<span id="cb23-620"><a href="#cb23-620" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Differenz (x&amp;~y): </span><span class="sc">{</span>x<span class="op">&amp;~</span>y<span class="sc">:#0b}</span><span class="ss">"</span>, <span class="st">"= </span><span class="sc">{1}</span><span class="st">"</span>)</span>
<span id="cb23-621"><a href="#cb23-621" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-622"><a href="#cb23-622" aria-hidden="true" tabindex="-1"></a><span class="co"># bitwise xor</span></span>
<span id="cb23-623"><a href="#cb23-623" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Symmetrische Differenz (x^y): </span><span class="sc">{</span>x<span class="op">^</span>y<span class="sc">:#0b}</span><span class="ss">"</span>, <span class="st">"= {4, 1}"</span>)</span>
<span id="cb23-624"><a href="#cb23-624" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-625"><a href="#cb23-625" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-626"><a href="#cb23-626" aria-hidden="true" tabindex="-1"></a>Die *shift* Operatoren `&lt;&lt;` und `&gt;&gt;` verschieben die *bits* einer Binärzahl um $n$ Stellen nach links bzw. rechts.</span>
<span id="cb23-627"><a href="#cb23-627" aria-hidden="true" tabindex="-1"></a>Dabei wird die Zahl bei *links-shift* mit `&lt;&lt;` von rechts mit 0-*bits* aufgefüllt, der Wert der Zahl verdoppelt sich also mit jedem *shift*.</span>
<span id="cb23-628"><a href="#cb23-628" aria-hidden="true" tabindex="-1"></a>Demnach ist z.B. <span class="in">`x &lt;&lt; 3`</span> gleichbedeutend mit $x\cdot2^3$.</span>
<span id="cb23-629"><a href="#cb23-629" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-632"><a href="#cb23-632" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-633"><a href="#cb23-633" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb23-634"><a href="#cb23-634" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"a = </span><span class="sc">{</span>a<span class="sc">:#0b}</span><span class="ss"> = </span><span class="sc">{</span>a<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-635"><a href="#cb23-635" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> a <span class="op">&lt;&lt;</span> <span class="dv">3</span></span>
<span id="cb23-636"><a href="#cb23-636" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"b = </span><span class="sc">{</span>b<span class="sc">:#0b}</span><span class="ss"> = </span><span class="sc">{</span>b<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-637"><a href="#cb23-637" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> b <span class="op">==</span> a <span class="op">*</span> <span class="dv">2</span><span class="op">**</span><span class="dv">3</span></span>
<span id="cb23-638"><a href="#cb23-638" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-639"><a href="#cb23-639" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-640"><a href="#cb23-640" aria-hidden="true" tabindex="-1"></a>Bei einem rechts-*shift* mit `x &gt;&gt; n` werden `n` Stellen am rechten Ende von `x` abgeschnitten, der Wert der Zahl halbiert sich also mit jedem *shift*.</span>
<span id="cb23-641"><a href="#cb23-641" aria-hidden="true" tabindex="-1"></a>Wenn das letzte bit $b_0$ dabei gesetzt ist, die Zahl also ungerade ist, dann geht der Rest der Division durch 2 dabei verloren; es gilt also: <span class="in">`x &gt;&gt; 1`</span> ist gleichbedeutend mit <span class="in">`x // 2`</span>.</span>
<span id="cb23-642"><a href="#cb23-642" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-645"><a href="#cb23-645" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-646"><a href="#cb23-646" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"a = </span><span class="sc">{</span>a<span class="sc">:#0b}</span><span class="ss"> = </span><span class="sc">{</span>a<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-647"><a href="#cb23-647" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> a <span class="op">&gt;&gt;</span> <span class="dv">1</span></span>
<span id="cb23-648"><a href="#cb23-648" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"c = </span><span class="sc">{</span>c<span class="sc">:#0b}</span><span class="ss"> = </span><span class="sc">{</span>c<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-649"><a href="#cb23-649" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> c <span class="op">==</span> a <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb23-650"><a href="#cb23-650" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-651"><a href="#cb23-651" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-652"><a href="#cb23-652" aria-hidden="true" tabindex="-1"></a><span class="fu">## Übungen</span></span>
<span id="cb23-653"><a href="#cb23-653" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-654"><a href="#cb23-654" aria-hidden="true" tabindex="-1"></a>Die Übungen dieser Lektion findest du im Notebook <span class="in">`arithmetik/_mengen.ipynb`</span>.</span>
<span id="cb23-655"><a href="#cb23-655" aria-hidden="true" tabindex="-1"></a>Öffne diese Datei in *Jupyter* und erforsche des Rechnen mit verschiedenen Zahlensystemen.</span>
</code><button title="In die Zwischenablage kopieren" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<script>videojs(video_shortcode_videojs_video1);</script>




</body></html>