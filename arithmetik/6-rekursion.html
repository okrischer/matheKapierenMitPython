<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Rekursion – Mathe kapieren mit Python</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="../site_libs/quarto-contrib/videojs/video.min.js"></script>
<link href="../site_libs/quarto-contrib/videojs/video-js.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Keine Treffer",
    "search-matching-documents-text": "Treffer",
    "search-copy-link-title": "Link in die Suche kopieren",
    "search-hide-matches-text": "Zusätzliche Treffer verbergen",
    "search-more-match-text": "weitere Treffer in diesem Dokument",
    "search-more-matches-text": "weitere Treffer in diesem Dokument",
    "search-clear-button-title": "Zurücksetzen",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Abbrechen",
    "search-submit-button-title": "Abschicken",
    "search-label": "Suchen"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../arithmetik/1-rechenregeln.html">Arithmetik</a></li><li class="breadcrumb-item"><a href="../arithmetik/6-rekursion.html">Rekursion</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Suchen" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Mathe kapieren mit Python</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Suchen"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Arithmetik</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../arithmetik/1-rechenregeln.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Grundlegende Rechenregeln</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../arithmetik/2-teiler.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Teiler und Vielfache</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../arithmetik/3-mengen.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Zahlenbereiche und Zahlensysteme</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../arithmetik/4-bruchrechnung.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Bruchrechnung</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../arithmetik/5-logarithmen.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Potenzen, Wurzeln, Logarithmen</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../arithmetik/6-rekursion.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Rekursion</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Auf dieser Seite</h2>
   
  <ul>
  <li><a href="#mathematische-beispiele" id="toc-mathematische-beispiele" class="nav-link active" data-scroll-target="#mathematische-beispiele"><span class="header-section-number">1</span> Mathematische Beispiele</a>
  <ul class="collapse">
  <li><a href="#fakultät" id="toc-fakultät" class="nav-link" data-scroll-target="#fakultät"><span class="header-section-number">1.1</span> Fakultät</a></li>
  <li><a href="#größter-gemeinsamer-teiler" id="toc-größter-gemeinsamer-teiler" class="nav-link" data-scroll-target="#größter-gemeinsamer-teiler"><span class="header-section-number">1.2</span> Größter gemeinsamer Teiler</a></li>
  <li><a href="#fibonacci-folge" id="toc-fibonacci-folge" class="nav-link" data-scroll-target="#fibonacci-folge"><span class="header-section-number">1.3</span> Fibonacci-Folge</a></li>
  </ul></li>
  <li><a href="#die-türme-von-hanoi" id="toc-die-türme-von-hanoi" class="nav-link" data-scroll-target="#die-türme-von-hanoi"><span class="header-section-number">2</span> Die Türme von Hanoi</a>
  <ul class="collapse">
  <li><a href="#lösungsansatz" id="toc-lösungsansatz" class="nav-link" data-scroll-target="#lösungsansatz"><span class="header-section-number">2.1</span> Lösungsansatz</a></li>
  <li><a href="#implementierung" id="toc-implementierung" class="nav-link" data-scroll-target="#implementierung"><span class="header-section-number">2.2</span> Implementierung</a></li>
  <li><a href="#laufzeitanalyse" id="toc-laufzeitanalyse" class="nav-link" data-scroll-target="#laufzeitanalyse"><span class="header-section-number">2.3</span> Laufzeitanalyse</a></li>
  </ul></li>
  <li><a href="#übungen" id="toc-übungen" class="nav-link" data-scroll-target="#übungen"><span class="header-section-number">3</span> Übungen</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../arithmetik/1-rechenregeln.html">Arithmetik</a></li><li class="breadcrumb-item"><a href="../arithmetik/6-rekursion.html">Rekursion</a></li></ol></nav>
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Rekursion</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Rekursion ist eine wichtige Problemlösungsstrategie der Mathematik und der Programmierung. Komplexe Sachverhalte können oft mit rekursiv formulierten Regeln sehr elegant erfasst werden. Das Grundprinzip der Rekursion besteht darin, eine komplexe Aufgabe in gleichförmige Teilaufgaben zu zerlegen, die dann einfach gelöst werden können.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Rekursion
</div>
</div>
<div class="callout-body-container callout-body">
<p>Als Rekursion wird ein prinzipiell unendlicher Vorgang bezeichnet, der sich selbst als Teil enthält oder mithilfe von sich selbst definierbar ist.<br>
Die bei der Rekursion aufeinander folgenden Teilvorgänge sind nicht unabhängig voneinander, sondern zwischen jedem Schrittpaar besteht eine besondere, die <em>rekursive Beziehung</em>.</p>
</div>
</div>
<p>Das klingt erstmal nicht besonders einleuchtend. Ein alltägliches Beispiel kann das Funktionsprinzip der Rekursion vielleicht erhellen:</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Einschrauben ein Glühbirne
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Frage</strong>: Wie viele Umdrehungen sind nötig, um eine Glühbirne einzuschrauben?<br>
<strong>Antwort</strong>: Ist sie bereits eingeschraubt? Dann ist die Antwort null. Wenn nicht, dann drehe sie einmal, frage mich erneut, und addiere 1 zu meiner Antwort.</p>
</div>
</div>
<section id="mathematische-beispiele" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="mathematische-beispiele"><span class="header-section-number">1</span> Mathematische Beispiele</h2>
<p>Mathematische Objekte werden häufig <em>rekursiv</em> definiert, d.h. mit Bezug auf sich selbst. Solche Objekte können dann mit Hilfe von Rekursion bestimmt werden.</p>
<section id="fakultät" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="fakultät"><span class="header-section-number">1.1</span> Fakultät</h3>
<p>Als erstes Beispiel für Rekursion wollen wir die Berechnung der <em>Fakultät</em> untersuchen.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Fakultät
</div>
</div>
<div class="callout-body-container callout-body">
<p>Die Funktion Fakultät (<span class="math inline">\(n!\)</span>) einer natürlichen Zahl <span class="math inline">\(n \geq 1\)</span> ist definiert als das Produkt der Zahlen 1 bis <span class="math inline">\(n\)</span>: <span id="eq-fakt"><span class="math display">\[
n! = 1\cdot2\cdot3\cdots n=\prod_{k=1}^n{k}
\tag{1}\]</span></span></p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Beispiele
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math display">\[
\begin{align}
1! &amp;= 1 &amp;= &amp; 1 \\
2! &amp;= 1\cdot2 &amp;= &amp; 2 \\
3! &amp;= 1\cdot2\cdot3 &amp;= &amp; 6 \\
4! &amp;= 1\cdot2\cdot3\cdot4 &amp;= &amp; 24 \\
\end{align}
\]</span></p>
</div>
</div>
<p>Soll diese Liste fortgesetzt werden, ergibt sich die Rekursivität nahezu von selbst. Für die Berechnung von <span class="math inline">\(5!\)</span> wollen wir nicht von vorn beginnen, sondern wir greifen auf das vorherige Ergebniss zurück, also <span class="math inline">\(5! = 4! \cdot 5=24\cdot5=120\)</span>.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Rekursive Definition der Fakultät
</div>
</div>
<div class="callout-body-container callout-body">
<p>Verallgemeinert lässt sich die Funktion Fakultät somit <em>rekursiv</em> definieren: <span id="eq-fakt-rek"><span class="math display">\[
n! =
\begin{cases}
1 &amp;\text{, falls} \ n=1 &amp;\text{(Rekursionsanfang)}\\
n \cdot (n-1)! &amp;\text{, sonst} &amp;\text{(Rekursionsschritt)}
\end{cases}
\tag{2}\]</span></span></p>
</div>
</div>
<p>Wir können den Wert der Fakultät also mittes Rekursion in Python bestimmen:</p>
<div id="665842a3" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="annotated-cell-1"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-1-1" class="code-annotation-target"><a href="#annotated-cell-1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fakultät(n):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-1-2" class="code-annotation-target"><a href="#annotated-cell-1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="annotated-cell-1-3"><a href="#annotated-cell-1-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="annotated-cell-1-4"><a href="#annotated-cell-1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-1-5" class="code-annotation-target"><a href="#annotated-cell-1-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n <span class="op">*</span> fakultät(n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="annotated-cell-1-6"><a href="#annotated-cell-1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-7"><a href="#annotated-cell-1-7" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> fakultät(<span class="dv">5</span>) <span class="op">==</span> <span class="dv">120</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-1" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="1" data-code-annotation="1">Signatur der rekursiven Funktion <code>fakultät</code>. Das entspricht einer “gewöhnlichen” Funktionsdefinition; eine rekursive Funktion muss in Python nicht besonders gekennzeichnet werden.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="2" data-code-annotation="2"><strong>Rekursionsanfang</strong>: Test, ob der Eingabewert dem definierten Rekursionsanfang entspricht. Falls ja, geben wir den Wert 1 zurück.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="5" data-code-annotation="3"><strong>Rekursionsschritt</strong>: Wenn der Eingabewert nicht dem Rekursionsanfang entspricht, dann wird das Ergebnis rekursiv berechnet, d.h. die Funktion ruft sich selbst mit neuem Argument auf. Das neue Argument ist in diesem Fall <code>n-1</code>.</span>
</dd>
</dl>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Rekursive Funktion
</div>
</div>
<div class="callout-body-container callout-body">
<p>Rekursion wird in der Programmierung über eine <em>rekursive Funktion</em> abgebildet, d.h. mit einer Funktion, die sich selbst wiederholt aufruft.<br>
Entsprechend der rekursiven Definition muss auch eine rekursive Funktion dabei immer zwei Fälle berücksichtigen:</p>
<ul>
<li><strong>Rekursionsanfang</strong>: Falls der definierte Wert für den Rekursionsanfang erreicht ist, gibt die Funktion das dafür definierte Ergebnis aus. In diesem Fall darf kein weiterer rekursiver Aufruf erfolgen.</li>
<li><strong>Rekursionsschritt</strong>: Falls der Eingabewert nicht dem Rekursionsanfang entspricht, wird der nächste Schritt der Berechnung durchgeführt, indem sich die Funktion mit einem neuen Argument selbst wieder aufruft.</li>
</ul>
<p><strong>Beachte</strong>: Das neue Argument für den rekursiven Aufruf muss <em>immer</em> so gewählt werden, dass es sich dem Wert des Rekursionsanfangs annähert und am Ende auch diesen Wert erreicht.</p>
</div>
</div>
<p>Bei der Fakultät handelt es sich um eine <em>linear rekursive</em> Definition, bei der höchstens <em>ein</em> rekursiver Aufruf vorkommt. Die Berechnung mittels Python verläuft daher entlang einer Kette von Aufrufen. Bei einer solchen Rekursion enthält der <em>Aufrufbaum</em> also keine Verzweigungen.</p>
<p>Um die Abarbeitung des Aufrufbaums verdeutlichen, ergänzen wir die Funktion <code>fakultät</code> um zwei Ausgaben:</p>
<div id="b6c9a9e1" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fakultät(n):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">: Rekursionsanfang erreicht"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">: Rekursionsschritt mit neuem Argument </span><span class="sc">{</span>n<span class="op">-</span><span class="dv">1</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n <span class="op">*</span> fakultät(n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>fakultät(<span class="dv">5</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>n = 5: Rekursionsschritt mit neuem Argument 4
n = 4: Rekursionsschritt mit neuem Argument 3
n = 3: Rekursionsschritt mit neuem Argument 2
n = 2: Rekursionsschritt mit neuem Argument 1
n = 1: Rekursionsanfang erreicht</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>120</code></pre>
</div>
</div>
<p>Damit ein rekursives Programm das Ergebnis berechnen kann, müssen alle bisherigen Teilergebnisse zwischengespeichert werden. Das passiert automatisch in einem besonderen Programmspeicher, dem sogenannten <em>program stack</em>. Wenn es sich um eine sehr komplexe Berechnung handelt, oder wenn sich das Argument des rekursiven Aufrufs nicht dem Wert des Rekursionsanfangs annähert, dann muss das Programm sehr viele dieser Zwischenergebnisse speichern. Im schlimmsten Fall führt das zu einem Programmabruch, weil der Progammspeicher voll ist; das ist bekannt als <em>stack overflow</em>.</p>
<p>Einige funktionale Programmiersprachen (wie z.B. Haskell, F# oder Scala) umgehen dieses Problem, indem sie eine optimierte Abarbeitung ermöglichen, die eine rekursive Schleife intern in eine iterative Schleife umwandelt. Dazu muss aber eine sogenannte <em>endständige Rekursion</em> vorliegen, in der der rekursive Aufruf der letzte Aufruf der Funktion ist; außerdem dürfen bei diesem Aufruf keine weiteren Operationen durchgeführt werden.</p>
<p>Unsere Funktion <code>fakultät</code> ist also nicht <em>endständig rekursiv</em>, da der rekursive Aufruf zusätzlich mit einer Multiplikation verknüpft ist. Das Problem kann aber gelöst werden, indem wir die Multiplikation vorher durchführen und das Produkt mit einem zusätzlichen Parameter dem rekursiven Aufruf hinzufügen.</p>
<div id="1e6cc079" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="annotated-cell-3"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-3-1" class="code-annotation-target"><a href="#annotated-cell-3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fakultät(n):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-3-2" class="code-annotation-target"><a href="#annotated-cell-3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> rek(n, p):</span>
<span id="annotated-cell-3-3"><a href="#annotated-cell-3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="annotated-cell-3-4"><a href="#annotated-cell-3-4" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Rekursionsanfang, Ergebnis = </span><span class="sc">{</span>p<span class="sc">}</span><span class="ss">"</span>)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-3-5" class="code-annotation-target"><a href="#annotated-cell-3-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> p</span>
<span id="annotated-cell-3-6"><a href="#annotated-cell-3-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-3-7" class="code-annotation-target"><a href="#annotated-cell-3-7" aria-hidden="true" tabindex="-1"></a>            p <span class="op">*=</span> n</span>
<span id="annotated-cell-3-8"><a href="#annotated-cell-3-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">, produkt = </span><span class="sc">{</span>p<span class="sc">}</span><span class="ss">"</span>)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="5" onclick="event.preventDefault();">5</a><span id="annotated-cell-3-9" class="code-annotation-target"><a href="#annotated-cell-3-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> rek(n<span class="op">-</span><span class="dv">1</span>, p)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="6" onclick="event.preventDefault();">6</a><span id="annotated-cell-3-10" class="code-annotation-target"><a href="#annotated-cell-3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> rek(n, <span class="dv">1</span>)</span>
<span id="annotated-cell-3-11"><a href="#annotated-cell-3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-12"><a href="#annotated-cell-3-12" aria-hidden="true" tabindex="-1"></a>fakultät(<span class="dv">5</span>)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-3" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="1" data-code-annotation="1">Definition einer “gewöhnlichen” Funktion.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="2" data-code-annotation="2">Definition einer inneren, rekursiven Funktion mit einem zweiten Parameter für die Speicherung der Zwischenergebnisse.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="5" data-code-annotation="3">Rekursionsanfang: wir geben hier anstelle der 1 das letzte Teilergebnis zurück.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="7" data-code-annotation="4">Durchführung der Multiplikation und Zuweisung an <code>p</code>, dem Teilergebnis.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="9" data-code-annotation="5">Rekursiver Aufruf mit neuem Argument und bisherigem Teilergebnis.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="6">6</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="10" data-code-annotation="6">Aufruf der rekursiven Funktion mit dem definierten Wert für den Rekursionsanfang.</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>n = 5, produkt = 5
n = 4, produkt = 20
n = 3, produkt = 60
n = 2, produkt = 120
Rekursionsanfang, Ergebnis = 120</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>120</code></pre>
</div>
</div>
<p>In einer imperativen Sprachen wie Python ist diese Optimierung aber ohne Belang: der Compiler bzw. Interpreter kann kann eine endständige Rekursion nicht automatisch in eine iterative Schleife überführen.<br>
Aber wir können eine lineare Rekursion auch explizit als iterative Schleife ausdrücken. Das Vorgehen hierzu entspricht dem der endständigen Rekursion:</p>
<div id="0a9a2dc1" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="annotated-cell-4"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-4-1"><a href="#annotated-cell-4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fakultät(n):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-4-2" class="code-annotation-target"><a href="#annotated-cell-4-2" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="dv">1</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-4-3" class="code-annotation-target"><a href="#annotated-cell-4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> n <span class="op">!=</span> <span class="dv">1</span>:</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-4-4" class="code-annotation-target"><a href="#annotated-cell-4-4" aria-hidden="true" tabindex="-1"></a>        p <span class="op">*=</span> n</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-4-5" class="code-annotation-target"><a href="#annotated-cell-4-5" aria-hidden="true" tabindex="-1"></a>        n <span class="op">-=</span> <span class="dv">1</span></span>
<span id="annotated-cell-4-6"><a href="#annotated-cell-4-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">, produkt = </span><span class="sc">{</span>p<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="annotated-cell-4-7"><a href="#annotated-cell-4-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Rekursionsanfang, Ergebnis = </span><span class="sc">{</span>p<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="annotated-cell-4-8"><a href="#annotated-cell-4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> p</span>
<span id="annotated-cell-4-9"><a href="#annotated-cell-4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-10"><a href="#annotated-cell-4-10" aria-hidden="true" tabindex="-1"></a>fakultät(<span class="dv">5</span>)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-4" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="2" data-code-annotation="1">Initialisierung des Ergebnisses mit 1, dem Wert für den Rekursionsanfang.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="3" data-code-annotation="2">Beginn einer iterativen Schleife, deren Bedingung prüft, ob der Rekursionsanfang erreicht wurde.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="4" data-code-annotation="3">Durchführung der Multiplikation und Zuweisung an <code>p</code>, dem Teilergebnis.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="5" data-code-annotation="4">Verringerung der Schleifenvariablen um 1.</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>n = 4, produkt = 5
n = 3, produkt = 20
n = 2, produkt = 60
n = 1, produkt = 120
Rekursionsanfang, Ergebnis = 120</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>120</code></pre>
</div>
</div>
</section>
<section id="größter-gemeinsamer-teiler" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="größter-gemeinsamer-teiler"><span class="header-section-number">1.2</span> Größter gemeinsamer Teiler</h3>
<p>In Lektion <a href="../arithmetik/2-teiler.html#sec-ggT">Teiler und Vielfache</a> haben wir den größten gemeinsamen Teiler zweier ganzer Zahlen iterativ berechnet mit folgender Funktion:</p>
<div id="8f503af6" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ggT_iter(a, b):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> b <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        a, b <span class="op">=</span> b, a <span class="op">%</span> b</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Hier werden innerhalb der itertiven Schleife nur zwei Anweisungen wiederholt ausgeführt:</p>
<blockquote class="blockquote">
<p>setze <code>a</code> gleich <code>b</code>, und <code>b</code> gleich <code>a % b</code>.</p>
</blockquote>
<p>Genauso, wie wir eine rekursive Schleife in eine iterative Schleife überführen können, können wir auch den umgekehrten Schritt machen: eine itertive Schleife als rekursive Schleife ausdrücken:</p>
<div id="c13e0fa5" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ggT_rek(a, b):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> b <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> a</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: <span class="cf">return</span> ggT_rek(b, a <span class="op">%</span> b)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Hier werden die selben Anweisungen ausgeführt, aber dieses mal in einer rekursiven Schleife, indem die Funktion mit den entprechenden Argumenten aufgerufen wird:</p>
<blockquote class="blockquote">
<p>setze Parameter <code>a</code> auf <code>b</code>, und Parameter <code>b</code> auf <code>a % b</code>.</p>
</blockquote>
<p>Wir haben in beiden Versionen exakt denselben Algorithmus implementiert, mit der Folge, dass die Funktionen das selbe Ergebnis mit der selben Anzahl von Berechnungsschritten liefern:</p>
<div id="72bcc180" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> ggT_iter(<span class="dv">143</span>, <span class="dv">65</span>) <span class="op">==</span> ggT_rek(<span class="dv">143</span>, <span class="dv">65</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> ggT_iter(<span class="dv">3780</span>, <span class="dv">3528</span>) <span class="op">==</span> ggT_rek(<span class="dv">3780</span>, <span class="dv">3528</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Es besteht aber ein <em>semantischer</em> Unterschied, d.h. in der Art <em>wie</em> wir den Algorithmus ausdrücken.<br>
Die <strong>iterative Variante</strong> folgt diesem Muster:</p>
<blockquote class="blockquote">
<p>solange der Rekursionsanfang <em>nicht</em> erreicht ist:<br>
&gt;&gt;&gt; wiederhole die Anweisungen<br>
anderenfalls gib das Ergebnis aus</p>
</blockquote>
<p>Die <strong>rekursive Variante</strong> folgt diesem Muster:</p>
<blockquote class="blockquote">
<p>wenn der Rekursionsanfang erreicht ist:<br>
gib das Ergebnis aus<br>
&gt;&gt;&gt; anderenfalls wiederhole die Anweisungen</p>
</blockquote>
</section>
<section id="fibonacci-folge" class="level3" data-number="1.3">
<h3 data-number="1.3" class="anchored" data-anchor-id="fibonacci-folge"><span class="header-section-number">1.3</span> Fibonacci-Folge</h3>
<p>Das Paradebeispiel rekursiver Definitionen in der Mathematik ist die sogenannte <em>Fibonacci Folge</em>. Benannt ist die Folge nach dem italienischen Mathematiker Leonardo Fibonacci, den wir bereits in der Lektion <a href="../arithmetik/3-mengen.html#sec-dezimal">Zahlenbereiche und Zahlensysteme</a> kennengelernt haben. Fibonacci hatte mit dieser Zahlenfolge in seinem Rechenbuch <em>Liber abbaci</em> das Wachstum einer (fiktiven) Kaninchenpopulation beschrieben.</p>
<p>Die Fibonacci-Folge ist die unendliche Folge natürlicher Zahlen, die mit den Zahlen 0 und 1 beginnt, und bei der jede Zahl die Summe der beiden ihr vorangehenden Zahlen ist. Die Fibonacci-Folge ist also deshalb <em>rekursiv</em>, weil ihre Elemente in Bezug auf ihre jeweils vorangehenden Elemente definiert sind.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Rekursive Definition der Fibonacci-Folge
</div>
</div>
<div class="callout-body-container callout-body">
<p>Die Fibonacci-Folge ist wie folgt mathematisch definiert: <span id="eq-fibonacci"><span class="math display">\[
\begin{align}
F_0 &amp;= 0 \\
F_1 &amp;= 1 \\
F_n &amp;= F_{n-1} + F_{n-2}
\end{align}
\tag{3}\]</span></span></p>
</div>
</div>
<p>Wir können die Zahlen der Fibonacci-Folge also mittels Rekursion in Python bestimmen:</p>
<div id="f1649ddb" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="annotated-cell-8"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-8-1"><a href="#annotated-cell-8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib_rek(n):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-8" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-8-2" class="code-annotation-target"><a href="#annotated-cell-8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="annotated-cell-8-3"><a href="#annotated-cell-8-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n</span>
<span id="annotated-cell-8-4"><a href="#annotated-cell-8-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-8" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-8-5" class="code-annotation-target"><a href="#annotated-cell-8-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> fib_rek(n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib_rek(n<span class="op">-</span><span class="dv">2</span>)</span>
<span id="annotated-cell-8-6"><a href="#annotated-cell-8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-8-7"><a href="#annotated-cell-8-7" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> fib_rek(<span class="dv">10</span>) <span class="op">==</span> <span class="dv">55</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-8" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-8" data-code-lines="2" data-code-annotation="1"><em>Rekursionsanfang</em>: Test, ob <code>n</code> gleich 0 oder 1 ist. Falls ja, dann geben wir <code>n</code> als Ergebnis zurück</span>
</dd>
<dt data-target-cell="annotated-cell-8" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-8" data-code-lines="5" data-code-annotation="2"><em>Rekursionsschritt</em>: Wenn <code>n</code> größer als 1 ist, dann wird das Ergebnis durch zwei rekursive Aufrufe der Funktion berechnet. Das Ergebnis ist dann die <span class="math inline">\(n\)</span>-te Fibonacci-Zahl.</span>
</dd>
</dl>
</div>
</div>
<p>Diese Rekursion ist also nicht linear, da hier zwei rekursive Aufrufe nacheinander vorkommen. Man nennt diese Form auch <em>kaskadenförmige</em> oder <em>verschachtelte</em> Rekursion, da die Aufrufe hier einen verschachtelten Baum bilden, der sich bei jedem Aufruf zweifach verzweigt.</p>
<p>Wir können auch das wieder veranschaulichen, indem wir Programmausgaben einfügen:</p>
<div id="bb9d1af1" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="annotated-cell-9"><pre class="sourceCode python code-annotation-code code-with-copy"><code class="sourceCode python"><span id="annotated-cell-9-1"><a href="#annotated-cell-9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib_print(n):</span>
<span id="annotated-cell-9-2"><a href="#annotated-cell-9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="annotated-cell-9-3"><a href="#annotated-cell-9-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Rekursionsanfang mit n = </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="annotated-cell-9-4"><a href="#annotated-cell-9-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n</span>
<span id="annotated-cell-9-5"><a href="#annotated-cell-9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="annotated-cell-9-6"><a href="#annotated-cell-9-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Rekursionsschritt mit n = </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="annotated-cell-9-7"><a href="#annotated-cell-9-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> fib_print(n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib_print(n<span class="op">-</span><span class="dv">2</span>)</span>
<span id="annotated-cell-9-8"><a href="#annotated-cell-9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-9-9"><a href="#annotated-cell-9-9" aria-hidden="true" tabindex="-1"></a>fib_print(<span class="dv">4</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Rekursionsschritt mit n = 4
Rekursionsschritt mit n = 3
Rekursionsschritt mit n = 2
Rekursionsanfang mit n = 1
Rekursionsanfang mit n = 0
Rekursionsanfang mit n = 1
Rekursionsschritt mit n = 2
Rekursionsanfang mit n = 1
Rekursionsanfang mit n = 0</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>3</code></pre>
</div>
</div>
<p>Es ist nicht notwendig, diesen Ablaufbaum im Detail zu verstehen, das kann bei einer verschachtelten Rekursion recht schwierig sein. Wir wollen aber wissen, wie schnell der Baum wächst; ich habe dazu <code>fib_print</code> mit den Argumenten 3, 4 und 5 aufgerufen und jeweils die Ausgabezeilen gezählt:</p>
<ul>
<li><span class="math inline">\(fib(3)=5\)</span></li>
<li><span class="math inline">\(fib(4)=9\)</span></li>
<li><span class="math inline">\(fib(5)=15\)</span></li>
</ul>
<p>Mit ein wenig Intuition (oder ausprobieren) finden wir heraus, dass die Wachstumsrate ungefähr gleich <span class="math inline">\(2^{n-1}\)</span> ist, d.h. der Aufwand steigt exponentiell in Abhängigkeit vom Eingabewert <span class="math inline">\(n\)</span>. Schon bei einem Eingabewert größer als 30 müssen wir mit mehr als einer Milliarde Aufrufen rechnen. Wir können die Bearbeitungszeit einer Anweisung in Python mit dem <em>magic command</em> <code>%time</code> messen:</p>
<div id="f523309c" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time fib_rek(<span class="dv">35</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 850 ms, sys: 133 μs, total: 851 ms
Wall time: 850 ms</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>9227465</code></pre>
</div>
</div>
<p>Die Bearbeitungszeit beträgt knapp 900 Millisekunden (<span class="math inline">\(1ms = 10^{-3}s\)</span>), also fast eine Sekunde. Das ist für größere Eingabewerte nicht mehr praktikabel.</p>
<p>Eine Möglichkeit zur Lösung des Problems ist die Anwendung einer Technik, die als <em>memoization</em> bezeichnet wird. Dabei werden Teilergebnisse, die bereits berechnet wurden, in einem Zwischenspeicher (engl. <em>cache</em>) gespeichert, und aus diesem cache abgerufen, ohne eine erneute Berechnung durchzuführen.</p>
<div id="863a3e9c" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="annotated-cell-11"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><a class="code-annotation-anchor" data-target-cell="annotated-cell-11" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-11-1" class="code-annotation-target"><a href="#annotated-cell-11-1" aria-hidden="true" tabindex="-1"></a>cache <span class="op">=</span> {<span class="dv">0</span>: <span class="dv">0</span>, <span class="dv">1</span>: <span class="dv">1</span>}</span>
<span id="annotated-cell-11-2"><a href="#annotated-cell-11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-11-3"><a href="#annotated-cell-11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib_mem(n):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-11" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-11-4" class="code-annotation-target"><a href="#annotated-cell-11-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="kw">not</span> <span class="kw">in</span> cache:</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-11" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-11-5" class="code-annotation-target"><a href="#annotated-cell-11-5" aria-hidden="true" tabindex="-1"></a>        cache[n] <span class="op">=</span> fib_mem(n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib_mem(n<span class="op">-</span><span class="dv">2</span>)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-11" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-11-6" class="code-annotation-target"><a href="#annotated-cell-11-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cache[n]</span>
<span id="annotated-cell-11-7"><a href="#annotated-cell-11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-11-8"><a href="#annotated-cell-11-8" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> fib_mem(<span class="dv">10</span>) <span class="op">==</span> fib_rek(<span class="dv">10</span>)</span>
<span id="annotated-cell-11-9"><a href="#annotated-cell-11-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(cache)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-11" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-11" data-code-lines="1" data-code-annotation="1">Definition des Zwischenspeichers als <code>dict</code> mit den Werten aus dem Rekursionsanfang.</span>
</dd>
<dt data-target-cell="annotated-cell-11" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-11" data-code-lines="4" data-code-annotation="2">Test, ob das Ergebnis für <code>n</code> bereits vorliegt.</span>
</dd>
<dt data-target-cell="annotated-cell-11" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-11" data-code-lines="5" data-code-annotation="3">Falls nicht, berechnen wir das Ergebnisses für <code>n</code> mittels Rekursion und fügen es zum Zwischenspeicher hinzu.</span>
</dd>
<dt data-target-cell="annotated-cell-11" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-11" data-code-lines="6" data-code-annotation="4">In jedem Fall geben wir das Ergebnis für <code>n</code> aus dem Zwischenspeicher aus, da der cache den Wert für <code>n</code> jetzt enthalten muss.</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>{0: 0, 1: 1, 2: 1, 3: 2, 4: 3, 5: 5, 6: 8, 7: 13, 8: 21, 9: 34, 10: 55}</code></pre>
</div>
</div>
<p>Nach der Ausführung der Funktion enthält der cache alle Fibonacci-Zahlen bis einschließlich <span class="math inline">\(n\)</span>.</p>
<p>Wir messen die Bearbeitungszeit der neuen Version ebenfalls mit dem Eingabewert 35:</p>
<div id="26fa9f7b" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time fib_mem(<span class="dv">35</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 10 μs, sys: 0 ns, total: 10 μs
Wall time: 12.2 μs</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="12">
<pre><code>9227465</code></pre>
</div>
</div>
<p>Die Bearbeitungszeit beträgt jetzt rund 11 Mikrosekunden (<span class="math inline">\(1\mu s=10^{-6}s\)</span>). Die neue Version ist damit um den Faktor <span class="math inline">\(10^5\)</span> schneller als die Version ohne <em>memoization</em>. Es lohnt sich also auf jeden Fall, Algorithmen mit einer exponentiellen Laufzeit zu optimieren.</p>
<p>Die Fibonacci-Folge kann aber auch mit einer iterativen Schleife berechnet werden; hierfür benötigen wir zwei Variable, eine für die letzte und die andere für die vorletzte Zahl der bisherigen Folge:</p>
<div id="293aa30d" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="annotated-cell-13"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-13-1"><a href="#annotated-cell-13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib_iter(n):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-13" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-13-2" class="code-annotation-target"><a href="#annotated-cell-13-2" aria-hidden="true" tabindex="-1"></a>    a, b <span class="op">=</span> <span class="dv">0</span>, <span class="dv">1</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-13" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-13-3" class="code-annotation-target"><a href="#annotated-cell-13-3" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> <span class="dv">0</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-13" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-13-4" class="code-annotation-target"><a href="#annotated-cell-13-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> c <span class="op">!=</span> n:</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-13" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-13-5" class="code-annotation-target"><a href="#annotated-cell-13-5" aria-hidden="true" tabindex="-1"></a>        a, b <span class="op">=</span> b, a <span class="op">+</span> b</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-13" data-target-annotation="5" onclick="event.preventDefault();">5</a><span id="annotated-cell-13-6" class="code-annotation-target"><a href="#annotated-cell-13-6" aria-hidden="true" tabindex="-1"></a>        c <span class="op">+=</span> <span class="dv">1</span></span>
<span id="annotated-cell-13-7"><a href="#annotated-cell-13-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a</span>
<span id="annotated-cell-13-8"><a href="#annotated-cell-13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-13-9"><a href="#annotated-cell-13-9" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> fib_iter(<span class="dv">10</span>) <span class="op">==</span> fib_mem(<span class="dv">10</span>)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-13" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-13" data-code-lines="2" data-code-annotation="1">Die ersten beiden Zahlen der Folge aus dem Rekursionsanfang.</span>
</dd>
<dt data-target-cell="annotated-cell-13" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-13" data-code-lines="3" data-code-annotation="2">Initialisierung eines Zählers.</span>
</dd>
<dt data-target-cell="annotated-cell-13" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-13" data-code-lines="4" data-code-annotation="3">Iterative Schleife: wiederhole die Anweisungen, solange <code>c != n</code>. Wir verwenden hier einen Zähler als Schleifenvariable, um die Berechnung abzubrechen, sobald die gesuchte Fibonacci-Zahl berechnet wurde.</span>
</dd>
<dt data-target-cell="annotated-cell-13" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-13" data-code-lines="5" data-code-annotation="4">Berechnung der nächsten Zahl der Folge als Summe der beiden vorangehenden Zahlen.</span>
</dd>
<dt data-target-cell="annotated-cell-13" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-13" data-code-lines="6" data-code-annotation="5">Hochzählen des Zählers.</span>
</dd>
</dl>
</div>
</div>
<p>Wir messen erneut die Laufzeit der neuen Version:</p>
<div id="3fcc98dc" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time fib_iter(<span class="dv">35</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 5 μs, sys: 0 ns, total: 5 μs
Wall time: 6.91 μs</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="14">
<pre><code>9227465</code></pre>
</div>
</div>
<p>Die Laufzeit beträgt hier nur noch rund 6 <span class="math inline">\(\mu s\)</span>; die iterative Version ist also ungefähr doppelt so schnell wie die optimierte rekursive Version.</p>
<p>In der Regel können verschachtelte Rekursionen aber nicht ohne Weiteres in iterative Schleifen überführt werden. Bei der Fibonacci-Folge klappt das nur deshalb, weil es sich hier um eine sogenannte <em>primitive</em> Rekursion handelt, bei der das Ergebnis jeden Teilschrittes über eine einfache mathematische Operation (wie z.B. der Addition) berechnet werden kann. Wir werden im nächsten Kapitel ein Beispiel einer nicht-primitiven Rekursion kennenlernen, die sich nicht direkt in eine iterative Schleife überführen läßt.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Rekursion vs.&nbsp;Iteration
</div>
</div>
<div class="callout-body-container callout-body">
<p>Eine <strong>Rekursion</strong> kommt i.d.R. mit weniger Quellcode aus und ist (für erfahrene Programmierer) übersichtlicher – es müssen hier keine Hilfsvariablen und Schleifenzähler definiert werden.<br>
In der Abarbeitung sind <strong>iterative Verfahren</strong> meist effizienter und benötigen weniger Speicherplatz.</p>
</div>
</div>
</section>
</section>
<section id="die-türme-von-hanoi" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="die-türme-von-hanoi"><span class="header-section-number">2</span> Die Türme von Hanoi</h2>
<p>Die Türme von Hanoi sind ein mathematisches Knobel- und Geduldsspiel, das als Standardbeispiel für rekursive Programmierung dient. Das Spiel wird von einer Person gespielt. Es besteht aus drei gleich großen Stäben, auf die mehrere gelochte Scheiben gesteckt werden, alle verschieden groß.</p>
<p>Zu Beginn liegen alle Scheiben auf dem linken Stab, der Größe nach geordnet, mit der größten Scheibe unten und der kleinsten oben.</p>
<div id="fig-hanoi-aufbau" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-hanoi-aufbau-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://upload.wikimedia.org/wikipedia/commons/0/07/Tower_of_Hanoi.jpeg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-hanoi-aufbau-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;1: Türme von Hanoi - Spielaufbau
</figcaption>
</figure>
</div>
<p>Ziel des Spiels ist es, den kompletten Scheiben-Stapel vom linken Stab auf den rechten Stab zu versetzen, wobei der mittlere Stab als temporäre Ablage dient. Hierbei gelten zwei Regeln:</p>
<ol type="1">
<li>Es darf in jedem Zug nur eine Scheibe bewegt werden.</li>
<li>Eine Scheibe muss immer auf einer größeren Scheibe abgelegt werden.</li>
</ol>
<p>Folglich sind zu jedem Zeitpunkt des Spieles die Scheiben auf jedem Stapel der Größe nach geordnet.</p>
<section id="lösungsansatz" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="lösungsansatz"><span class="header-section-number">2.1</span> Lösungsansatz</h3>
<p>Es ist nicht sofort offensichtlich, wie das Spiel gelöst werden kann. In der Praxis wird man durch Ausprobieren versuchen, ein Muster für geeignete Zugfolgen zu erkennen, und dieses Muster dann wiederholt anwenden, bis alle Scheiben auf dem Zielstab abgelegt sind.</p>
<p>In der Programmierung führt Ausprobieren in der Regel nicht zum Erfolg. Stattdessen wollen wir uns <em>vor</em> der Implementierung überlegen, wie wir das Problem am besten lösen können. Wir versuchen also, das Muster anhand theoretischer Überlegungen zu erkennen, und es dann in Form eines Algorithmus im Programm-Code abzubilden.</p>
<p>Als erstes benennen wir dazu die bekannten Fakten: Den linken Stab (Start) nennen wir <code>A</code>, den mittleren (temporären) Stab <code>B</code> und den rechten Zielstab <code>C</code>.<br>
Die Anzahl der Scheiben, mit denen gespielt wird, nennen wir <code>n</code>, wobei die kleinste (oberste) Scheibe den Wert 1 erhält, und der Wert jeder weiteren darunter liegende Scheibe jeweils um eins vergrößert wird; die unterste (größte) Scheibe hat dann den Wert <code>n</code>.</p>
<p>Typischerweise wird das Spiel mit acht Scheiben gespielt. Um uns die Analyse zu erleichtern, betrachten wir zunächst ein einfacheres Problem mit nur drei Schreiben. Um dieses Problem zu lösen, müssen wir</p>
<ol type="1">
<li>die beiden kleinsten Scheiben (mit den Werten <code>1</code> und <code>2</code>) auf den temporären Stapel <code>B</code> verschieben</li>
<li>die größte Scheibe mit dem Wert <code>3</code> auf den Zielstapel <code>C</code> verschieben</li>
<li>die beiden kleinsten Scheiben vom temporären Stapel <code>B</code> auf den Zielstapel <code>C</code> verschieben.</li>
</ol>
<div id="fig-hanoi-analyze" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-hanoi-analyze-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-video"><video id="video_shortcode_videojs_video1" class="video-js vjs-default-skin vjs-fluid" controls="" preload="auto" data-setup="{}" title=""><source src="media/videos/hanoi_analyze/480p15/hanoi_analyze.mp4"></video></div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-hanoi-analyze-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;2: Hanoi - Lösungsansatz in drei Schritten
</figcaption>
</figure>
</div>
<p>Das Muster ist nachvollziehbar, aber es scheint, als gäbe es ein Problem:<br>
in den Schritten 1 und 3 verschieben wir mehr als eine Scheibe, was nach den Regeln nicht erlaubt ist.</p>
<p>Wir könnten versuchen, das Problem iterativ zu lösen, indem wir explizite Zugfolgen für 2, 3, 4, oder mehr Scheiben berechnen, die verschoben werden sollen. Bei näherer Betrachtung erkennen wir aber, dass das gar nicht notwendig ist:</p>
<ul>
<li>Schritt 2 mit dem Verschieben einer einzelnen Scheibe ist trivial (das entspricht einem Rekursionsanfang mit <code>n==1</code>)</li>
<li>die Schritte 1 und 3 verschieben jeweils <code>n-1</code> Scheiben (das entspricht einem Rekursionsschritt mit neuem Argument <code>n-1</code>).</li>
</ul>
<p>Es handelt sich also offensichtlich um ein rekursives Problem, und wir können den Algorithmus beschreiben, indem wir unser Muster für ein beliebiges <code>n</code> verallgemeinern:</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Rekursiver Algorithmus
</div>
</div>
<div class="callout-body-container callout-body">
<ol type="1">
<li>Verschiebe die <code>n-1</code> kleinsten Scheiben rekursiv auf den temporären Stapel</li>
<li>Verschiebe die verbleibende Scheibe auf den Zielstapel</li>
<li>Verschiebe die <code>n-1</code> kleinsten Scheiben rekursiv vom temporären auf den Zielstapel.</li>
</ol>
</div>
</div>
<p>Wenn wir den Algorithmus als verschachtelte Rekursion implementieren, d.h. alle drei Schritte als rekursive Aufrufe direkt nacheinander ausführen, dann wird zunächst Schritt 1 <code>n-1</code> mal aufgerufen, bevor in Schritt 2 tatsächlich nur eine Scheibe bewegt wird. Wir bewegen also nie mehr als eine Scheibe mit einem einzelnen Aufruf, wie gefordert.</p>
</section>
<section id="implementierung" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="implementierung"><span class="header-section-number">2.2</span> Implementierung</h3>
<p>Für unsere erste Implementierung verwenden wir zur Repräsentation der Scheibenstapel eine Datenstrukur <a href="https://de.wikipedia.org/wiki/Stapelspeicher">Stapel</a>. Die Elemente eines Stapels werden wie bei einem Stapel Spielkarten übereinander gelegt und in umgekehrter Reihenfolge vom Stapel genommen. Dies wird auch Last-In-First-Out-Prinzip <a href="https://de.wikipedia.org/wiki/Last_In_%E2%80%93_First_Out">LIFO</a> genannt.</p>
<p>Ein Stapel verfügt typischerweise über zwei Methoden <code>push</code> und <code>pop</code>, mit denen Elemente auf dem Stapel abgelegt bzw. wieder ausgelagert werden. Da Python nicht über einen eingebauten Datentyp <em>stack</em> verfügt, bauen wir uns einen eigenen mit Hilfe einer Liste:</p>
<div id="3a8db0f9" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="annotated-cell-15"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-15-1"><a href="#annotated-cell-15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Stapel():</span>
<span id="annotated-cell-15-2"><a href="#annotated-cell-15-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-15" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-15-3" class="code-annotation-target"><a href="#annotated-cell-15-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.speicher <span class="op">=</span> []</span>
<span id="annotated-cell-15-4"><a href="#annotated-cell-15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-15-5"><a href="#annotated-cell-15-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> push(<span class="va">self</span>, elem):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-15" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-15-6" class="code-annotation-target"><a href="#annotated-cell-15-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.speicher.append(elem)</span>
<span id="annotated-cell-15-7"><a href="#annotated-cell-15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-15-8"><a href="#annotated-cell-15-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> pop(<span class="va">self</span>):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-15" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-15-9" class="code-annotation-target"><a href="#annotated-cell-15-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.speicher.pop()</span>
<span id="annotated-cell-15-10"><a href="#annotated-cell-15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-15-11"><a href="#annotated-cell-15-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-15" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-15-12" class="code-annotation-target"><a href="#annotated-cell-15-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">repr</span>(<span class="va">self</span>.speicher)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-15" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-15" data-code-lines="3" data-code-annotation="1">Initialisierung einer leeren Liste als Datenspeicher.</span>
</dd>
<dt data-target-cell="annotated-cell-15" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-15" data-code-lines="6" data-code-annotation="2">Implementierung der <code>push</code> Methode: das neue Element wird am Ende der Liste angehängt.</span>
</dd>
<dt data-target-cell="annotated-cell-15" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-15" data-code-lines="9" data-code-annotation="3">Implementierung der <code>pop</code> Methode: das letzte Element der Liste wird aus dem Datenspeicher entfernt und zurückgegeben.</span>
</dd>
<dt data-target-cell="annotated-cell-15" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-15" data-code-lines="12" data-code-annotation="4">Ausgabe der Elemente im Datenspeicher.</span>
</dd>
</dl>
</div>
</div>
<div id="f5ef298c" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> Stapel()</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> Stapel()</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> Stapel()</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    A.push(i)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>A</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<pre><code>[8, 7, 6, 5, 4, 3, 2, 1]</code></pre>
</div>
</div>
<p>Ich habe hier den Startstapel mit den Werten 1 bis <code>n</code> befüllt, so dass, unserer Konvention folgend, das oberste Element (der letzte Eintrag in der Liste) den Wert 1 hat und das unterste Element (der erste Eintrag in der Liste) den Wert <code>n</code> hat.</p>
<p>Diese Stapel können wir nun in einer rekursiven Funktion <code>hanoi</code> verwenden, um den rekursiven Algorithmus abzubilden:</p>
<div id="26d65614" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="annotated-cell-17"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><a class="code-annotation-anchor" data-target-cell="annotated-cell-17" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-17-1" class="code-annotation-target"><a href="#annotated-cell-17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hanoi(start, ziel, temp, n):</span>
<span id="annotated-cell-17-2"><a href="#annotated-cell-17-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-17" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-17-3" class="code-annotation-target"><a href="#annotated-cell-17-3" aria-hidden="true" tabindex="-1"></a>        ziel.push(start.pop())</span>
<span id="annotated-cell-17-4"><a href="#annotated-cell-17-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-17" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-17-5" class="code-annotation-target"><a href="#annotated-cell-17-5" aria-hidden="true" tabindex="-1"></a>        hanoi(start, temp, ziel, n<span class="op">-</span><span class="dv">1</span>)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-17" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-17-6" class="code-annotation-target"><a href="#annotated-cell-17-6" aria-hidden="true" tabindex="-1"></a>        hanoi(start, ziel, temp, <span class="dv">1</span>)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-17" data-target-annotation="5" onclick="event.preventDefault();">5</a><span id="annotated-cell-17-7" class="code-annotation-target"><a href="#annotated-cell-17-7" aria-hidden="true" tabindex="-1"></a>        hanoi(temp, ziel, start, n<span class="op">-</span><span class="dv">1</span>)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-17" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-17" data-code-lines="1" data-code-annotation="1">Signatur mit vier Parametern: <code>start</code>, <code>ziel</code> und <code>temp</code>, die die jeweiligen Scheibenstapel repräsentieren; <code>n</code> für die Gesamtanzahl der Scheiben.</span>
</dd>
<dt data-target-cell="annotated-cell-17" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-17" data-code-lines="3" data-code-annotation="2">Rekursionsanfang: wenn <code>n</code> gleich 1 ist, also die unterste Scheibe im Stapel erreicht ist, dann wird diese Scheibe vom Startstapel entfernt und auf dem Zielstapel abgelegt.</span>
</dd>
<dt data-target-cell="annotated-cell-17" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-17" data-code-lines="5" data-code-annotation="3">Rekursionsschritt 1: verschieben der obersten <code>n-1</code> Scheiben von <code>start</code> nach <code>temp</code>. Beachte die Reihenfolge der Argumente: das erste Argument entpricht gemäß der Funktionssignatur dem Startstapel, das zweite dem Zielstapel und das dritte dem temporären Stapel.</span>
</dd>
<dt data-target-cell="annotated-cell-17" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-17" data-code-lines="6" data-code-annotation="4">Rekursionsschritt 2: verschieben der untersten Scheibe von <code>start</code> nach <code>ziel</code>.</span>
</dd>
<dt data-target-cell="annotated-cell-17" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-17" data-code-lines="7" data-code-annotation="5">Rekursionsschritt 3: verschieben der <code>n-1</code> Scheiben von <code>temp</code> nach <code>ziel</code>.</span>
</dd>
</dl>
</div>
</div>
<p>Mit dieser Implementierung wird offensichtlich, dass nur im Rekursionsanfang (<code>n==1</code>) tatsächlich eine Scheibe verschoben wird. Die Rekursionsschritte dienen lediglich dazu, die korrekte Reihenfolge der Züge zu berechnen.</p>
<p>Wir rufen <code>hanoi</code> mit den Scheibenstapeln <code>A</code>, <code>C</code> und <code>B</code> auf (beachte die Reihenfolge gem. Funktionssignatur) und prüfen das Ergebnis:</p>
<div id="b4764852" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>hanoi(A, C, B, n)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(A)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(B)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(C)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[]
[]
[8, 7, 6, 5, 4, 3, 2, 1]</code></pre>
</div>
</div>
<p>Offensichtlich wurden alle Scheiben in der richtigen Reihenfolge von <code>A</code> nach <code>C</code> verschoben. Leider gibt diese Implementierung keinen Aufschluss darüber, in welcher Reihenfolge die Scheiben <em>tatsächlich</em> verschoben wurden. Wenn wir das Spiel manuell lösen wollen, haben wir also immer noch keinen brauchbaren Lösungsweg.</p>
<p>Um den Lösungsweg zu erhalten, nehmen wir eine kleine Korrektur vor: anstatt konkrete Scheiben zu verschieben, zeichnen wir lediglich jeden Zug auf, der in Schritt 2 unseres Algorithmus ausgeführt wird.</p>
<div id="e085a241" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="annotated-cell-19"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-19-1"><a href="#annotated-cell-19-1" aria-hidden="true" tabindex="-1"></a>züge <span class="op">=</span> Stapel()</span>
<span id="annotated-cell-19-2"><a href="#annotated-cell-19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-19-3"><a href="#annotated-cell-19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hanoi(start, ziel, temp, n):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-19" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-19-4" class="code-annotation-target"><a href="#annotated-cell-19-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-19" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-19-5" class="code-annotation-target"><a href="#annotated-cell-19-5" aria-hidden="true" tabindex="-1"></a>    hanoi(start, temp, ziel, n<span class="op">-</span><span class="dv">1</span>)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-19" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-19-6" class="code-annotation-target"><a href="#annotated-cell-19-6" aria-hidden="true" tabindex="-1"></a>    züge.push((start, ziel))</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-19" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-19-7" class="code-annotation-target"><a href="#annotated-cell-19-7" aria-hidden="true" tabindex="-1"></a>    hanoi(temp, ziel, start, n<span class="op">-</span><span class="dv">1</span>)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-19" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-19" data-code-lines="4" data-code-annotation="1">Rekursionsanfang: wenn alle Scheiben verschoben wurden (<code>n==0</code>), dann gibt es nichts mehr zu tun, und wir beenden das Programm. Damit sparen wir uns auch die <code>if-else</code> Verzweigung der bisherigen Version.</span>
</dd>
<dt data-target-cell="annotated-cell-19" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-19" data-code-lines="5" data-code-annotation="2">Rekursionsschritt 1: verschiebe die obersten <code>n-1</code> Scheiben von <code>start</code> nach <code>temp</code>.</span>
</dd>
<dt data-target-cell="annotated-cell-19" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-19" data-code-lines="6" data-code-annotation="3">Schritt 2: speichere den Zug der aktuellen Scheibe von <code>start</code> nach <code>ziel</code>. Dazu muss sich die Funktion gar nicht rekursiv aufrufen, sondern die Speicherung erfolgt direkt hier.</span>
</dd>
<dt data-target-cell="annotated-cell-19" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-19" data-code-lines="7" data-code-annotation="4">Rekursionsschritt 3: verschiebe die <code>n-1</code> Scheiben von <code>temp</code> nach <code>ziel</code>.</span>
</dd>
</dl>
</div>
</div>
<p>Wir rufen die neue Version jetzt nicht mit den konkreten Stapeln auf, sondern mit den Buchstaben ‘A’, ‘B’ und ‘C’, die diese Stapel repräsentieren.</p>
<div id="2cbd6857" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>hanoi(<span class="st">'A'</span>, <span class="st">'C'</span>, <span class="st">'B'</span>, <span class="dv">3</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>züge</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>[('A', 'C'), ('A', 'B'), ('C', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('A', 'C')]</code></pre>
</div>
</div>
<p>Die Züge sind wie folgt zu interpretieren: jedes Paar in runden Klammern repräsentiert einen Zug, wobei jeweils die oberste Scheibe des erstgenannten Stapels auf den zweiten Stapel verschoben wird. Du kannst das z.B. mit einem Stapel verschiedengroßer Münzen ausprobieren und wirst feststellen, dass das Problem damit gelöst wird, und dass dabei nie eine größere auf einer kleineren Münze plaziert wird.</p>
<p>Ich habe die zweite Versionen der Funktion <code>hanoi</code> benutzt, um nachfolgende Animation für vier Scheiben zu erstellen. Wenn du wissen willst wie das geht, dann sieh dir den Quellcode unter <code>arithmetik/hanoi_solve.py</code> an.</p>
<div id="fig-hanoi-solve" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-hanoi-solve-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-video"><video id="video_shortcode_videojs_video2" class="video-js vjs-default-skin vjs-fluid" controls="" preload="auto" data-setup="{}" title=""><source src="media/videos/hanoi_solve/480p15/hanoi_solve.mp4"></video></div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-hanoi-solve-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;3: Hanoi - Lösung für vier Scheiben
</figcaption>
</figure>
</div>
</section>
<section id="laufzeitanalyse" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="laufzeitanalyse"><span class="header-section-number">2.3</span> Laufzeitanalyse</h3>
<p>Das Problem ist gelöst. Bleibt nur noch, die Anzahl der dazu notwendigen Schritte zu berechnen, um eine Aussage über die Effizienz des Algorithmus zu erhalten. Wir rufen dafür die Funktion <code>hanoi</code> mit verschiedener Scheibenanzahl auf und zählen die Züge im jeweiligen Ergebnis:</p>
<div id="c88bbcb3" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> size(<span class="va">self</span>):</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">len</span>(<span class="va">self</span>.speicher)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>Stapel.size <span class="op">=</span> size</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, <span class="dv">9</span>):</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    züge <span class="op">=</span> Stapel()</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    hanoi(<span class="st">'A'</span>, <span class="st">'C'</span>, <span class="st">'B'</span>, n)</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss"> Scheiben: </span><span class="sc">{</span>z<span class="sc">ü</span>ge<span class="sc">.</span>size()<span class="sc">}</span><span class="ss"> Züge"</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>3 Scheiben: 7 Züge
4 Scheiben: 15 Züge
5 Scheiben: 31 Züge
6 Scheiben: 63 Züge
7 Scheiben: 127 Züge
8 Scheiben: 255 Züge</code></pre>
</div>
</div>
<p>Offensichtlich ist die Anzahl der Züge <span class="math inline">\(H_n\)</span> abhängig von der Anzahl der Scheiben <span class="math inline">\(n\)</span>, und mit etwas Intuition erkennen wir: <span id="eq-zuege"><span class="math display">\[
H_n=2^n-1, \quad \mathrm{mit} \ n \geq 0.
\tag{4}\]</span></span> Wir haben es also wieder mit einem exponentiellen Wachstum zu tun.</p>
<p>Wir wollen uns aber als angehende Mathematiker nicht auf unsere Intuition verlassen. Außerdem wollen wir prüfen, ob es, ähnlich wie bei der Fibonacci-Folge, eine effizientere Lösung gibt, indem wir z.B. die verschachtelte Rekursion in eine lineare Rekursion überführen.</p>
<p>Dazu analysieren wir nochmal unseren Algorithmus:</p>
<ul>
<li>zuerst verschieben wir die <code>n-1</code> kleinsten Scheiben, was <span class="math inline">\(H_{n-1}\)</span> Züge erfordert</li>
<li>dann verschieben wir die größte Scheibe, was einen Zug erfordert</li>
<li>schließlich verschieben wir erneut <code>n-1</code> Scheiben, was weitere <span class="math inline">\(H_{n-1}\)</span> Züge erfordert.</li>
</ul>
<p>Wir können also <span class="math inline">\(n\)</span> Scheiben in höchstens <span class="math inline">\(2H_{n-1}+1\)</span> Zügen verschieben: <span class="math display">\[
H_n \leq 2H_{n-1} + 1, \quad \mathrm{mit} \ n &gt; 0.
\]</span></p>
<p>Die obige Formel verwendet <span class="math inline">\(\leq\)</span> anstatt <span class="math inline">\(=\)</span>, da wir bisher nur gezeigt haben, dass <span class="math inline">\(2H_{n-1}+1\)</span> Züge auf jeden Fall ausreichen. Vielleicht gibt es aber einen schnelleren Weg zur Lösung.</p>
<p>Können wir das tatsächlich besser machen?<br>
Irgendwann müssen wir die größte Scheibe verschieben. Zu diesem Zeitpunkt müssen sich die <code>n-1</code> kleinsten Scheiben auf einem einzelnen Stapel befinden, und es hat mindestens <span class="math inline">\(H_{n-1}\)</span> Züge gebraucht, um sie dorthin zu bewegen.<br>
Es spielt keine Rolle, wie viele Züge wir für das Verschieben der größten Scheibe an die richtige Position brauchen. Aber nach dem letzten Zug der größten Scheibe müssen wir die <code>n-1</code> kleinsten Scheiben (die dann wieder auf einem einzelnen Stapel liegen müssen), zurück auf die größte Scheibe verschieben; das erfordert wieder mindestens <span class="math inline">\(H_{n-1}\)</span> Züge. Daraus folgt <span class="math display">\[
H_n \geq 2H_{n-1} + 1, \quad \mathrm{mit} \ n &gt; 0.
\]</span></p>
<p>Diese zwei Ungleichungen führen zu folgenden Gleichungen</p>
<p><span id="eq-recurrence"><span class="math display">\[
\begin{align}
H_0 &amp;= 0\\
H_n &amp;= 2H_{n-1} + 1, \quad \mathrm{mit} \ n &gt; 0.
\end{align}
\tag{5}\]</span></span></p>
<p>Das entspricht offensichtlich einer rekursiven Definition für die Anzahl der notwendigen Züge. Wir wollen diese Anzahl aber nicht rekursiv berechnen, sondern wir suchen eine <em>geschlossene Formel</em>, mit der wir die Anzahl der Züge in einem Schritt berechnen können.</p>
<p>Eine Möglichkeit, eine rekursive Formel in eine geschlossene Formel zu überführen, ist die sogenannte <em>mathematische Induktion</em>. Wir werden uns im Abschnitt <a href="???">Beweise</a> dieses Tutorials ausführlich mit mathematischer Induktion beschäftigen. An dieser Stelle geben wir aber schon mal ein Beispiel, um zu zeigen, wie eng das Prinzip der Induktion mit dem der Rekursion verwandt ist.</p>
<p>Der Grundgedanke besteht darin, unsere Behauptung aus <a href="#eq-zuege" class="quarto-xref">Gleichung&nbsp;4</a> (die <em>Induktionsbehauptung</em>) in die Gleichungen der rekursiven Definition (<a href="#eq-recurrence" class="quarto-xref">Gleichung&nbsp;5</a>) einzusetzen und zu prüfen, ob die Gleichungen dann immer noch für jedes <span class="math inline">\(n\)</span> gelten.</p>
<p>Der erste Fall für <span class="math inline">\(n=0\)</span> (<em>Induktionsanfang</em>) ist trivial, da <span class="math inline">\(H_0 = 2^0-1=1-1=0\)</span>.</p>
<p>Für den zweiten Fall <span class="math inline">\(n\neq0\)</span> (<em>Induktionsschritt</em>) kann die Behauptung für jedes <span class="math inline">\(n\)</span> bewiesen werden, indem wir zeigen, dass sie auch für <span class="math inline">\(n-1\)</span> gilt:</p>
<p><span class="math display">\[
H_n=2H_{n-1}+1=2(2^{n-1}-1)+1=2^n-1.
\]</span></p>
<p>Wir haben damit mathematisch bewiesen, dass die Anzahl der Züge <em>immer</em> gleich <span class="math inline">\(2^n-1\)</span> ist. Damit kann es auch keine effizientere Lösung für unser Problem geben: die verschachtelte Rekursion kann nicht in eine lineare Rekursion überführt werden.</p>
</section>
</section>
<section id="übungen" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="übungen"><span class="header-section-number">3</span> Übungen</h2>
<p>Die Übungen zu dieser Lektion findest du im Notebook <code>artithmetik/_rekursion.ipynb</code>.</p>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Kopiert");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Kopiert");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/okrischer\.github\.io\/matheKapierenMitPython\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Quellcode</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb31" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Rekursion"</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>Rekursion ist eine wichtige Problemlösungsstrategie der Mathematik und der Programmierung.</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>Komplexe Sachverhalte können oft mit rekursiv formulierten Regeln sehr elegant erfasst werden.</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>Das Grundprinzip der Rekursion besteht darin, eine komplexe Aufgabe in gleichförmige Teilaufgaben zu zerlegen, die dann einfach gelöst werden können.</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="fu">## Rekursion</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>Als Rekursion wird ein prinzipiell unendlicher Vorgang bezeichnet, der sich selbst als Teil enthält oder mithilfe von sich selbst definierbar ist.\</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>Die bei der Rekursion aufeinander folgenden Teilvorgänge sind nicht unabhängig voneinander, sondern zwischen jedem Schrittpaar besteht eine besondere, die *rekursive Beziehung*.</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>Das klingt erstmal nicht besonders einleuchtend.</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>Ein alltägliches Beispiel kann das Funktionsprinzip der Rekursion vielleicht erhellen:</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a><span class="fu">## Einschrauben ein Glühbirne</span></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>**Frage**: Wie viele Umdrehungen sind nötig, um eine Glühbirne einzuschrauben?\</span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>**Antwort**: Ist sie bereits eingeschraubt? Dann ist die Antwort null.</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>Wenn nicht, dann drehe sie einmal, frage mich erneut, und addiere 1 zu meiner Antwort.</span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a><span class="fu">## Mathematische Beispiele</span></span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a>Mathematische Objekte werden häufig *rekursiv* definiert, d.h. mit Bezug auf sich selbst.</span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a>Solche Objekte können dann mit Hilfe von Rekursion bestimmt werden.</span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a><span class="fu">### Fakultät</span></span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true" tabindex="-1"></a>Als erstes Beispiel für Rekursion wollen wir die Berechnung der *Fakultät* untersuchen.</span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb31-35"><a href="#cb31-35" aria-hidden="true" tabindex="-1"></a><span class="fu">## Fakultät</span></span>
<span id="cb31-36"><a href="#cb31-36" aria-hidden="true" tabindex="-1"></a>Die Funktion Fakultät ($n!$) einer natürlichen Zahl $n \geq 1$ ist definiert als das Produkt der Zahlen 1 bis $n$:</span>
<span id="cb31-37"><a href="#cb31-37" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb31-38"><a href="#cb31-38" aria-hidden="true" tabindex="-1"></a>n! = 1\cdot2\cdot3\cdots n=\prod_{k=1}^n{k}</span>
<span id="cb31-39"><a href="#cb31-39" aria-hidden="true" tabindex="-1"></a>$$ {#eq-fakt}</span>
<span id="cb31-40"><a href="#cb31-40" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb31-41"><a href="#cb31-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-42"><a href="#cb31-42" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb31-43"><a href="#cb31-43" aria-hidden="true" tabindex="-1"></a><span class="fu">## Beispiele</span></span>
<span id="cb31-44"><a href="#cb31-44" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb31-45"><a href="#cb31-45" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb31-46"><a href="#cb31-46" aria-hidden="true" tabindex="-1"></a>1! &amp;= 1 &amp;= &amp; 1 <span class="sc">\\</span></span>
<span id="cb31-47"><a href="#cb31-47" aria-hidden="true" tabindex="-1"></a>2! &amp;= 1\cdot2 &amp;= &amp; 2 <span class="sc">\\</span></span>
<span id="cb31-48"><a href="#cb31-48" aria-hidden="true" tabindex="-1"></a>3! &amp;= 1\cdot2\cdot3 &amp;= &amp; 6 <span class="sc">\\</span></span>
<span id="cb31-49"><a href="#cb31-49" aria-hidden="true" tabindex="-1"></a>4! &amp;= 1\cdot2\cdot3\cdot4 &amp;= &amp; 24 <span class="sc">\\</span></span>
<span id="cb31-50"><a href="#cb31-50" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb31-51"><a href="#cb31-51" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb31-52"><a href="#cb31-52" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb31-53"><a href="#cb31-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-54"><a href="#cb31-54" aria-hidden="true" tabindex="-1"></a>Soll diese Liste fortgesetzt werden, ergibt sich die Rekursivität nahezu von selbst.</span>
<span id="cb31-55"><a href="#cb31-55" aria-hidden="true" tabindex="-1"></a>Für die Berechnung von $5!$ wollen wir nicht von vorn beginnen, sondern wir greifen auf das vorherige Ergebniss zurück, also $5! = 4! \cdot 5=24\cdot5=120$.</span>
<span id="cb31-56"><a href="#cb31-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-57"><a href="#cb31-57" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb31-58"><a href="#cb31-58" aria-hidden="true" tabindex="-1"></a><span class="fu">## Rekursive Definition der Fakultät</span></span>
<span id="cb31-59"><a href="#cb31-59" aria-hidden="true" tabindex="-1"></a>Verallgemeinert lässt sich die Funktion Fakultät somit *rekursiv* definieren:</span>
<span id="cb31-60"><a href="#cb31-60" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb31-61"><a href="#cb31-61" aria-hidden="true" tabindex="-1"></a>n! =</span>
<span id="cb31-62"><a href="#cb31-62" aria-hidden="true" tabindex="-1"></a>\begin{cases}</span>
<span id="cb31-63"><a href="#cb31-63" aria-hidden="true" tabindex="-1"></a>1 &amp;\text{, falls} \ n=1 &amp;\text{(Rekursionsanfang)}<span class="sc">\\</span></span>
<span id="cb31-64"><a href="#cb31-64" aria-hidden="true" tabindex="-1"></a>n \cdot (n-1)! &amp;\text{, sonst} &amp;\text{(Rekursionsschritt)}</span>
<span id="cb31-65"><a href="#cb31-65" aria-hidden="true" tabindex="-1"></a>\end{cases}</span>
<span id="cb31-66"><a href="#cb31-66" aria-hidden="true" tabindex="-1"></a>$$ {#eq-fakt-rek}</span>
<span id="cb31-67"><a href="#cb31-67" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb31-68"><a href="#cb31-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-69"><a href="#cb31-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-70"><a href="#cb31-70" aria-hidden="true" tabindex="-1"></a>Wir können den Wert der Fakultät also mittes Rekursion in Python bestimmen:</span>
<span id="cb31-71"><a href="#cb31-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-74"><a href="#cb31-74" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-75"><a href="#cb31-75" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fakultät(n):                                                    <span class="co"># &lt;1&gt;</span></span>
<span id="cb31-76"><a href="#cb31-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:                                                      <span class="co"># &lt;2&gt;</span></span>
<span id="cb31-77"><a href="#cb31-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb31-78"><a href="#cb31-78" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb31-79"><a href="#cb31-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n <span class="op">*</span> fakultät(n<span class="op">-</span><span class="dv">1</span>)                                    <span class="co"># &lt;3&gt;</span></span>
<span id="cb31-80"><a href="#cb31-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-81"><a href="#cb31-81" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> fakultät(<span class="dv">5</span>) <span class="op">==</span> <span class="dv">120</span></span>
<span id="cb31-82"><a href="#cb31-82" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-83"><a href="#cb31-83" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Signatur der rekursiven Funktion <span class="in">`fakultät`</span>.</span>
<span id="cb31-84"><a href="#cb31-84" aria-hidden="true" tabindex="-1"></a>Das entspricht einer "gewöhnlichen" Funktionsdefinition; eine rekursive Funktion muss in Python nicht besonders gekennzeichnet werden.</span>
<span id="cb31-85"><a href="#cb31-85" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Rekursionsanfang**: Test, ob der Eingabewert dem definierten Rekursionsanfang entspricht.</span>
<span id="cb31-86"><a href="#cb31-86" aria-hidden="true" tabindex="-1"></a>Falls ja, geben wir den Wert 1 zurück.</span>
<span id="cb31-87"><a href="#cb31-87" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Rekursionsschritt**: Wenn der Eingabewert nicht dem Rekursionsanfang entspricht, dann wird das Ergebnis rekursiv berechnet, d.h. die Funktion ruft sich selbst mit neuem Argument auf.</span>
<span id="cb31-88"><a href="#cb31-88" aria-hidden="true" tabindex="-1"></a>Das neue Argument ist in diesem Fall <span class="in">`n-1`</span>.</span>
<span id="cb31-89"><a href="#cb31-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-90"><a href="#cb31-90" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb31-91"><a href="#cb31-91" aria-hidden="true" tabindex="-1"></a><span class="fu">## Rekursive Funktion</span></span>
<span id="cb31-92"><a href="#cb31-92" aria-hidden="true" tabindex="-1"></a>Rekursion wird in der Programmierung über eine *rekursive Funktion* abgebildet, d.h. mit einer Funktion, die sich selbst wiederholt aufruft.\</span>
<span id="cb31-93"><a href="#cb31-93" aria-hidden="true" tabindex="-1"></a>Entsprechend der rekursiven Definition muss auch eine rekursive Funktion dabei immer zwei Fälle berücksichtigen:</span>
<span id="cb31-94"><a href="#cb31-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-95"><a href="#cb31-95" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Rekursionsanfang**: Falls der definierte Wert für den Rekursionsanfang erreicht ist, gibt die Funktion das dafür definierte Ergebnis aus.</span>
<span id="cb31-96"><a href="#cb31-96" aria-hidden="true" tabindex="-1"></a>In diesem Fall darf kein weiterer rekursiver Aufruf erfolgen.</span>
<span id="cb31-97"><a href="#cb31-97" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Rekursionsschritt**: Falls der Eingabewert nicht dem Rekursionsanfang entspricht, wird der nächste Schritt der Berechnung durchgeführt, indem sich die Funktion mit einem neuen Argument selbst wieder aufruft.</span>
<span id="cb31-98"><a href="#cb31-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-99"><a href="#cb31-99" aria-hidden="true" tabindex="-1"></a>**Beachte**: Das neue Argument für den rekursiven Aufruf muss *immer* so gewählt werden, dass es sich dem Wert des Rekursionsanfangs annähert und am Ende auch diesen Wert erreicht.</span>
<span id="cb31-100"><a href="#cb31-100" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb31-101"><a href="#cb31-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-102"><a href="#cb31-102" aria-hidden="true" tabindex="-1"></a>Bei der Fakultät handelt es sich um eine *linear rekursive* Definition, bei der höchstens *ein* rekursiver Aufruf vorkommt.</span>
<span id="cb31-103"><a href="#cb31-103" aria-hidden="true" tabindex="-1"></a>Die Berechnung mittels Python verläuft daher entlang einer Kette von Aufrufen.</span>
<span id="cb31-104"><a href="#cb31-104" aria-hidden="true" tabindex="-1"></a>Bei einer solchen Rekursion enthält der *Aufrufbaum* also keine Verzweigungen.</span>
<span id="cb31-105"><a href="#cb31-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-106"><a href="#cb31-106" aria-hidden="true" tabindex="-1"></a>Um die Abarbeitung des Aufrufbaums verdeutlichen, ergänzen wir die Funktion <span class="in">`fakultät`</span> um zwei Ausgaben:</span>
<span id="cb31-107"><a href="#cb31-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-110"><a href="#cb31-110" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-111"><a href="#cb31-111" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fakultät(n):</span>
<span id="cb31-112"><a href="#cb31-112" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb31-113"><a href="#cb31-113" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">: Rekursionsanfang erreicht"</span>)</span>
<span id="cb31-114"><a href="#cb31-114" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb31-115"><a href="#cb31-115" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb31-116"><a href="#cb31-116" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">: Rekursionsschritt mit neuem Argument </span><span class="sc">{</span>n<span class="op">-</span><span class="dv">1</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-117"><a href="#cb31-117" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n <span class="op">*</span> fakultät(n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb31-118"><a href="#cb31-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-119"><a href="#cb31-119" aria-hidden="true" tabindex="-1"></a>fakultät(<span class="dv">5</span>)</span>
<span id="cb31-120"><a href="#cb31-120" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-121"><a href="#cb31-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-122"><a href="#cb31-122" aria-hidden="true" tabindex="-1"></a>Damit ein rekursives Programm das Ergebnis berechnen kann, müssen alle bisherigen Teilergebnisse zwischengespeichert werden.</span>
<span id="cb31-123"><a href="#cb31-123" aria-hidden="true" tabindex="-1"></a>Das passiert automatisch in einem besonderen Programmspeicher, dem sogenannten *program stack*.</span>
<span id="cb31-124"><a href="#cb31-124" aria-hidden="true" tabindex="-1"></a>Wenn es sich um eine sehr komplexe Berechnung handelt, oder wenn sich das Argument des rekursiven Aufrufs nicht dem Wert des Rekursionsanfangs annähert, dann muss das Programm sehr viele dieser Zwischenergebnisse speichern.</span>
<span id="cb31-125"><a href="#cb31-125" aria-hidden="true" tabindex="-1"></a>Im schlimmsten Fall führt das zu einem Programmabruch, weil der Progammspeicher voll ist; das ist bekannt als *stack overflow*.</span>
<span id="cb31-126"><a href="#cb31-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-127"><a href="#cb31-127" aria-hidden="true" tabindex="-1"></a>Einige funktionale Programmiersprachen (wie z.B. Haskell, F# oder Scala) umgehen dieses Problem, indem sie eine optimierte Abarbeitung ermöglichen, die eine rekursive Schleife intern in eine iterative Schleife umwandelt.</span>
<span id="cb31-128"><a href="#cb31-128" aria-hidden="true" tabindex="-1"></a>Dazu muss aber eine sogenannte *endständige Rekursion* vorliegen, in der der rekursive Aufruf der letzte Aufruf der Funktion ist; außerdem dürfen bei diesem Aufruf keine weiteren Operationen durchgeführt werden.</span>
<span id="cb31-129"><a href="#cb31-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-130"><a href="#cb31-130" aria-hidden="true" tabindex="-1"></a>Unsere Funktion <span class="in">`fakultät`</span> ist also nicht *endständig rekursiv*, da der rekursive Aufruf zusätzlich mit einer Multiplikation verknüpft ist.</span>
<span id="cb31-131"><a href="#cb31-131" aria-hidden="true" tabindex="-1"></a>Das Problem kann aber gelöst werden, indem wir die Multiplikation vorher durchführen und das Produkt mit einem zusätzlichen Parameter dem rekursiven Aufruf hinzufügen.</span>
<span id="cb31-132"><a href="#cb31-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-135"><a href="#cb31-135" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-136"><a href="#cb31-136" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fakultät(n):                                                <span class="co"># &lt;1&gt;</span></span>
<span id="cb31-137"><a href="#cb31-137" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> rek(n, p):                                              <span class="co"># &lt;2&gt;</span></span>
<span id="cb31-138"><a href="#cb31-138" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb31-139"><a href="#cb31-139" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Rekursionsanfang, Ergebnis = </span><span class="sc">{</span>p<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-140"><a href="#cb31-140" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> p                                            <span class="co"># &lt;3&gt;</span></span>
<span id="cb31-141"><a href="#cb31-141" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb31-142"><a href="#cb31-142" aria-hidden="true" tabindex="-1"></a>            p <span class="op">*=</span> n                                              <span class="co"># &lt;4&gt;</span></span>
<span id="cb31-143"><a href="#cb31-143" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">, produkt = </span><span class="sc">{</span>p<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-144"><a href="#cb31-144" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> rek(n<span class="op">-</span><span class="dv">1</span>, p)                                  <span class="co"># &lt;5&gt;</span></span>
<span id="cb31-145"><a href="#cb31-145" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> rek(n, <span class="dv">1</span>)                                            <span class="co"># &lt;6&gt;</span></span>
<span id="cb31-146"><a href="#cb31-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-147"><a href="#cb31-147" aria-hidden="true" tabindex="-1"></a>fakultät(<span class="dv">5</span>)</span>
<span id="cb31-148"><a href="#cb31-148" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-149"><a href="#cb31-149" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Definition einer "gewöhnlichen" Funktion.</span>
<span id="cb31-150"><a href="#cb31-150" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Definition einer inneren, rekursiven Funktion mit einem zweiten Parameter für die Speicherung der Zwischenergebnisse.</span>
<span id="cb31-151"><a href="#cb31-151" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Rekursionsanfang: wir geben hier anstelle der 1 das letzte Teilergebnis zurück.</span>
<span id="cb31-152"><a href="#cb31-152" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Durchführung der Multiplikation und Zuweisung an <span class="in">`p`</span>, dem Teilergebnis.</span>
<span id="cb31-153"><a href="#cb31-153" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>Rekursiver Aufruf mit neuem Argument und bisherigem Teilergebnis.</span>
<span id="cb31-154"><a href="#cb31-154" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>Aufruf der rekursiven Funktion mit dem definierten Wert für den Rekursionsanfang.</span>
<span id="cb31-155"><a href="#cb31-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-156"><a href="#cb31-156" aria-hidden="true" tabindex="-1"></a>In einer imperativen Sprachen wie Python ist diese Optimierung aber ohne Belang: der Compiler bzw. Interpreter kann kann eine endständige Rekursion nicht automatisch in eine iterative Schleife überführen.\</span>
<span id="cb31-157"><a href="#cb31-157" aria-hidden="true" tabindex="-1"></a>Aber wir können eine lineare Rekursion auch explizit als iterative Schleife ausdrücken.</span>
<span id="cb31-158"><a href="#cb31-158" aria-hidden="true" tabindex="-1"></a>Das Vorgehen hierzu entspricht dem der endständigen Rekursion: </span>
<span id="cb31-159"><a href="#cb31-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-162"><a href="#cb31-162" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-163"><a href="#cb31-163" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fakultät(n):</span>
<span id="cb31-164"><a href="#cb31-164" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="dv">1</span>                                           <span class="co"># &lt;1&gt;</span></span>
<span id="cb31-165"><a href="#cb31-165" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> n <span class="op">!=</span> <span class="dv">1</span>:                                   <span class="co"># &lt;2&gt;</span></span>
<span id="cb31-166"><a href="#cb31-166" aria-hidden="true" tabindex="-1"></a>        p <span class="op">*=</span> n                                      <span class="co"># &lt;3&gt;</span></span>
<span id="cb31-167"><a href="#cb31-167" aria-hidden="true" tabindex="-1"></a>        n <span class="op">-=</span> <span class="dv">1</span>                                      <span class="co"># &lt;4&gt;</span></span>
<span id="cb31-168"><a href="#cb31-168" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">, produkt = </span><span class="sc">{</span>p<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-169"><a href="#cb31-169" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Rekursionsanfang, Ergebnis = </span><span class="sc">{</span>p<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-170"><a href="#cb31-170" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> p</span>
<span id="cb31-171"><a href="#cb31-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-172"><a href="#cb31-172" aria-hidden="true" tabindex="-1"></a>fakultät(<span class="dv">5</span>)</span>
<span id="cb31-173"><a href="#cb31-173" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-174"><a href="#cb31-174" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Initialisierung des Ergebnisses mit 1, dem Wert für den Rekursionsanfang.</span>
<span id="cb31-175"><a href="#cb31-175" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Beginn einer iterativen Schleife, deren Bedingung prüft, ob der Rekursionsanfang erreicht wurde.</span>
<span id="cb31-176"><a href="#cb31-176" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Durchführung der Multiplikation und Zuweisung an <span class="in">`p`</span>, dem Teilergebnis.</span>
<span id="cb31-177"><a href="#cb31-177" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Verringerung der Schleifenvariablen um 1.</span>
<span id="cb31-178"><a href="#cb31-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-179"><a href="#cb31-179" aria-hidden="true" tabindex="-1"></a><span class="fu">### Größter gemeinsamer Teiler</span></span>
<span id="cb31-180"><a href="#cb31-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-181"><a href="#cb31-181" aria-hidden="true" tabindex="-1"></a>In Lektion <span class="co">[</span><span class="ot">Teiler und Vielfache</span><span class="co">](2-teiler.qmd#sec-ggT)</span> haben wir den größten gemeinsamen Teiler zweier ganzer Zahlen iterativ berechnet mit folgender Funktion:</span>
<span id="cb31-182"><a href="#cb31-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-183"><a href="#cb31-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-186"><a href="#cb31-186" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-187"><a href="#cb31-187" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ggT_iter(a, b):</span>
<span id="cb31-188"><a href="#cb31-188" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> b <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb31-189"><a href="#cb31-189" aria-hidden="true" tabindex="-1"></a>        a, b <span class="op">=</span> b, a <span class="op">%</span> b</span>
<span id="cb31-190"><a href="#cb31-190" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a</span>
<span id="cb31-191"><a href="#cb31-191" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-192"><a href="#cb31-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-193"><a href="#cb31-193" aria-hidden="true" tabindex="-1"></a>Hier werden innerhalb der itertiven Schleife nur zwei Anweisungen wiederholt ausgeführt:</span>
<span id="cb31-194"><a href="#cb31-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-195"><a href="#cb31-195" aria-hidden="true" tabindex="-1"></a><span class="at">&gt; setze </span><span class="in">`a`</span><span class="at"> gleich </span><span class="in">`b`</span><span class="at">, und </span><span class="in">`b`</span><span class="at"> gleich </span><span class="in">`a % b`</span><span class="at">.</span></span>
<span id="cb31-196"><a href="#cb31-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-197"><a href="#cb31-197" aria-hidden="true" tabindex="-1"></a>Genauso, wie wir eine rekursive Schleife in eine iterative Schleife überführen können, können wir auch den umgekehrten Schritt machen: eine itertive Schleife als rekursive Schleife ausdrücken:</span>
<span id="cb31-198"><a href="#cb31-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-201"><a href="#cb31-201" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-202"><a href="#cb31-202" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ggT_rek(a, b):</span>
<span id="cb31-203"><a href="#cb31-203" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> b <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> a</span>
<span id="cb31-204"><a href="#cb31-204" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: <span class="cf">return</span> ggT_rek(b, a <span class="op">%</span> b)</span>
<span id="cb31-205"><a href="#cb31-205" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-206"><a href="#cb31-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-207"><a href="#cb31-207" aria-hidden="true" tabindex="-1"></a>Hier werden die selben Anweisungen ausgeführt, aber dieses mal in einer rekursiven Schleife, indem die Funktion mit den entprechenden Argumenten aufgerufen wird:</span>
<span id="cb31-208"><a href="#cb31-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-209"><a href="#cb31-209" aria-hidden="true" tabindex="-1"></a><span class="at">&gt; setze Parameter </span><span class="in">`a`</span><span class="at"> auf </span><span class="in">`b`</span><span class="at">, und Parameter </span><span class="in">`b`</span><span class="at"> auf </span><span class="in">`a % b`</span><span class="at">.</span></span>
<span id="cb31-210"><a href="#cb31-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-211"><a href="#cb31-211" aria-hidden="true" tabindex="-1"></a>Wir haben in beiden Versionen exakt denselben Algorithmus implementiert, mit der Folge, dass die Funktionen das selbe Ergebnis mit der selben Anzahl von Berechnungsschritten liefern:</span>
<span id="cb31-212"><a href="#cb31-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-215"><a href="#cb31-215" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-216"><a href="#cb31-216" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> ggT_iter(<span class="dv">143</span>, <span class="dv">65</span>) <span class="op">==</span> ggT_rek(<span class="dv">143</span>, <span class="dv">65</span>)</span>
<span id="cb31-217"><a href="#cb31-217" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> ggT_iter(<span class="dv">3780</span>, <span class="dv">3528</span>) <span class="op">==</span> ggT_rek(<span class="dv">3780</span>, <span class="dv">3528</span>)</span>
<span id="cb31-218"><a href="#cb31-218" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-219"><a href="#cb31-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-220"><a href="#cb31-220" aria-hidden="true" tabindex="-1"></a>Es besteht aber ein *semantischer* Unterschied, d.h. in der Art *wie* wir den Algorithmus ausdrücken.\</span>
<span id="cb31-221"><a href="#cb31-221" aria-hidden="true" tabindex="-1"></a>Die **iterative Variante** folgt diesem Muster:</span>
<span id="cb31-222"><a href="#cb31-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-223"><a href="#cb31-223" aria-hidden="true" tabindex="-1"></a><span class="at">&gt; solange der Rekursionsanfang *nicht* erreicht ist:\</span></span>
<span id="cb31-224"><a href="#cb31-224" aria-hidden="true" tabindex="-1"></a><span class="at">&gt; &gt;&gt;&gt; wiederhole die Anweisungen\</span></span>
<span id="cb31-225"><a href="#cb31-225" aria-hidden="true" tabindex="-1"></a><span class="at">&gt; anderenfalls gib das Ergebnis aus</span></span>
<span id="cb31-226"><a href="#cb31-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-227"><a href="#cb31-227" aria-hidden="true" tabindex="-1"></a>Die **rekursive Variante** folgt diesem Muster:</span>
<span id="cb31-228"><a href="#cb31-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-229"><a href="#cb31-229" aria-hidden="true" tabindex="-1"></a><span class="at">&gt; wenn der Rekursionsanfang erreicht ist:\</span></span>
<span id="cb31-230"><a href="#cb31-230" aria-hidden="true" tabindex="-1"></a><span class="at">&gt; gib das Ergebnis aus\</span></span>
<span id="cb31-231"><a href="#cb31-231" aria-hidden="true" tabindex="-1"></a><span class="at">&gt; &gt;&gt;&gt; anderenfalls wiederhole die Anweisungen</span></span>
<span id="cb31-232"><a href="#cb31-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-233"><a href="#cb31-233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-234"><a href="#cb31-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-235"><a href="#cb31-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-236"><a href="#cb31-236" aria-hidden="true" tabindex="-1"></a><span class="fu">### Fibonacci-Folge</span></span>
<span id="cb31-237"><a href="#cb31-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-238"><a href="#cb31-238" aria-hidden="true" tabindex="-1"></a>Das Paradebeispiel rekursiver Definitionen in der Mathematik ist die sogenannte *Fibonacci Folge*.</span>
<span id="cb31-239"><a href="#cb31-239" aria-hidden="true" tabindex="-1"></a>Benannt ist die Folge nach dem italienischen Mathematiker Leonardo Fibonacci, den wir bereits in der Lektion <span class="co">[</span><span class="ot">Zahlenbereiche und Zahlensysteme</span><span class="co">](3-mengen.qmd#sec-dezimal)</span> kennengelernt haben.</span>
<span id="cb31-240"><a href="#cb31-240" aria-hidden="true" tabindex="-1"></a>Fibonacci hatte mit dieser Zahlenfolge in seinem Rechenbuch *Liber abbaci* das Wachstum einer (fiktiven) Kaninchenpopulation beschrieben.</span>
<span id="cb31-241"><a href="#cb31-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-242"><a href="#cb31-242" aria-hidden="true" tabindex="-1"></a>Die Fibonacci-Folge ist die unendliche Folge natürlicher Zahlen, die mit den Zahlen 0 und 1 beginnt, und bei der jede Zahl die Summe der beiden ihr vorangehenden Zahlen ist.</span>
<span id="cb31-243"><a href="#cb31-243" aria-hidden="true" tabindex="-1"></a>Die Fibonacci-Folge ist also deshalb *rekursiv*, weil ihre Elemente in Bezug auf ihre jeweils vorangehenden Elemente definiert sind.</span>
<span id="cb31-244"><a href="#cb31-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-245"><a href="#cb31-245" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb31-246"><a href="#cb31-246" aria-hidden="true" tabindex="-1"></a><span class="fu">## Rekursive Definition der Fibonacci-Folge</span></span>
<span id="cb31-247"><a href="#cb31-247" aria-hidden="true" tabindex="-1"></a>Die Fibonacci-Folge ist wie folgt mathematisch definiert:</span>
<span id="cb31-248"><a href="#cb31-248" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb31-249"><a href="#cb31-249" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb31-250"><a href="#cb31-250" aria-hidden="true" tabindex="-1"></a>F_0 &amp;= 0 <span class="sc">\\</span></span>
<span id="cb31-251"><a href="#cb31-251" aria-hidden="true" tabindex="-1"></a>F_1 &amp;= 1 <span class="sc">\\</span></span>
<span id="cb31-252"><a href="#cb31-252" aria-hidden="true" tabindex="-1"></a>F_n &amp;= F_{n-1} + F_{n-2}</span>
<span id="cb31-253"><a href="#cb31-253" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb31-254"><a href="#cb31-254" aria-hidden="true" tabindex="-1"></a>$$ {#eq-fibonacci}</span>
<span id="cb31-255"><a href="#cb31-255" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb31-256"><a href="#cb31-256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-257"><a href="#cb31-257" aria-hidden="true" tabindex="-1"></a>Wir können die Zahlen der Fibonacci-Folge also mittels Rekursion in Python bestimmen:</span>
<span id="cb31-258"><a href="#cb31-258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-261"><a href="#cb31-261" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-262"><a href="#cb31-262" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib_rek(n):</span>
<span id="cb31-263"><a href="#cb31-263" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">2</span>:                                           <span class="co"># &lt;1&gt;</span></span>
<span id="cb31-264"><a href="#cb31-264" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n</span>
<span id="cb31-265"><a href="#cb31-265" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb31-266"><a href="#cb31-266" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> fib_rek(n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib_rek(n<span class="op">-</span><span class="dv">2</span>)          <span class="co"># &lt;2&gt;</span></span>
<span id="cb31-267"><a href="#cb31-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-268"><a href="#cb31-268" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> fib_rek(<span class="dv">10</span>) <span class="op">==</span> <span class="dv">55</span></span>
<span id="cb31-269"><a href="#cb31-269" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-270"><a href="#cb31-270" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>*Rekursionsanfang*: Test, ob <span class="in">`n`</span> gleich 0 oder 1 ist. Falls ja, dann geben wir <span class="in">`n`</span> als Ergebnis zurück</span>
<span id="cb31-271"><a href="#cb31-271" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>*Rekursionsschritt*: Wenn <span class="in">`n`</span> größer als 1 ist, dann wird das Ergebnis durch zwei rekursive Aufrufe der Funktion berechnet.</span>
<span id="cb31-272"><a href="#cb31-272" aria-hidden="true" tabindex="-1"></a>Das Ergebnis ist dann die $n$-te Fibonacci-Zahl.</span>
<span id="cb31-273"><a href="#cb31-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-274"><a href="#cb31-274" aria-hidden="true" tabindex="-1"></a>Diese Rekursion ist also nicht linear, da hier zwei rekursive Aufrufe nacheinander vorkommen.</span>
<span id="cb31-275"><a href="#cb31-275" aria-hidden="true" tabindex="-1"></a>Man nennt diese Form auch *kaskadenförmige* oder *verschachtelte* Rekursion, da die Aufrufe hier einen verschachtelten Baum bilden, der sich bei jedem Aufruf zweifach verzweigt.</span>
<span id="cb31-276"><a href="#cb31-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-277"><a href="#cb31-277" aria-hidden="true" tabindex="-1"></a>Wir können auch das wieder veranschaulichen, indem wir Programmausgaben einfügen:</span>
<span id="cb31-278"><a href="#cb31-278" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-281"><a href="#cb31-281" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-282"><a href="#cb31-282" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib_print(n):</span>
<span id="cb31-283"><a href="#cb31-283" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">2</span>:                                           <span class="co"># &lt;1&gt;</span></span>
<span id="cb31-284"><a href="#cb31-284" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Rekursionsanfang mit n = </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-285"><a href="#cb31-285" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n</span>
<span id="cb31-286"><a href="#cb31-286" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb31-287"><a href="#cb31-287" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Rekursionsschritt mit n = </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-288"><a href="#cb31-288" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> fib_print(n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib_print(n<span class="op">-</span><span class="dv">2</span>)          <span class="co"># &lt;2&gt;</span></span>
<span id="cb31-289"><a href="#cb31-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-290"><a href="#cb31-290" aria-hidden="true" tabindex="-1"></a>fib_print(<span class="dv">4</span>)</span>
<span id="cb31-291"><a href="#cb31-291" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-292"><a href="#cb31-292" aria-hidden="true" tabindex="-1"></a>Es ist nicht notwendig, diesen Ablaufbaum im Detail zu verstehen, das kann bei einer verschachtelten Rekursion recht schwierig sein.</span>
<span id="cb31-293"><a href="#cb31-293" aria-hidden="true" tabindex="-1"></a>Wir wollen aber wissen, wie schnell der Baum wächst; ich habe dazu <span class="in">`fib_print`</span> mit den Argumenten 3, 4 und 5 aufgerufen und jeweils die Ausgabezeilen gezählt:</span>
<span id="cb31-294"><a href="#cb31-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-295"><a href="#cb31-295" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$fib(3)=5$</span>
<span id="cb31-296"><a href="#cb31-296" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$fib(4)=9$</span>
<span id="cb31-297"><a href="#cb31-297" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$fib(5)=15$</span>
<span id="cb31-298"><a href="#cb31-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-299"><a href="#cb31-299" aria-hidden="true" tabindex="-1"></a>Mit ein wenig Intuition (oder ausprobieren) finden wir heraus, dass die Wachstumsrate ungefähr gleich $2^{n-1}$ ist, d.h. der Aufwand steigt exponentiell in Abhängigkeit vom Eingabewert $n$.</span>
<span id="cb31-300"><a href="#cb31-300" aria-hidden="true" tabindex="-1"></a>Schon bei einem Eingabewert größer als 30 müssen wir mit mehr als einer Milliarde Aufrufen rechnen.</span>
<span id="cb31-301"><a href="#cb31-301" aria-hidden="true" tabindex="-1"></a>Wir können die Bearbeitungszeit einer Anweisung in Python mit dem *magic command* <span class="in">`%time`</span> messen:</span>
<span id="cb31-302"><a href="#cb31-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-305"><a href="#cb31-305" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-306"><a href="#cb31-306" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time fib_rek(<span class="dv">35</span>)</span>
<span id="cb31-307"><a href="#cb31-307" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-308"><a href="#cb31-308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-309"><a href="#cb31-309" aria-hidden="true" tabindex="-1"></a>Die Bearbeitungszeit beträgt knapp 900 Millisekunden ($1ms = 10^{-3}s$), also fast eine Sekunde.</span>
<span id="cb31-310"><a href="#cb31-310" aria-hidden="true" tabindex="-1"></a>Das ist für größere Eingabewerte nicht mehr praktikabel.</span>
<span id="cb31-311"><a href="#cb31-311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-312"><a href="#cb31-312" aria-hidden="true" tabindex="-1"></a>Eine Möglichkeit zur Lösung des Problems ist die Anwendung einer Technik, die als *memoization* bezeichnet wird.</span>
<span id="cb31-313"><a href="#cb31-313" aria-hidden="true" tabindex="-1"></a>Dabei werden Teilergebnisse, die bereits berechnet wurden, in einem Zwischenspeicher (engl. *cache*) gespeichert, und aus diesem cache abgerufen, ohne eine erneute Berechnung durchzuführen.</span>
<span id="cb31-314"><a href="#cb31-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-317"><a href="#cb31-317" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-318"><a href="#cb31-318" aria-hidden="true" tabindex="-1"></a>cache <span class="op">=</span> {<span class="dv">0</span>: <span class="dv">0</span>, <span class="dv">1</span>: <span class="dv">1</span>}                                <span class="co"># &lt;1&gt;</span></span>
<span id="cb31-319"><a href="#cb31-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-320"><a href="#cb31-320" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib_mem(n):</span>
<span id="cb31-321"><a href="#cb31-321" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="kw">not</span> <span class="kw">in</span> cache:                              <span class="co"># &lt;2&gt;</span></span>
<span id="cb31-322"><a href="#cb31-322" aria-hidden="true" tabindex="-1"></a>        cache[n] <span class="op">=</span> fib_mem(n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib_mem(n<span class="op">-</span><span class="dv">2</span>)      <span class="co"># &lt;3&gt;</span></span>
<span id="cb31-323"><a href="#cb31-323" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cache[n]                                 <span class="co"># &lt;4&gt;</span></span>
<span id="cb31-324"><a href="#cb31-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-325"><a href="#cb31-325" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> fib_mem(<span class="dv">10</span>) <span class="op">==</span> fib_rek(<span class="dv">10</span>)</span>
<span id="cb31-326"><a href="#cb31-326" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(cache)</span>
<span id="cb31-327"><a href="#cb31-327" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-328"><a href="#cb31-328" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Definition des Zwischenspeichers als <span class="in">`dict`</span> mit den Werten aus dem Rekursionsanfang.</span>
<span id="cb31-329"><a href="#cb31-329" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Test, ob das Ergebnis für <span class="in">`n`</span> bereits vorliegt.</span>
<span id="cb31-330"><a href="#cb31-330" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Falls nicht, berechnen wir das Ergebnisses für <span class="in">`n`</span> mittels Rekursion und fügen es zum Zwischenspeicher hinzu.</span>
<span id="cb31-331"><a href="#cb31-331" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>In jedem Fall geben wir das Ergebnis für <span class="in">`n`</span> aus dem Zwischenspeicher aus, da der cache den Wert für <span class="in">`n`</span> jetzt enthalten muss.</span>
<span id="cb31-332"><a href="#cb31-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-333"><a href="#cb31-333" aria-hidden="true" tabindex="-1"></a>Nach der Ausführung der Funktion enthält der cache alle Fibonacci-Zahlen bis einschließlich $n$.</span>
<span id="cb31-334"><a href="#cb31-334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-335"><a href="#cb31-335" aria-hidden="true" tabindex="-1"></a>Wir messen die Bearbeitungszeit der neuen Version ebenfalls mit dem Eingabewert 35:</span>
<span id="cb31-336"><a href="#cb31-336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-339"><a href="#cb31-339" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-340"><a href="#cb31-340" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time fib_mem(<span class="dv">35</span>)</span>
<span id="cb31-341"><a href="#cb31-341" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-342"><a href="#cb31-342" aria-hidden="true" tabindex="-1"></a>Die Bearbeitungszeit beträgt jetzt rund 11 Mikrosekunden ($1\mu s=10^{-6}s$).</span>
<span id="cb31-343"><a href="#cb31-343" aria-hidden="true" tabindex="-1"></a>Die neue Version ist damit um den Faktor $10^5$ schneller als die Version ohne *memoization*.</span>
<span id="cb31-344"><a href="#cb31-344" aria-hidden="true" tabindex="-1"></a>Es lohnt sich also auf jeden Fall, Algorithmen mit einer exponentiellen Laufzeit zu optimieren.</span>
<span id="cb31-345"><a href="#cb31-345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-346"><a href="#cb31-346" aria-hidden="true" tabindex="-1"></a>Die Fibonacci-Folge kann aber auch mit einer iterativen Schleife berechnet werden; hierfür benötigen wir zwei Variable, eine für die letzte und die andere für die vorletzte Zahl der bisherigen Folge:</span>
<span id="cb31-347"><a href="#cb31-347" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-350"><a href="#cb31-350" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-351"><a href="#cb31-351" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib_iter(n):</span>
<span id="cb31-352"><a href="#cb31-352" aria-hidden="true" tabindex="-1"></a>    a, b <span class="op">=</span> <span class="dv">0</span>, <span class="dv">1</span>                                     <span class="co"># &lt;1&gt;</span></span>
<span id="cb31-353"><a href="#cb31-353" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> <span class="dv">0</span>                                           <span class="co"># &lt;2&gt;</span></span>
<span id="cb31-354"><a href="#cb31-354" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> c <span class="op">!=</span> n:                                   <span class="co"># &lt;3&gt;</span></span>
<span id="cb31-355"><a href="#cb31-355" aria-hidden="true" tabindex="-1"></a>        a, b <span class="op">=</span> b, a <span class="op">+</span> b                             <span class="co"># &lt;4&gt;</span></span>
<span id="cb31-356"><a href="#cb31-356" aria-hidden="true" tabindex="-1"></a>        c <span class="op">+=</span> <span class="dv">1</span>                                      <span class="co"># &lt;5&gt;</span></span>
<span id="cb31-357"><a href="#cb31-357" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a</span>
<span id="cb31-358"><a href="#cb31-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-359"><a href="#cb31-359" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> fib_iter(<span class="dv">10</span>) <span class="op">==</span> fib_mem(<span class="dv">10</span>)</span>
<span id="cb31-360"><a href="#cb31-360" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-361"><a href="#cb31-361" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Die ersten beiden Zahlen der Folge aus dem Rekursionsanfang.</span>
<span id="cb31-362"><a href="#cb31-362" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Initialisierung eines Zählers.</span>
<span id="cb31-363"><a href="#cb31-363" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Iterative Schleife: wiederhole die Anweisungen, solange <span class="in">`c != n`</span>.</span>
<span id="cb31-364"><a href="#cb31-364" aria-hidden="true" tabindex="-1"></a>Wir verwenden hier einen Zähler als Schleifenvariable, um die Berechnung abzubrechen, sobald die gesuchte Fibonacci-Zahl berechnet wurde.</span>
<span id="cb31-365"><a href="#cb31-365" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Berechnung der nächsten Zahl der Folge als Summe der beiden vorangehenden Zahlen.</span>
<span id="cb31-366"><a href="#cb31-366" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>Hochzählen des Zählers.</span>
<span id="cb31-367"><a href="#cb31-367" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-368"><a href="#cb31-368" aria-hidden="true" tabindex="-1"></a>Wir messen erneut die Laufzeit der neuen Version:</span>
<span id="cb31-369"><a href="#cb31-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-372"><a href="#cb31-372" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-373"><a href="#cb31-373" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time fib_iter(<span class="dv">35</span>)</span>
<span id="cb31-374"><a href="#cb31-374" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-375"><a href="#cb31-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-376"><a href="#cb31-376" aria-hidden="true" tabindex="-1"></a>Die Laufzeit beträgt hier nur noch rund 6 $\mu s$; die iterative Version ist also ungefähr doppelt so schnell wie die optimierte rekursive Version.</span>
<span id="cb31-377"><a href="#cb31-377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-378"><a href="#cb31-378" aria-hidden="true" tabindex="-1"></a>In der Regel können verschachtelte Rekursionen aber nicht ohne Weiteres in iterative Schleifen überführt werden.</span>
<span id="cb31-379"><a href="#cb31-379" aria-hidden="true" tabindex="-1"></a>Bei der Fibonacci-Folge klappt das nur deshalb, weil es sich hier um eine sogenannte *primitive* Rekursion handelt, bei der das Ergebnis jeden Teilschrittes über eine einfache mathematische Operation (wie z.B. der Addition) berechnet werden kann.</span>
<span id="cb31-380"><a href="#cb31-380" aria-hidden="true" tabindex="-1"></a>Wir werden im nächsten Kapitel ein Beispiel einer nicht-primitiven Rekursion kennenlernen, die sich nicht direkt in eine iterative Schleife überführen läßt.</span>
<span id="cb31-381"><a href="#cb31-381" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-382"><a href="#cb31-382" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb31-383"><a href="#cb31-383" aria-hidden="true" tabindex="-1"></a><span class="fu">## Rekursion vs. Iteration</span></span>
<span id="cb31-384"><a href="#cb31-384" aria-hidden="true" tabindex="-1"></a>Eine **Rekursion** kommt i.d.R. mit weniger Quellcode aus und ist (für erfahrene Programmierer) übersichtlicher – es müssen hier keine Hilfsvariablen und Schleifenzähler definiert werden.\</span>
<span id="cb31-385"><a href="#cb31-385" aria-hidden="true" tabindex="-1"></a>In der Abarbeitung sind **iterative Verfahren** meist effizienter und benötigen weniger Speicherplatz.</span>
<span id="cb31-386"><a href="#cb31-386" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb31-387"><a href="#cb31-387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-388"><a href="#cb31-388" aria-hidden="true" tabindex="-1"></a><span class="fu">## Die Türme von Hanoi</span></span>
<span id="cb31-389"><a href="#cb31-389" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-390"><a href="#cb31-390" aria-hidden="true" tabindex="-1"></a>Die Türme von Hanoi sind ein mathematisches Knobel- und Geduldsspiel, das als Standardbeispiel für rekursive Programmierung dient.</span>
<span id="cb31-391"><a href="#cb31-391" aria-hidden="true" tabindex="-1"></a>Das Spiel wird von einer Person gespielt.</span>
<span id="cb31-392"><a href="#cb31-392" aria-hidden="true" tabindex="-1"></a>Es besteht aus drei gleich großen Stäben, auf die mehrere gelochte Scheiben gesteckt werden, alle verschieden groß.</span>
<span id="cb31-393"><a href="#cb31-393" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-394"><a href="#cb31-394" aria-hidden="true" tabindex="-1"></a>Zu Beginn liegen alle Scheiben auf dem linken Stab, der Größe nach geordnet, mit der größten Scheibe unten und der kleinsten oben.</span>
<span id="cb31-395"><a href="#cb31-395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-396"><a href="#cb31-396" aria-hidden="true" tabindex="-1"></a><span class="al">![Türme von Hanoi - Spielaufbau](https://upload.wikimedia.org/wikipedia/commons/0/07/Tower_of_Hanoi.jpeg)</span>{#fig-hanoi-aufbau}</span>
<span id="cb31-397"><a href="#cb31-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-398"><a href="#cb31-398" aria-hidden="true" tabindex="-1"></a>Ziel des Spiels ist es, den kompletten Scheiben-Stapel vom linken Stab auf den rechten Stab zu versetzen, wobei der mittlere Stab als temporäre Ablage dient.</span>
<span id="cb31-399"><a href="#cb31-399" aria-hidden="true" tabindex="-1"></a>Hierbei gelten zwei Regeln:</span>
<span id="cb31-400"><a href="#cb31-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-401"><a href="#cb31-401" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Es darf in jedem Zug nur eine Scheibe bewegt werden.</span>
<span id="cb31-402"><a href="#cb31-402" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Eine Scheibe muss immer auf einer größeren Scheibe abgelegt werden.</span>
<span id="cb31-403"><a href="#cb31-403" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-404"><a href="#cb31-404" aria-hidden="true" tabindex="-1"></a>Folglich sind zu jedem Zeitpunkt des Spieles die Scheiben auf jedem Stapel der Größe nach geordnet.</span>
<span id="cb31-405"><a href="#cb31-405" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-406"><a href="#cb31-406" aria-hidden="true" tabindex="-1"></a><span class="fu">### Lösungsansatz</span></span>
<span id="cb31-407"><a href="#cb31-407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-408"><a href="#cb31-408" aria-hidden="true" tabindex="-1"></a>Es ist nicht sofort offensichtlich, wie das Spiel gelöst werden kann.</span>
<span id="cb31-409"><a href="#cb31-409" aria-hidden="true" tabindex="-1"></a>In der Praxis wird man durch Ausprobieren versuchen, ein Muster für geeignete Zugfolgen zu erkennen, und dieses Muster dann wiederholt anwenden, bis alle Scheiben auf dem Zielstab abgelegt sind.</span>
<span id="cb31-410"><a href="#cb31-410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-411"><a href="#cb31-411" aria-hidden="true" tabindex="-1"></a>In der Programmierung führt Ausprobieren in der Regel nicht zum Erfolg.</span>
<span id="cb31-412"><a href="#cb31-412" aria-hidden="true" tabindex="-1"></a>Stattdessen wollen wir uns *vor* der Implementierung überlegen, wie wir das Problem am besten lösen können.</span>
<span id="cb31-413"><a href="#cb31-413" aria-hidden="true" tabindex="-1"></a>Wir versuchen also, das Muster anhand theoretischer Überlegungen zu erkennen, und es dann in Form eines Algorithmus im Programm-Code abzubilden.</span>
<span id="cb31-414"><a href="#cb31-414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-415"><a href="#cb31-415" aria-hidden="true" tabindex="-1"></a>Als erstes benennen wir dazu die bekannten Fakten:</span>
<span id="cb31-416"><a href="#cb31-416" aria-hidden="true" tabindex="-1"></a>Den linken Stab (Start) nennen wir <span class="in">`A`</span>, den mittleren (temporären) Stab <span class="in">`B`</span> und den rechten Zielstab <span class="in">`C`</span>.\</span>
<span id="cb31-417"><a href="#cb31-417" aria-hidden="true" tabindex="-1"></a>Die Anzahl der Scheiben, mit denen gespielt wird, nennen wir <span class="in">`n`</span>, wobei die kleinste (oberste) Scheibe den Wert 1 erhält, und der Wert jeder weiteren darunter liegende Scheibe jeweils um eins vergrößert wird; die unterste (größte) Scheibe hat dann den Wert <span class="in">`n`</span>.</span>
<span id="cb31-418"><a href="#cb31-418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-419"><a href="#cb31-419" aria-hidden="true" tabindex="-1"></a>Typischerweise wird das Spiel mit acht Scheiben gespielt.</span>
<span id="cb31-420"><a href="#cb31-420" aria-hidden="true" tabindex="-1"></a>Um uns die Analyse zu erleichtern, betrachten wir zunächst ein einfacheres Problem mit nur drei Schreiben.</span>
<span id="cb31-421"><a href="#cb31-421" aria-hidden="true" tabindex="-1"></a>Um dieses Problem zu lösen, müssen wir</span>
<span id="cb31-422"><a href="#cb31-422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-423"><a href="#cb31-423" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>die beiden kleinsten Scheiben (mit den Werten <span class="in">`1`</span> und <span class="in">`2`</span>) auf den temporären Stapel <span class="in">`B`</span> verschieben</span>
<span id="cb31-424"><a href="#cb31-424" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>die größte Scheibe mit dem Wert <span class="in">`3`</span> auf den Zielstapel <span class="in">`C`</span> verschieben</span>
<span id="cb31-425"><a href="#cb31-425" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>die beiden kleinsten Scheiben vom temporären Stapel <span class="in">`B`</span> auf den Zielstapel <span class="in">`C`</span> verschieben.</span>
<span id="cb31-426"><a href="#cb31-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-427"><a href="#cb31-427" aria-hidden="true" tabindex="-1"></a>::: {#fig-hanoi-analyze}</span>
<span id="cb31-428"><a href="#cb31-428" aria-hidden="true" tabindex="-1"></a>{{&lt; video media/videos/hanoi_analyze/480p15/hanoi_analyze.mp4 &gt;}}</span>
<span id="cb31-429"><a href="#cb31-429" aria-hidden="true" tabindex="-1"></a>Hanoi - Lösungsansatz in drei Schritten</span>
<span id="cb31-430"><a href="#cb31-430" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb31-431"><a href="#cb31-431" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-432"><a href="#cb31-432" aria-hidden="true" tabindex="-1"></a>Das Muster ist nachvollziehbar, aber es scheint, als gäbe es ein Problem:\</span>
<span id="cb31-433"><a href="#cb31-433" aria-hidden="true" tabindex="-1"></a>in den Schritten 1 und 3 verschieben wir mehr als eine Scheibe, was nach den Regeln nicht erlaubt ist.</span>
<span id="cb31-434"><a href="#cb31-434" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-435"><a href="#cb31-435" aria-hidden="true" tabindex="-1"></a>Wir könnten versuchen, das Problem iterativ zu lösen, indem wir explizite Zugfolgen für 2, 3, 4, oder mehr Scheiben berechnen, die verschoben werden sollen.</span>
<span id="cb31-436"><a href="#cb31-436" aria-hidden="true" tabindex="-1"></a>Bei näherer Betrachtung erkennen wir aber, dass das gar nicht notwendig ist:</span>
<span id="cb31-437"><a href="#cb31-437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-438"><a href="#cb31-438" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Schritt 2 mit dem Verschieben einer einzelnen Scheibe ist trivial (das entspricht einem Rekursionsanfang mit <span class="in">`n==1`</span>)</span>
<span id="cb31-439"><a href="#cb31-439" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>die Schritte 1 und 3 verschieben jeweils <span class="in">`n-1`</span> Scheiben (das entspricht einem Rekursionsschritt mit neuem Argument <span class="in">`n-1`</span>).</span>
<span id="cb31-440"><a href="#cb31-440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-441"><a href="#cb31-441" aria-hidden="true" tabindex="-1"></a>Es handelt sich also offensichtlich um ein rekursives Problem, und wir können den Algorithmus beschreiben, indem wir unser Muster für ein beliebiges <span class="in">`n`</span> verallgemeinern:</span>
<span id="cb31-442"><a href="#cb31-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-443"><a href="#cb31-443" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb31-444"><a href="#cb31-444" aria-hidden="true" tabindex="-1"></a><span class="fu">## Rekursiver Algorithmus</span></span>
<span id="cb31-445"><a href="#cb31-445" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Verschiebe die <span class="in">`n-1`</span> kleinsten Scheiben rekursiv auf den temporären Stapel</span>
<span id="cb31-446"><a href="#cb31-446" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Verschiebe die verbleibende Scheibe auf den Zielstapel</span>
<span id="cb31-447"><a href="#cb31-447" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Verschiebe die <span class="in">`n-1`</span> kleinsten Scheiben rekursiv vom temporären auf den Zielstapel.</span>
<span id="cb31-448"><a href="#cb31-448" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb31-449"><a href="#cb31-449" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-450"><a href="#cb31-450" aria-hidden="true" tabindex="-1"></a>Wenn wir den Algorithmus als verschachtelte Rekursion implementieren, d.h. alle drei Schritte als rekursive Aufrufe direkt nacheinander ausführen, dann wird zunächst Schritt 1 <span class="in">`n-1`</span> mal aufgerufen, bevor in Schritt 2 tatsächlich nur eine Scheibe bewegt wird.</span>
<span id="cb31-451"><a href="#cb31-451" aria-hidden="true" tabindex="-1"></a>Wir bewegen also nie mehr als eine Scheibe mit einem einzelnen Aufruf, wie gefordert.</span>
<span id="cb31-452"><a href="#cb31-452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-453"><a href="#cb31-453" aria-hidden="true" tabindex="-1"></a><span class="fu">### Implementierung</span></span>
<span id="cb31-454"><a href="#cb31-454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-455"><a href="#cb31-455" aria-hidden="true" tabindex="-1"></a>Für unsere erste Implementierung verwenden wir zur Repräsentation der Scheibenstapel eine Datenstrukur <span class="co">[</span><span class="ot">Stapel</span><span class="co">](https://de.wikipedia.org/wiki/Stapelspeicher)</span>.</span>
<span id="cb31-456"><a href="#cb31-456" aria-hidden="true" tabindex="-1"></a>Die Elemente eines Stapels werden wie bei einem Stapel Spielkarten übereinander gelegt und in umgekehrter Reihenfolge vom Stapel genommen.</span>
<span id="cb31-457"><a href="#cb31-457" aria-hidden="true" tabindex="-1"></a>Dies wird auch Last-In-First-Out-Prinzip <span class="co">[</span><span class="ot">LIFO</span><span class="co">](https://de.wikipedia.org/wiki/Last_In_%E2%80%93_First_Out)</span> genannt.</span>
<span id="cb31-458"><a href="#cb31-458" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-459"><a href="#cb31-459" aria-hidden="true" tabindex="-1"></a>Ein Stapel verfügt typischerweise über zwei Methoden <span class="in">`push`</span> und <span class="in">`pop`</span>, mit denen Elemente auf dem Stapel abgelegt bzw. wieder ausgelagert werden.</span>
<span id="cb31-460"><a href="#cb31-460" aria-hidden="true" tabindex="-1"></a>Da Python nicht über einen eingebauten Datentyp *stack* verfügt, bauen wir uns einen eigenen mit Hilfe einer Liste:</span>
<span id="cb31-461"><a href="#cb31-461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-464"><a href="#cb31-464" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-465"><a href="#cb31-465" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Stapel():</span>
<span id="cb31-466"><a href="#cb31-466" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb31-467"><a href="#cb31-467" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.speicher <span class="op">=</span> []                             <span class="co"># &lt;1&gt;</span></span>
<span id="cb31-468"><a href="#cb31-468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-469"><a href="#cb31-469" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> push(<span class="va">self</span>, elem):</span>
<span id="cb31-470"><a href="#cb31-470" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.speicher.append(elem)                     <span class="co"># &lt;2&gt;</span></span>
<span id="cb31-471"><a href="#cb31-471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-472"><a href="#cb31-472" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> pop(<span class="va">self</span>):</span>
<span id="cb31-473"><a href="#cb31-473" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.speicher.pop()                     <span class="co"># &lt;3&gt;</span></span>
<span id="cb31-474"><a href="#cb31-474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-475"><a href="#cb31-475" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):</span>
<span id="cb31-476"><a href="#cb31-476" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">repr</span>(<span class="va">self</span>.speicher)                     <span class="co"># &lt;4&gt;</span></span>
<span id="cb31-477"><a href="#cb31-477" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-478"><a href="#cb31-478" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Initialisierung einer leeren Liste als Datenspeicher.</span>
<span id="cb31-479"><a href="#cb31-479" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Implementierung der <span class="in">`push`</span> Methode: das neue Element wird am Ende der Liste angehängt.</span>
<span id="cb31-480"><a href="#cb31-480" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Implementierung der <span class="in">`pop`</span> Methode: das letzte Element der Liste wird aus dem Datenspeicher entfernt und zurückgegeben.</span>
<span id="cb31-481"><a href="#cb31-481" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Ausgabe der Elemente im Datenspeicher.</span>
<span id="cb31-482"><a href="#cb31-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-483"><a href="#cb31-483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-486"><a href="#cb31-486" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-487"><a href="#cb31-487" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb31-488"><a href="#cb31-488" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> Stapel()</span>
<span id="cb31-489"><a href="#cb31-489" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> Stapel()</span>
<span id="cb31-490"><a href="#cb31-490" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> Stapel()</span>
<span id="cb31-491"><a href="#cb31-491" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb31-492"><a href="#cb31-492" aria-hidden="true" tabindex="-1"></a>    A.push(i)</span>
<span id="cb31-493"><a href="#cb31-493" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-494"><a href="#cb31-494" aria-hidden="true" tabindex="-1"></a>A</span>
<span id="cb31-495"><a href="#cb31-495" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-496"><a href="#cb31-496" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-497"><a href="#cb31-497" aria-hidden="true" tabindex="-1"></a>Ich habe hier den Startstapel mit den Werten 1 bis <span class="in">`n`</span> befüllt, so dass, unserer Konvention folgend, das oberste Element (der letzte Eintrag in der Liste) den Wert 1 hat und das unterste Element (der erste Eintrag in der Liste) den Wert <span class="in">`n`</span> hat.</span>
<span id="cb31-498"><a href="#cb31-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-499"><a href="#cb31-499" aria-hidden="true" tabindex="-1"></a>Diese Stapel können wir nun in einer rekursiven Funktion <span class="in">`hanoi`</span> verwenden, um den rekursiven Algorithmus abzubilden:</span>
<span id="cb31-500"><a href="#cb31-500" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-503"><a href="#cb31-503" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-504"><a href="#cb31-504" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hanoi(start, ziel, temp, n):                    <span class="co"># &lt;1&gt;</span></span>
<span id="cb31-505"><a href="#cb31-505" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb31-506"><a href="#cb31-506" aria-hidden="true" tabindex="-1"></a>        ziel.push(start.pop())                      <span class="co"># &lt;2&gt;</span></span>
<span id="cb31-507"><a href="#cb31-507" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb31-508"><a href="#cb31-508" aria-hidden="true" tabindex="-1"></a>        hanoi(start, temp, ziel, n<span class="op">-</span><span class="dv">1</span>)               <span class="co"># &lt;3&gt;</span></span>
<span id="cb31-509"><a href="#cb31-509" aria-hidden="true" tabindex="-1"></a>        hanoi(start, ziel, temp, <span class="dv">1</span>)                 <span class="co"># &lt;4&gt;</span></span>
<span id="cb31-510"><a href="#cb31-510" aria-hidden="true" tabindex="-1"></a>        hanoi(temp, ziel, start, n<span class="op">-</span><span class="dv">1</span>)               <span class="co"># &lt;5&gt;</span></span>
<span id="cb31-511"><a href="#cb31-511" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-512"><a href="#cb31-512" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Signatur mit vier Parametern: <span class="in">`start`</span>, <span class="in">`ziel`</span> und <span class="in">`temp`</span>, die die jeweiligen Scheibenstapel repräsentieren; <span class="in">`n`</span> für die Gesamtanzahl der Scheiben.</span>
<span id="cb31-513"><a href="#cb31-513" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Rekursionsanfang: wenn <span class="in">`n`</span> gleich 1 ist, also die unterste Scheibe im Stapel erreicht ist, dann wird diese Scheibe vom Startstapel entfernt und auf dem Zielstapel abgelegt.</span>
<span id="cb31-514"><a href="#cb31-514" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Rekursionsschritt 1: verschieben der obersten <span class="in">`n-1`</span> Scheiben von <span class="in">`start`</span> nach <span class="in">`temp`</span>.</span>
<span id="cb31-515"><a href="#cb31-515" aria-hidden="true" tabindex="-1"></a>Beachte die Reihenfolge der Argumente: das erste Argument entpricht gemäß der Funktionssignatur dem Startstapel, das zweite dem Zielstapel und das dritte dem temporären Stapel.</span>
<span id="cb31-516"><a href="#cb31-516" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Rekursionsschritt 2: verschieben der untersten Scheibe von <span class="in">`start`</span> nach <span class="in">`ziel`</span>.</span>
<span id="cb31-517"><a href="#cb31-517" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>Rekursionsschritt 3: verschieben der <span class="in">`n-1`</span> Scheiben von <span class="in">`temp`</span> nach <span class="in">`ziel`</span>.</span>
<span id="cb31-518"><a href="#cb31-518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-519"><a href="#cb31-519" aria-hidden="true" tabindex="-1"></a>Mit dieser Implementierung wird offensichtlich, dass nur im Rekursionsanfang (<span class="in">`n==1`</span>) tatsächlich eine Scheibe verschoben wird.</span>
<span id="cb31-520"><a href="#cb31-520" aria-hidden="true" tabindex="-1"></a>Die Rekursionsschritte dienen lediglich dazu, die korrekte Reihenfolge der Züge zu berechnen.</span>
<span id="cb31-521"><a href="#cb31-521" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-522"><a href="#cb31-522" aria-hidden="true" tabindex="-1"></a>Wir rufen <span class="in">`hanoi`</span> mit den Scheibenstapeln <span class="in">`A`</span>, <span class="in">`C`</span> und <span class="in">`B`</span> auf (beachte die Reihenfolge gem. Funktionssignatur) und prüfen das Ergebnis:</span>
<span id="cb31-523"><a href="#cb31-523" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-526"><a href="#cb31-526" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-527"><a href="#cb31-527" aria-hidden="true" tabindex="-1"></a>hanoi(A, C, B, n)</span>
<span id="cb31-528"><a href="#cb31-528" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(A)</span>
<span id="cb31-529"><a href="#cb31-529" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(B)</span>
<span id="cb31-530"><a href="#cb31-530" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(C)</span>
<span id="cb31-531"><a href="#cb31-531" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-532"><a href="#cb31-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-533"><a href="#cb31-533" aria-hidden="true" tabindex="-1"></a>Offensichtlich wurden alle Scheiben in der richtigen Reihenfolge von <span class="in">`A`</span> nach <span class="in">`C`</span> verschoben.</span>
<span id="cb31-534"><a href="#cb31-534" aria-hidden="true" tabindex="-1"></a>Leider gibt diese Implementierung keinen Aufschluss darüber, in welcher Reihenfolge die Scheiben *tatsächlich* verschoben wurden.</span>
<span id="cb31-535"><a href="#cb31-535" aria-hidden="true" tabindex="-1"></a>Wenn wir das Spiel manuell lösen wollen, haben wir also immer noch keinen brauchbaren Lösungsweg.</span>
<span id="cb31-536"><a href="#cb31-536" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-537"><a href="#cb31-537" aria-hidden="true" tabindex="-1"></a>Um den Lösungsweg zu erhalten, nehmen wir eine kleine Korrektur vor:</span>
<span id="cb31-538"><a href="#cb31-538" aria-hidden="true" tabindex="-1"></a>anstatt konkrete Scheiben zu verschieben, zeichnen wir lediglich jeden Zug auf, der in Schritt 2 unseres Algorithmus ausgeführt wird.</span>
<span id="cb31-539"><a href="#cb31-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-542"><a href="#cb31-542" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-543"><a href="#cb31-543" aria-hidden="true" tabindex="-1"></a>züge <span class="op">=</span> Stapel()</span>
<span id="cb31-544"><a href="#cb31-544" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-545"><a href="#cb31-545" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hanoi(start, ziel, temp, n):</span>
<span id="cb31-546"><a href="#cb31-546" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span>                               <span class="co"># &lt;1&gt;</span></span>
<span id="cb31-547"><a href="#cb31-547" aria-hidden="true" tabindex="-1"></a>    hanoi(start, temp, ziel, n<span class="op">-</span><span class="dv">1</span>)                   <span class="co"># &lt;2&gt;</span></span>
<span id="cb31-548"><a href="#cb31-548" aria-hidden="true" tabindex="-1"></a>    züge.push((start, ziel))                        <span class="co"># &lt;3&gt;</span></span>
<span id="cb31-549"><a href="#cb31-549" aria-hidden="true" tabindex="-1"></a>    hanoi(temp, ziel, start, n<span class="op">-</span><span class="dv">1</span>)                   <span class="co"># &lt;4&gt;</span></span>
<span id="cb31-550"><a href="#cb31-550" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-551"><a href="#cb31-551" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Rekursionsanfang: wenn alle Scheiben verschoben wurden (<span class="in">`n==0`</span>), dann gibt es nichts mehr zu tun, und wir beenden das Programm.</span>
<span id="cb31-552"><a href="#cb31-552" aria-hidden="true" tabindex="-1"></a>Damit sparen wir uns auch die <span class="in">`if-else`</span> Verzweigung der bisherigen Version.</span>
<span id="cb31-553"><a href="#cb31-553" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Rekursionsschritt 1: verschiebe die obersten <span class="in">`n-1`</span> Scheiben von <span class="in">`start`</span> nach <span class="in">`temp`</span>.</span>
<span id="cb31-554"><a href="#cb31-554" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Schritt 2: speichere den Zug der aktuellen Scheibe von <span class="in">`start`</span> nach <span class="in">`ziel`</span>.</span>
<span id="cb31-555"><a href="#cb31-555" aria-hidden="true" tabindex="-1"></a>Dazu muss sich die Funktion gar nicht rekursiv aufrufen, sondern die Speicherung erfolgt direkt hier.</span>
<span id="cb31-556"><a href="#cb31-556" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Rekursionsschritt 3: verschiebe die <span class="in">`n-1`</span> Scheiben von <span class="in">`temp`</span> nach <span class="in">`ziel`</span>.</span>
<span id="cb31-557"><a href="#cb31-557" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-558"><a href="#cb31-558" aria-hidden="true" tabindex="-1"></a>Wir rufen die neue Version jetzt nicht mit den konkreten Stapeln auf, sondern mit den Buchstaben 'A', 'B' und 'C', die diese Stapel repräsentieren.</span>
<span id="cb31-559"><a href="#cb31-559" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-562"><a href="#cb31-562" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-563"><a href="#cb31-563" aria-hidden="true" tabindex="-1"></a>hanoi(<span class="st">'A'</span>, <span class="st">'C'</span>, <span class="st">'B'</span>, <span class="dv">3</span>)</span>
<span id="cb31-564"><a href="#cb31-564" aria-hidden="true" tabindex="-1"></a>züge</span>
<span id="cb31-565"><a href="#cb31-565" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-566"><a href="#cb31-566" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-567"><a href="#cb31-567" aria-hidden="true" tabindex="-1"></a>Die Züge sind wie folgt zu interpretieren:</span>
<span id="cb31-568"><a href="#cb31-568" aria-hidden="true" tabindex="-1"></a>jedes Paar in runden Klammern repräsentiert einen Zug, wobei jeweils die oberste Scheibe des erstgenannten Stapels auf den zweiten Stapel verschoben wird.</span>
<span id="cb31-569"><a href="#cb31-569" aria-hidden="true" tabindex="-1"></a>Du kannst das z.B. mit einem Stapel verschiedengroßer Münzen ausprobieren und wirst feststellen, dass das Problem damit gelöst wird, und dass dabei nie eine größere auf einer kleineren Münze plaziert wird.</span>
<span id="cb31-570"><a href="#cb31-570" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-571"><a href="#cb31-571" aria-hidden="true" tabindex="-1"></a>Ich habe die zweite Versionen der Funktion <span class="in">`hanoi`</span> benutzt, um nachfolgende Animation für vier Scheiben zu erstellen.</span>
<span id="cb31-572"><a href="#cb31-572" aria-hidden="true" tabindex="-1"></a>Wenn du wissen willst wie das geht, dann sieh dir den Quellcode unter <span class="in">`arithmetik/hanoi_solve.py`</span> an.</span>
<span id="cb31-573"><a href="#cb31-573" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-574"><a href="#cb31-574" aria-hidden="true" tabindex="-1"></a>::: {#fig-hanoi-solve}</span>
<span id="cb31-575"><a href="#cb31-575" aria-hidden="true" tabindex="-1"></a>{{&lt; video media/videos/hanoi_solve/480p15/hanoi_solve.mp4 &gt;}}</span>
<span id="cb31-576"><a href="#cb31-576" aria-hidden="true" tabindex="-1"></a>Hanoi - Lösung für vier Scheiben</span>
<span id="cb31-577"><a href="#cb31-577" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb31-578"><a href="#cb31-578" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-579"><a href="#cb31-579" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-580"><a href="#cb31-580" aria-hidden="true" tabindex="-1"></a><span class="fu">### Laufzeitanalyse</span></span>
<span id="cb31-581"><a href="#cb31-581" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-582"><a href="#cb31-582" aria-hidden="true" tabindex="-1"></a>Das Problem ist gelöst.</span>
<span id="cb31-583"><a href="#cb31-583" aria-hidden="true" tabindex="-1"></a>Bleibt nur noch, die Anzahl der dazu notwendigen Schritte zu berechnen, um eine Aussage über die Effizienz des Algorithmus zu erhalten.</span>
<span id="cb31-584"><a href="#cb31-584" aria-hidden="true" tabindex="-1"></a>Wir rufen dafür die Funktion <span class="in">`hanoi`</span> mit verschiedener Scheibenanzahl auf und zählen die Züge im jeweiligen Ergebnis:</span>
<span id="cb31-585"><a href="#cb31-585" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-588"><a href="#cb31-588" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb31-589"><a href="#cb31-589" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> size(<span class="va">self</span>):</span>
<span id="cb31-590"><a href="#cb31-590" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">len</span>(<span class="va">self</span>.speicher)</span>
<span id="cb31-591"><a href="#cb31-591" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-592"><a href="#cb31-592" aria-hidden="true" tabindex="-1"></a>Stapel.size <span class="op">=</span> size</span>
<span id="cb31-593"><a href="#cb31-593" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-594"><a href="#cb31-594" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, <span class="dv">9</span>):</span>
<span id="cb31-595"><a href="#cb31-595" aria-hidden="true" tabindex="-1"></a>    züge <span class="op">=</span> Stapel()</span>
<span id="cb31-596"><a href="#cb31-596" aria-hidden="true" tabindex="-1"></a>    hanoi(<span class="st">'A'</span>, <span class="st">'C'</span>, <span class="st">'B'</span>, n)</span>
<span id="cb31-597"><a href="#cb31-597" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss"> Scheiben: </span><span class="sc">{</span>z<span class="sc">ü</span>ge<span class="sc">.</span>size()<span class="sc">}</span><span class="ss"> Züge"</span>)</span>
<span id="cb31-598"><a href="#cb31-598" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb31-599"><a href="#cb31-599" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-600"><a href="#cb31-600" aria-hidden="true" tabindex="-1"></a>Offensichtlich ist die Anzahl der Züge $H_n$ abhängig von der Anzahl der Scheiben $n$, und mit etwas Intuition erkennen wir:</span>
<span id="cb31-601"><a href="#cb31-601" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb31-602"><a href="#cb31-602" aria-hidden="true" tabindex="-1"></a>H_n=2^n-1, \quad \mathrm{mit} \ n \geq 0.</span>
<span id="cb31-603"><a href="#cb31-603" aria-hidden="true" tabindex="-1"></a>$$ {#eq-zuege}</span>
<span id="cb31-604"><a href="#cb31-604" aria-hidden="true" tabindex="-1"></a>Wir haben es also wieder mit einem exponentiellen Wachstum zu tun.</span>
<span id="cb31-605"><a href="#cb31-605" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-606"><a href="#cb31-606" aria-hidden="true" tabindex="-1"></a>Wir wollen uns aber als angehende Mathematiker nicht auf unsere Intuition verlassen.</span>
<span id="cb31-607"><a href="#cb31-607" aria-hidden="true" tabindex="-1"></a>Außerdem wollen wir prüfen, ob es, ähnlich wie bei der Fibonacci-Folge, eine effizientere Lösung gibt, indem wir z.B. die verschachtelte Rekursion in eine lineare Rekursion überführen.</span>
<span id="cb31-608"><a href="#cb31-608" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-609"><a href="#cb31-609" aria-hidden="true" tabindex="-1"></a>Dazu analysieren wir nochmal unseren Algorithmus:</span>
<span id="cb31-610"><a href="#cb31-610" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-611"><a href="#cb31-611" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>zuerst verschieben wir die <span class="in">`n-1`</span> kleinsten Scheiben, was $H_{n-1}$ Züge erfordert</span>
<span id="cb31-612"><a href="#cb31-612" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>dann verschieben wir die größte Scheibe, was einen Zug erfordert</span>
<span id="cb31-613"><a href="#cb31-613" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>schließlich verschieben wir erneut <span class="in">`n-1`</span> Scheiben, was weitere $H_{n-1}$ Züge erfordert.</span>
<span id="cb31-614"><a href="#cb31-614" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-615"><a href="#cb31-615" aria-hidden="true" tabindex="-1"></a>Wir können also $n$ Scheiben in höchstens $2H_{n-1}+1$ Zügen verschieben:</span>
<span id="cb31-616"><a href="#cb31-616" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb31-617"><a href="#cb31-617" aria-hidden="true" tabindex="-1"></a>H_n \leq 2H_{n-1} + 1, \quad \mathrm{mit} \ n &gt; 0.</span>
<span id="cb31-618"><a href="#cb31-618" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb31-619"><a href="#cb31-619" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-620"><a href="#cb31-620" aria-hidden="true" tabindex="-1"></a>Die obige Formel verwendet $\leq$ anstatt $=$, da wir bisher nur gezeigt haben, dass $2H_{n-1}+1$ Züge auf jeden Fall ausreichen.</span>
<span id="cb31-621"><a href="#cb31-621" aria-hidden="true" tabindex="-1"></a>Vielleicht gibt es aber einen schnelleren Weg zur Lösung.</span>
<span id="cb31-622"><a href="#cb31-622" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-623"><a href="#cb31-623" aria-hidden="true" tabindex="-1"></a>Können wir das tatsächlich besser machen?\</span>
<span id="cb31-624"><a href="#cb31-624" aria-hidden="true" tabindex="-1"></a>Irgendwann müssen wir die größte Scheibe verschieben.</span>
<span id="cb31-625"><a href="#cb31-625" aria-hidden="true" tabindex="-1"></a>Zu diesem Zeitpunkt müssen sich die <span class="in">`n-1`</span> kleinsten Scheiben auf einem einzelnen Stapel befinden, und es hat mindestens $H_{n-1}$ Züge gebraucht, um sie dorthin zu bewegen.\</span>
<span id="cb31-626"><a href="#cb31-626" aria-hidden="true" tabindex="-1"></a>Es spielt keine Rolle, wie viele Züge wir für das Verschieben der größten Scheibe an die richtige Position brauchen.</span>
<span id="cb31-627"><a href="#cb31-627" aria-hidden="true" tabindex="-1"></a>Aber nach dem letzten Zug der größten Scheibe müssen wir die <span class="in">`n-1`</span> kleinsten Scheiben (die dann wieder auf einem einzelnen Stapel liegen müssen), zurück auf die größte Scheibe verschieben; das erfordert wieder mindestens $H_{n-1}$ Züge.</span>
<span id="cb31-628"><a href="#cb31-628" aria-hidden="true" tabindex="-1"></a>Daraus folgt</span>
<span id="cb31-629"><a href="#cb31-629" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb31-630"><a href="#cb31-630" aria-hidden="true" tabindex="-1"></a>H_n \geq 2H_{n-1} + 1, \quad \mathrm{mit} \ n &gt; 0.</span>
<span id="cb31-631"><a href="#cb31-631" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb31-632"><a href="#cb31-632" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-633"><a href="#cb31-633" aria-hidden="true" tabindex="-1"></a>Diese zwei Ungleichungen führen zu folgenden Gleichungen</span>
<span id="cb31-634"><a href="#cb31-634" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-635"><a href="#cb31-635" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb31-636"><a href="#cb31-636" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb31-637"><a href="#cb31-637" aria-hidden="true" tabindex="-1"></a>H_0 &amp;= 0<span class="sc">\\</span></span>
<span id="cb31-638"><a href="#cb31-638" aria-hidden="true" tabindex="-1"></a>H_n &amp;= 2H_{n-1} + 1, \quad \mathrm{mit} \ n &gt; 0.</span>
<span id="cb31-639"><a href="#cb31-639" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb31-640"><a href="#cb31-640" aria-hidden="true" tabindex="-1"></a>$$ {#eq-recurrence}</span>
<span id="cb31-641"><a href="#cb31-641" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-642"><a href="#cb31-642" aria-hidden="true" tabindex="-1"></a>Das entspricht offensichtlich einer rekursiven Definition für die Anzahl der notwendigen Züge.</span>
<span id="cb31-643"><a href="#cb31-643" aria-hidden="true" tabindex="-1"></a>Wir wollen diese Anzahl aber nicht rekursiv berechnen, sondern wir suchen eine *geschlossene Formel*, mit der wir die Anzahl der Züge in einem Schritt berechnen können.</span>
<span id="cb31-644"><a href="#cb31-644" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-645"><a href="#cb31-645" aria-hidden="true" tabindex="-1"></a>Eine Möglichkeit, eine rekursive Formel in eine geschlossene Formel zu überführen, ist die sogenannte *mathematische Induktion*.</span>
<span id="cb31-646"><a href="#cb31-646" aria-hidden="true" tabindex="-1"></a>Wir werden uns im Abschnitt <span class="co">[</span><span class="ot">Beweise</span><span class="co">](???)</span> dieses Tutorials ausführlich mit mathematischer Induktion beschäftigen.</span>
<span id="cb31-647"><a href="#cb31-647" aria-hidden="true" tabindex="-1"></a>An dieser Stelle geben wir aber schon mal ein Beispiel, um zu zeigen, wie eng das Prinzip der Induktion mit dem der Rekursion verwandt ist.</span>
<span id="cb31-648"><a href="#cb31-648" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-649"><a href="#cb31-649" aria-hidden="true" tabindex="-1"></a>Der Grundgedanke besteht darin, unsere Behauptung aus @eq-zuege (die *Induktionsbehauptung*) in die Gleichungen der rekursiven Definition (@eq-recurrence) einzusetzen und zu prüfen, ob die Gleichungen dann immer noch für jedes $n$ gelten.</span>
<span id="cb31-650"><a href="#cb31-650" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-651"><a href="#cb31-651" aria-hidden="true" tabindex="-1"></a>Der erste Fall für $n=0$ (*Induktionsanfang*) ist trivial, da $H_0 = 2^0-1=1-1=0$.</span>
<span id="cb31-652"><a href="#cb31-652" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-653"><a href="#cb31-653" aria-hidden="true" tabindex="-1"></a>Für den zweiten Fall $n\neq0$ (*Induktionsschritt*) kann die Behauptung für jedes $n$ bewiesen werden, indem wir zeigen, dass sie auch für $n-1$ gilt:</span>
<span id="cb31-654"><a href="#cb31-654" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-655"><a href="#cb31-655" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb31-656"><a href="#cb31-656" aria-hidden="true" tabindex="-1"></a>H_n=2H_{n-1}+1=2(2^{n-1}-1)+1=2^n-1.</span>
<span id="cb31-657"><a href="#cb31-657" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb31-658"><a href="#cb31-658" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-659"><a href="#cb31-659" aria-hidden="true" tabindex="-1"></a>Wir haben damit mathematisch bewiesen, dass die Anzahl der Züge *immer* gleich $2^n-1$ ist.</span>
<span id="cb31-660"><a href="#cb31-660" aria-hidden="true" tabindex="-1"></a>Damit kann es auch keine effizientere Lösung für unser Problem geben: die verschachtelte Rekursion kann nicht in eine lineare Rekursion überführt werden.</span>
<span id="cb31-661"><a href="#cb31-661" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-662"><a href="#cb31-662" aria-hidden="true" tabindex="-1"></a><span class="fu">## Übungen</span></span>
<span id="cb31-663"><a href="#cb31-663" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-664"><a href="#cb31-664" aria-hidden="true" tabindex="-1"></a>Die Übungen zu dieser Lektion findest du im Notebook <span class="in">`artithmetik/_rekursion.ipynb`</span>.</span>
</code><button title="In die Zwischenablage kopieren" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<script>videojs(video_shortcode_videojs_video1);</script>
<script>videojs(video_shortcode_videojs_video2);</script>




</body></html>