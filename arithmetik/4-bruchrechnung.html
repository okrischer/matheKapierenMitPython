<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.55">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Bruchrechnung – Mathe kapieren mit Python</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Keine Treffer",
    "search-matching-documents-text": "Treffer",
    "search-copy-link-title": "Link in die Suche kopieren",
    "search-hide-matches-text": "Zusätzliche Treffer verbergen",
    "search-more-match-text": "weitere Treffer in diesem Dokument",
    "search-more-matches-text": "weitere Treffer in diesem Dokument",
    "search-clear-button-title": "Zurücksetzen",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Abbrechen",
    "search-submit-button-title": "Abschicken",
    "search-label": "Suchen"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../arithmetik/1-rechenregeln.html">Arithmetik</a></li><li class="breadcrumb-item"><a href="../arithmetik/4-bruchrechnung.html">Bruchrechnung</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Suchen" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Mathe kapieren mit Python</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Suchen"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Arithmetik</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../arithmetik/1-rechenregeln.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Grundlegende Rechenregeln</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../arithmetik/2-teiler.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Teiler und Vielfache</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../arithmetik/3-mengen.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Zahlenbereiche und Zahlensysteme</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../arithmetik/4-bruchrechnung.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Bruchrechnung</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../arithmetik/5-rekursion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Rekursion</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Auf dieser Seite</h2>
   
  <ul>
  <li><a href="#definitionen" id="toc-definitionen" class="nav-link active" data-scroll-target="#definitionen"><span class="header-section-number">1</span> Definitionen</a></li>
  <li><a href="#erweitern-und-kürzen" id="toc-erweitern-und-kürzen" class="nav-link" data-scroll-target="#erweitern-und-kürzen"><span class="header-section-number">2</span> Erweitern und Kürzen</a></li>
  <li><a href="#addieren-und-subtrahieren" id="toc-addieren-und-subtrahieren" class="nav-link" data-scroll-target="#addieren-und-subtrahieren"><span class="header-section-number">3</span> Addieren und Subtrahieren</a></li>
  <li><a href="#multiplizieren-von-brüchen" id="toc-multiplizieren-von-brüchen" class="nav-link" data-scroll-target="#multiplizieren-von-brüchen"><span class="header-section-number">4</span> Multiplizieren von Brüchen</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../arithmetik/1-rechenregeln.html">Arithmetik</a></li><li class="breadcrumb-item"><a href="../arithmetik/4-bruchrechnung.html">Bruchrechnung</a></li></ol></nav>
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Bruchrechnung</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="definitionen" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="definitionen"><span class="header-section-number">1</span> Definitionen</h2>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Bruch
</div>
</div>
<div class="callout-body-container callout-body">
<p>Ein <strong>Bruch</strong> ist eine Zahl, die durch einen Ausdruck <span class="math inline">\(\frac{m}{n}\)</span> (<span class="math inline">\(m\)</span> geteilt durch <span class="math inline">\(n\)</span>) dargestellt wird. Die Zahl <span class="math inline">\(m\)</span> heißt <em>Zähler</em> und die Zahl <span class="math inline">\(n\)</span> <em>Nenner</em> des Bruchs.<br>
Ein Bruch ist also ein Quotient, der Zähler ist der Divident, und der Nenner ist der Divisor: <span class="math display">\[
\frac{m}{n}=m\div n, \quad \mathrm{mit} \ m, n \in \mathbb{Z} \ \mathrm{und}\ n \neq 0.
\]</span></p>
</div>
</div>
<p>Es gelten folgende Regeln:</p>
<ul>
<li>Brüche, deren Zähler kleiner ist als der Nenner, heißen <em>echte Brüche</em>, z.B. <span class="math inline">\(\frac{2}{3}\)</span> (zwei Drittel), <span class="math inline">\(\frac{5}{7}\)</span> (fünf Siebtel).</li>
<li>Brüche mit dem Zähler 1 heißen <em>Stammbrüche</em>, z.B. <span class="math inline">\(\frac{1}{4}\)</span> (ein Viertel), <span class="math inline">\(\frac{1}{10}\)</span> (ein Zehntel).</li>
<li>Ganzzahlige Anteile <em>unechter</em> Brüchen können vorgezogen werden, z.B. <span class="math inline">\(\frac{15}{4}=3\frac{3}{4}\)</span>.</li>
<li>Der <em>Kehrwert</em> eines Bruchs <span class="math inline">\(\frac{p}{q}\)</span> ist der Bruch <span class="math inline">\(\frac{q}{p}\)</span>, also der Bruch, bei dem Zähler und Nenner vertauscht sind.</li>
</ul>
<p>Wir werden auch in dieser Lektion wieder mit Python rechnen. Da Python nicht über einen “eingebauten” Datentyp <em>Fraction</em> (engl. für Bruch) verfügt, werden wir uns selbst einen solchen Datentyp “bauen”. Dafür verwenden wir das Konzept einer <em>Klasse</em>.</p>
<p>Klassen sind der Grundbaustein für die <a href="https://de.wikipedia.org/wiki/Objektorientierte_Programmierung">objektorientierte Programmierung</a> (OOP).<br>
Eine Klasse ist dabei eine Art Schablone, aus der man beliebig viele <em>Instanzen</em> (Objekte) erzeugen kann, die dann die Eigenschaften der Klasse haben.</p>
<p>Klassen in Python haben zwei Typen von Eigenschaften, <em>Attribute</em> und <em>Methoden</em>:</p>
<ul>
<li><em>Attribute</em> sind Variable, die einer Klasse zugeordnet sind, d.h. wir können in jedem Objekt bestimmte Werte unter einem festen Namen speichern.</li>
<li><em>Methoden</em> sind nichts anderes als Funktionen, die einer Klasse zugeordnet sind, d.h. wir können diese Methoden für jedes Objekt der Klasse aufrufen.</li>
</ul>
<p>Unsere <em>initiale</em> Klassendefinition sieht folgendermaßen aus:</p>
<div id="a7aaed75" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="annotated-cell-1"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-1-1" class="code-annotation-target"><a href="#annotated-cell-1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Bruch:</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-1-2" class="code-annotation-target"><a href="#annotated-cell-1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, zähler, nenner):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-1-3" class="code-annotation-target"><a href="#annotated-cell-1-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.zähler <span class="op">=</span> zähler</span>
<span id="annotated-cell-1-4"><a href="#annotated-cell-1-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nenner <span class="op">=</span> nenner</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-1-5" class="code-annotation-target"><a href="#annotated-cell-1-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.zahl <span class="op">=</span> <span class="dv">0</span></span>
<span id="annotated-cell-1-6"><a href="#annotated-cell-1-6" aria-hidden="true" tabindex="-1"></a></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="5" onclick="event.preventDefault();">5</a><span id="annotated-cell-1-7" class="code-annotation-target"><a href="#annotated-cell-1-7" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> Bruch(<span class="dv">3</span>, <span class="dv">4</span>)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="6" onclick="event.preventDefault();">6</a><span id="annotated-cell-1-8" class="code-annotation-target"><a href="#annotated-cell-1-8" aria-hidden="true" tabindex="-1"></a>a.zähler, a.nenner, a. zahl</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-1" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="1" data-code-annotation="1">Eine Klasse wird mit dem Schlüsselwort <code>class</code> definiert, gefolgt vom Namen der Klasse (der Klassenname sollte der Python-Konvention folgend mit einem Großbuchstaben beginnen).</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="2" data-code-annotation="2">Definition der Methode <code>__init__</code>. Die doppelten Unterstriche vor und nach dem Methodennamen zeigen an, dass es sich hier um eine besondere Methode handelt, die sogenannte Initialisierungsmethode. Jede Klasse muss über diese Methode verfügen; sie wird beim Erzeugen eines Objekt der Klasse automatisch aufgerufen. Der erste Parameter <code>self</code> der Methode ist ebenfalls ein spezieller Parameter: er referenziert das aktuelle Objekt.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="3" data-code-annotation="3">Zuweisung des Parameters <code>zähler</code> an das Attribut <code>self.zähler</code>. Das Attribut wird dabei automatisch angelegt und erhält den Wert des entprechenden Arguments.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="5" data-code-annotation="4">Definition eines zusätzlichen Attributs <code>zahl</code>, dessen Wert immer 0 ist. Diese Attribut repräsentiert den ganzzahligen Anteil eines unechten Bruchs</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="7" data-code-annotation="5">Instanziierung eines Objekts <code>a</code> vom Typ <code>Bruch</code> mit den Argumenten <code>3</code> und <code>4</code>. Die Argumente werden wie bei einer gewöhnlichen Funktion in runden Klammern angegeben.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="6">6</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="8" data-code-annotation="6">Auf die Attribute einer Objekts können wir mit der sogenannten <em>dot notation</em> zugreifen: <code>&lt;Objektname&gt;.&lt;Attribut&gt;</code>.</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>(3, 4, 0)</code></pre>
</div>
</div>
</section>
<section id="erweitern-und-kürzen" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="erweitern-und-kürzen"><span class="header-section-number">2</span> Erweitern und Kürzen</h2>
<p>Um einfacher mit Brüchen zu können, gibt es die Möglichkeit, Brüche zu <em>kürzen</em> oder zu <em>erweitern</em>. Ein Bruch <span class="math inline">\(\frac{2}{3}\)</span> kann z.B. auch so geschrieben werden <span class="math inline">\(\frac{4}{6}\)</span> oder <span class="math inline">\(\frac{-6}{-9}\)</span>; das sind verschiedene Schreibweisen desselben Bruchs.</p>
<p>Erweitern heißt, Zähler und Nenner eines Bruchs mit der selben Zahl zu miltiplizieren. Der Wert des Bruchs bleibt durch Erweitern unverändert.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Erweitern
</div>
</div>
<div class="callout-body-container callout-body">
<p><span id="eq-erweitern"><span class="math display">\[
\frac{a}{b}=\frac{a\cdot c}{b\cdot c}=\frac{ac}{bc}, \quad \mathrm{mit} \ c\neq 0
\tag{1}\]</span></span></p>
</div>
</div>
<p>Ein Bruch kann auch mit einer Zahl multipliziert werden; das ist aber nicht das Gleiche wie Erweitern, da sich beim Multiplizieren der Wert des Bruchs ändert:</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Unterscheide Erweitern und Multiplizieren
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Erweitern mit 3: <span class="math display">\[
\frac{2}{5}=\frac{2\cdot3}{5\cdot3}=\frac{6}{15}
\]</span></li>
<li>Multiplizieren mit 3: <span class="math display">\[
\frac{2}{5}\cdot3=\frac{2\cdot3}{5}=\frac{6}{5}
\]</span></li>
</ul>
</div>
</div>
<p>Kürzen heißt, Zähler und Nenner eines Bruchs durch die selbe Zahl zu dividieren. Der Wert des Bruchs bleibt durch Kürzen unverändert.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Kürzen
</div>
</div>
<div class="callout-body-container callout-body">
<p><span id="eq-kurzen"><span class="math display">\[
\frac{a}{b}=\frac{a\div c}{b\div c}, \quad \mathrm{mit} \ c\neq 0
\tag{2}\]</span></span></p>
</div>
</div>
<p>Ein Bruch kann auch durch eine Zahl dividiert werden; das ist aber nicht das Gleiche wie Kürzen, da sich beim Dividieren der Wert des Bruchs ändert:</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Unterscheide Kürzen und Dividieren
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Kürzen mit 3: <span class="math display">\[
\frac{6}{15}=\frac{6\div3}{15\div3}=\frac{2}{5}
\]</span></li>
<li>Dividieren durch 3: <span class="math display">\[
\frac{6}{15}\div3=\frac{6\div3}{15}=\frac{2}{15}
\]</span></li>
</ul>
</div>
</div>
</section>
<section id="addieren-und-subtrahieren" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="addieren-und-subtrahieren"><span class="header-section-number">3</span> Addieren und Subtrahieren</h2>
<p>Beim Addieren und Subtrahieren von Brüchen muss man unterscheiden zwischen <em>gleichnamigen</em> und <em>ungleichnamigen</em> Brüchen:</p>
<ul>
<li><em>Gleichnamige</em> Brüche sind Brüche mit dem gleichen Nenner.</li>
<li><em>Ungleichnamige</em> Brüche sind Brüche mit verschiedenen Nennern.</li>
</ul>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Addieren und Subtrahieren gleichnamiger Brüche
</div>
</div>
<div class="callout-body-container callout-body">
<p>Gleichnamige Brüche werden addiert oder subtrahiert, indem man die Zähler addiert oder subtrahiert und den Nenner beibehält: <span id="eq-add-gleich"><span class="math display">\[
\frac{a}{c}\pm\frac{b}{c}=\frac{a\pm b}{c}
\tag{3}\]</span></span></p>
</div>
</div>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Addieren und Subtrahieren ungleichnamiger Brüche
</div>
</div>
<div class="callout-body-container callout-body">
<p>Ungleichnamige Brüche werden addiert oder subtrahiert, indem man sie auf den <em>Hauptnenner</em> bringt, also durch Erweitern gleichnamig macht: <span id="eq-add-ungleich"><span class="math display">\[
\frac{a}{b}\pm\frac{c}{d}=\frac{a\cdot d}{b\cdot d}\pm\frac{c\cdot b}{d\cdot b}=\frac{ad\pm bc}{bd}
\tag{4}\]</span></span></p>
</div>
</div>
<p>Mit dieser Formel berechnen wir den Hauptnenner, indem wir die beiden Nenner miteinander multiplizieren: <span class="math inline">\(b\cdot d= d\cdot b=bd\)</span>.<br>
Dann müssen wir auch die Zähler der Brüche mit dem jeweils anderen Nenner multiplizieren (erweitern), um den Wert der Brüche nicht zu verändern: <span class="math inline">\(a\cdot d\)</span> und <span class="math inline">\(c\cdot b\)</span>.<br>
Dann können wir die jetzt gleichnamigen Brüche addieren oder subtrahieren, indem wir ihre Zähler addieren oder subtrahieren (<span class="math inline">\(ad\pm bc\)</span>) und den Nenner <span class="math inline">\(bd\)</span> beibehalten.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Beispiele
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><span class="math inline">\(\frac{2}{3}+\frac{4}{5}\)</span>. Der Hauptnenner ist <span class="math inline">\(3\cdot5=15\)</span>. <span class="math display">\[
\frac{2}{3}+\frac{4}{5}=\frac{2\cdot5}{3\cdot5}\pm\frac{4\cdot3}{5\cdot3}=\frac{10+12}{15}=\frac{22}{15}
\]</span></li>
<li><span class="math inline">\(\frac{3}{4}-\frac{5}{6}\)</span>. Der Hauptnenner ist <span class="math inline">\(4\cdot6=24\)</span>. <span class="math display">\[
\frac{3}{4}-\frac{5}{6}=\frac{18}{24}-\frac{20}{24}=-\frac{2}{24}=-\frac{1}{12}
\]</span></li>
</ul>
</div>
</div>
<p>Im zweiten Beispiel haben wir das Ergebnis <span class="math inline">\(-\frac{2}{24}\)</span> mit <span class="math inline">\(2\)</span> gekürzt und als Endergebnis <span class="math inline">\(-\frac{1}{12}\)</span> erhalten. Woher wissen wir aber, mit welchen Faktor wir kürzen sollen?</p>
<p>Der Kürzungsfaktor ist gemäß <a href="#eq-kurzen" class="quarto-xref">Gleichung&nbsp;2</a> ein gemeinsamer Teiler des Zählers und des Nenners. Wenn wir einen Bruch vollständig kürzen wollen, so dass keine weitere Kürzung mehr möglich ist, dann suchen wir nach dem größtmöglichen Kürzungsfaktor, also dem <em>größten gemeinsamen Teiler</em> des Zählers und des Nenners.</p>
<p>In Lektion <a href="../arithmetik/2-teiler.html#sec-ggT">Teiler und Vielfache</a> haben wir bereits eine Funktion <code>eukild_modern</code> definiert, die den <em>größten gemeinsamen Teiler</em> zweier Zahlen mit Hilfe des <em>modernen euklidischen Algorithmus</em> berechnet. Diese Funktion wollen wir nun unserer Klasse <code>Bruch</code> als neue Methode <code>ggT</code> hinzufügen:</p>
<div id="33aee3ea" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="annotated-cell-2"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-2-1" class="code-annotation-target"><a href="#annotated-cell-2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> euklid_modern(<span class="va">self</span>, a, b):</span>
<span id="annotated-cell-2-2"><a href="#annotated-cell-2-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> b <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="annotated-cell-2-3"><a href="#annotated-cell-2-3" aria-hidden="true" tabindex="-1"></a>    a, b <span class="op">=</span> b, a <span class="op">%</span> b</span>
<span id="annotated-cell-2-4"><a href="#annotated-cell-2-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> a</span>
<span id="annotated-cell-2-5"><a href="#annotated-cell-2-5" aria-hidden="true" tabindex="-1"></a></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-2-6" class="code-annotation-target"><a href="#annotated-cell-2-6" aria-hidden="true" tabindex="-1"></a>Bruch.ggT <span class="op">=</span> euklid_modern</span>
<span id="annotated-cell-2-7"><a href="#annotated-cell-2-7" aria-hidden="true" tabindex="-1"></a></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-2-8" class="code-annotation-target"><a href="#annotated-cell-2-8" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> Bruch(<span class="dv">12</span>, <span class="dv">18</span>)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-2-9" class="code-annotation-target"><a href="#annotated-cell-2-9" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> b.ggT(b.nenner, b.zähler) <span class="op">==</span> <span class="dv">6</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-2" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="1" data-code-annotation="1">Definition von <code>euklid_modern</code> als “gewöhnliche” Funktion. Wenn wir eine Funktion außerhalb der eigentlichen Klassendefinition zu einer Klasse hinzufügen wollen, dann muss der erste Parameter der Funktion das Objekt <code>self</code> sein, d.h. eine Referenz auf die Klasse.</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="6" data-code-annotation="2">Zuweisung der Funktion <code>euklid_modern</code> an die neue Methode <code>ggT</code> der Klasse <code>Bruch</code>. Bei der Zuweisung lassen wir die Klammern der Funktion weg, da wir die Funktion nicht aufrufen wollen. Mit diese Schreibweise weisen wir das <em>Funktionsobjekt</em> <code>euklid_modern</code> einem neuen Objekt des gleichen Typs der Klasse zu.</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="8" data-code-annotation="3">Initialisierung des Objekts <code>b</code> vom Typ <code>Bruch</code> mit 12 als Zähler und 18 als Nenner.</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="9" data-code-annotation="4">Aufruf der Methode <code>ggT</code> des Objekts <code>b</code> mit Nenner und Zähler des Objekts. Die Reihenfolge der Argumente dieser Methode spielt keine Rolle. Ich habe aber den größeren der beide Werte zuerst genannt, da diese Variante etwas effizienter ist.</span>
</dd>
</dl>
</div>
</div>
<p>Wir können die Methode <code>ggt</code> jetzt verwenden, um eine neue Methode <code>kürze</code> zu definieren:</p>
<div id="bf9c562b" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="annotated-cell-3"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-3-1"><a href="#annotated-cell-3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kürze_Bruch(<span class="va">self</span>):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-3-2" class="code-annotation-target"><a href="#annotated-cell-3-2" aria-hidden="true" tabindex="-1"></a>    faktor <span class="op">=</span> <span class="va">self</span>.ggT(<span class="va">self</span>.nenner, <span class="va">self</span>.zähler)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-3-3" class="code-annotation-target"><a href="#annotated-cell-3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Bruch(<span class="va">self</span>.zähler <span class="op">//</span> faktor, <span class="va">self</span>.nenner <span class="op">//</span> faktor)</span>
<span id="annotated-cell-3-4"><a href="#annotated-cell-3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-5"><a href="#annotated-cell-3-5" aria-hidden="true" tabindex="-1"></a>Bruch.kürze <span class="op">=</span> kürze_Bruch</span>
<span id="annotated-cell-3-6"><a href="#annotated-cell-3-6" aria-hidden="true" tabindex="-1"></a></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-3-7" class="code-annotation-target"><a href="#annotated-cell-3-7" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> b.kürze()</span>
<span id="annotated-cell-3-8"><a href="#annotated-cell-3-8" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> (b.zähler, b.nenner) <span class="op">==</span> (<span class="dv">2</span>, <span class="dv">3</span>)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-3" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="2" data-code-annotation="1">Berechnung des Kürzungsfaktors über den <em>ggT</em></span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="3" data-code-annotation="2">Rückgabe eines neuen Bruchs, der mit dem <code>faktor</code> gekürzt ist.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="7" data-code-annotation="3">Aufruf der Methode <code>kürze</code> des Objekts <code>b</code> und Zuweisung des Ergebnisses an das Objekt <code>b</code>. Das ursprüngliche Objekt <code>b</code> wird dabei überschrieben und ist nicht mehr verfügbar. Beachte, dass wir die Methode <code>kürze</code> ohne Argument aufrufen; der Parameter <code>self</code> der Funktion wurde beim Zuweisen der Funktion an die Klasse bereits gesetzt.</span>
</dd>
</dl>
</div>
</div>
<p>Der Bruch <span class="math inline">\(b=\frac{12}{18}\)</span> wird korrekt gekürzt zu <span class="math inline">\(b=\frac{2}{3}\)</span>. Damit können wir jetzt die Addition von Brüchen gemäß den Formeln <a href="#eq-add-gleich" class="quarto-xref">Gleichung&nbsp;3</a> und <a href="#eq-add-ungleich" class="quarto-xref">Gleichung&nbsp;4</a> als neue Methode der Klasse <code>Bruch</code> definieren:</p>
<div id="6489324c" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="annotated-cell-4"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-4-1"><a href="#annotated-cell-4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> addiere_Bruch(<span class="va">self</span>, other):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-4-2" class="code-annotation-target"><a href="#annotated-cell-4-2" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> <span class="va">self</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-4-3" class="code-annotation-target"><a href="#annotated-cell-4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="va">self</span>.nenner <span class="op">==</span> other.nenner:</span>
<span id="annotated-cell-4-4"><a href="#annotated-cell-4-4" aria-hidden="true" tabindex="-1"></a>        res <span class="op">=</span> Bruch(<span class="va">self</span>.zähler <span class="op">+</span> other.zähler, <span class="va">self</span>.nenner)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-4-5" class="code-annotation-target"><a href="#annotated-cell-4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="annotated-cell-4-6"><a href="#annotated-cell-4-6" aria-hidden="true" tabindex="-1"></a>        res <span class="op">=</span> Bruch(<span class="va">self</span>.zähler<span class="op">*</span>other.nenner <span class="op">+</span> <span class="va">self</span>.nenner<span class="op">*</span>other.zähler,</span>
<span id="annotated-cell-4-7"><a href="#annotated-cell-4-7" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.nenner<span class="op">*</span>other.nenner)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-4-8" class="code-annotation-target"><a href="#annotated-cell-4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res.kürze()</span>
<span id="annotated-cell-4-9"><a href="#annotated-cell-4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-10"><a href="#annotated-cell-4-10" aria-hidden="true" tabindex="-1"></a>Bruch.add <span class="op">=</span> addiere_Bruch</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-4" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="2" data-code-annotation="1">Initialisierung des Ergebnisses</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="3" data-code-annotation="2">Addition eines gleichnamigen Bruchs mit der entsprechendene Formel</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="5" data-code-annotation="3">Addition eines ungleichnamigen Bruchs mit der der entsprechenden Formel</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="8" data-code-annotation="4">Kürzen und Rückgabe des Ergebnisses</span>
</dd>
</dl>
</div>
</div>
<p>Wir wollen testen, ob unsere Methode <code>add</code> für folgende Beispiele korrekt arbeitet:</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Beispiele für Addition von Brüchen
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><span class="math inline">\(\frac{1}{2}+\frac{1}{3}=\frac{3}{6}+\frac{2}{6}=\frac{5}{6}\)</span></li>
<li><span class="math inline">\(\frac{1}{6}+\frac{3}{9}=\frac{1}{6}+\frac{1}{3}=\frac{3}{18}+\frac{6}{18}=\frac{9}{18}=\frac{1}{2}\)</span></li>
</ul>
</div>
</div>
<div id="4bfa8c9c" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> Bruch(<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> Bruch(<span class="dv">1</span>, <span class="dv">3</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> a.add(b)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> (c.zähler, c.nenner) <span class="op">==</span> (<span class="dv">5</span>, <span class="dv">6</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> Bruch(<span class="dv">1</span>, <span class="dv">6</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> Bruch(<span class="dv">3</span>, <span class="dv">9</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> a.add(b)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> (c.zähler, c.nenner) <span class="op">==</span> (<span class="dv">1</span>, <span class="dv">2</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Schließlich wollen wir noch eine Methode definieren, die einen Bruch in einer leichter lesbaren Form ausgibt und dabei gegebenenfall einen ganzzahligen Anteil berücksichtigt. Dazu müssen wir zunächst den ganzzahligen Anteil berechnen, falls es sich um einen <em>unechten Bruch</em> handelt.</p>
<div id="57ed54b1" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="annotated-cell-6"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-6-1"><a href="#annotated-cell-6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ganzzahliger_anteil(<span class="va">self</span>):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-6" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-6-2" class="code-annotation-target"><a href="#annotated-cell-6-2" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> <span class="va">self</span>.kürze()</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-6" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-6-3" class="code-annotation-target"><a href="#annotated-cell-6-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> b.zähler <span class="op">==</span> b.nenner:</span>
<span id="annotated-cell-6-4"><a href="#annotated-cell-6-4" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> Bruch(<span class="va">None</span>, <span class="va">None</span>)</span>
<span id="annotated-cell-6-5"><a href="#annotated-cell-6-5" aria-hidden="true" tabindex="-1"></a>        b.zahl <span class="op">=</span> <span class="dv">1</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-6" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-6-6" class="code-annotation-target"><a href="#annotated-cell-6-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> b.zähler <span class="op">&gt;</span> b.nenner:</span>
<span id="annotated-cell-6-7"><a href="#annotated-cell-6-7" aria-hidden="true" tabindex="-1"></a>        zahl <span class="op">=</span> b.zähler <span class="op">//</span> b.nenner</span>
<span id="annotated-cell-6-8"><a href="#annotated-cell-6-8" aria-hidden="true" tabindex="-1"></a>        rest <span class="op">=</span> b.zähler <span class="op">%</span> b.nenner</span>
<span id="annotated-cell-6-9"><a href="#annotated-cell-6-9" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> Bruch(rest, b.nenner)</span>
<span id="annotated-cell-6-10"><a href="#annotated-cell-6-10" aria-hidden="true" tabindex="-1"></a>        b.zahl <span class="op">=</span> zahl</span>
<span id="annotated-cell-6-11"><a href="#annotated-cell-6-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> b</span>
<span id="annotated-cell-6-12"><a href="#annotated-cell-6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-13"><a href="#annotated-cell-6-13" aria-hidden="true" tabindex="-1"></a>Bruch.gza <span class="op">=</span> ganzzahliger_anteil</span>
<span id="annotated-cell-6-14"><a href="#annotated-cell-6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-15"><a href="#annotated-cell-6-15" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> Bruch(<span class="dv">12</span>, <span class="dv">9</span>)</span>
<span id="annotated-cell-6-16"><a href="#annotated-cell-6-16" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> a.gza()</span>
<span id="annotated-cell-6-17"><a href="#annotated-cell-6-17" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> (a.zahl, a.zähler, a.nenner) <span class="op">==</span> (<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">3</span>)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-6" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-6" data-code-lines="2" data-code-annotation="1">Zuerst kürzen wird den Bruch.</span>
</dd>
<dt data-target-cell="annotated-cell-6" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-6" data-code-lines="3" data-code-annotation="2">Wenn der Zähler gleich dem Nenner ist, dann ist der Wert des Bruchs immer 1. In diesem Fall erzeugen wir einen Bruch mit undefiniertem Zähler und Nenner, indem wir beiden den Wert <code>None</code> zuweisen. Das Attribut <code>zahl</code> des Bruchs setzen wir auf 1.</span>
</dd>
<dt data-target-cell="annotated-cell-6" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-6" data-code-lines="6" data-code-annotation="3">Wenn es sich um einen <em>unechten Bruch</em> handelt (Zähler größer als der Nenner), dann berechnen wir die ganze Zahl als ganzzahlige Division von Zähler und Nenner, und den Rest der Division mit dem Modulo Operator <code>%</code>. Schließlich erzeugen wir einen neuen Bruch mit diesen Werten.</span>
</dd>
</dl>
</div>
</div>
<p>Der Bruch <span class="math inline">\(\frac{12}{9}\)</span> im Code-Beispiel wird gekürzt zu <span class="math inline">\(\frac{4}{3}\)</span> und der ganzzahlige Anteil mit 1 berechnet; der verbleibende Bruch hat den Wert <span class="math inline">\(\frac{1}{3}\)</span>.<br>
Mit Hilfe dieser Methode können wir nun den Bruch in einer neuen Methode anzeigen:</p>
<div id="75ed0dff" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="annotated-cell-7"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-7-1"><a href="#annotated-cell-7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> zeige_Bruch(<span class="va">self</span>):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-7" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-7-2" class="code-annotation-target"><a href="#annotated-cell-7-2" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> <span class="va">self</span>.gza()</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-7" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-7-3" class="code-annotation-target"><a href="#annotated-cell-7-3" aria-hidden="true" tabindex="-1"></a>    anzeige <span class="op">=</span> <span class="bu">str</span>(b.zahl) <span class="cf">if</span> b.zahl <span class="cf">else</span> <span class="st">""</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-7" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-7-4" class="code-annotation-target"><a href="#annotated-cell-7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> b.zähler <span class="kw">and</span> b.nenner:</span>
<span id="annotated-cell-7-5"><a href="#annotated-cell-7-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>anzeige<span class="sc">}</span><span class="ss">+</span><span class="sc">{</span>b<span class="sc">.</span>z<span class="sc">ä</span>hler<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>b<span class="sc">.</span>nenner<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="annotated-cell-7-6"><a href="#annotated-cell-7-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="annotated-cell-7-7"><a href="#annotated-cell-7-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(anzeige)</span>
<span id="annotated-cell-7-8"><a href="#annotated-cell-7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-7-9"><a href="#annotated-cell-7-9" aria-hidden="true" tabindex="-1"></a>Bruch.zeige <span class="op">=</span> zeige_Bruch</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-7" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-7" data-code-lines="2" data-code-annotation="1">Berechnung des ganzzahligen Anteils des Bruchs.</span>
</dd>
<dt data-target-cell="annotated-cell-7" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-7" data-code-lines="3" data-code-annotation="2">Wenn der Bruch einen ganzzahligen Anteil hat, dann fügen wir diesen zum Ausgabe-<em>string</em> hinzu.</span>
</dd>
<dt data-target-cell="annotated-cell-7" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-7" data-code-lines="4" data-code-annotation="3">Wenn Zähler und Nenner definiert sind, dann geben wir sie zusammen mit dem ganzzahligen Anteil aus. Ich habe mich hier für das Ausgabeformat <span class="math inline">\(Z+zähler/nenner\)</span> entschieden.</span>
</dd>
</dl>
</div>
</div>
<p>Beachte, dass wir in dieser Implementierung nie mit dem ganzzahligen Anteil eines Bruchs rechnen; wir benutzen ihn ausschließlich zur Ausgabe eines Bruchs:</p>
<div id="ae08a77a" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> Bruch(<span class="dv">12</span>, <span class="dv">9</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>a.zeige()</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> Bruch(<span class="dv">4</span>, <span class="dv">4</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>b.zeige()</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> a.add(b)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>c.zeige()</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"a = "</span>, a.zahl, a.zähler, a.nenner)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"b = "</span>, b.zahl, b.zähler, b.nenner)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"c = "</span>, c.zahl, c.zähler, c.nenner)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>1+1/3
1
2+1/3
a =  0 12 9
b =  0 4 4
c =  0 7 3</code></pre>
</div>
</div>
</section>
<section id="multiplizieren-von-brüchen" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="multiplizieren-von-brüchen"><span class="header-section-number">4</span> Multiplizieren von Brüchen</h2>
<p>Das Multiplizieren von Brüchen ist einfacher als das Addieren, da wir hier nicht auf <em>Gleichnamigkeit</em> achten müssen:</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Multiplizieren von Brüchen
</div>
</div>
<div class="callout-body-container callout-body">
<p>Brüche werden miteinander multipliziert, indem man Zähler mit Zähler und Nenner mit Nenner multipliziert. For dem Multiplizieren sollte man kürzen. <span id="eq-mult"><span class="math display">\[
\frac{a}{b}\cdot\frac{c}{d}=\frac{a\cdot c}{b\cdot d}=\frac{ac}{bd}
\tag{5}\]</span></span> Sonderfall: Ein Bruch wird mit einer einer Zahl multipliziert, indem man nur den Zähler mit der Zahl multipliziert. <span class="math display">\[
\frac{a}{b}\cdot c=\frac{a\cdot c}{b}=\frac{ac}{b}
\]</span></p>
</div>
</div>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Kopiert");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Kopiert");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/okrischer\.github\.io\/matheKapierenMitPython\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Quellcode</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb5" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Bruchrechnung"</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span><span class="co"> python3</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="fu">## Definitionen</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="fu">## Bruch</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>Ein **Bruch** ist eine Zahl, die durch einen Ausdruck $\frac{m}{n}$ ($m$ geteilt durch $n$) dargestellt wird.</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>Die Zahl $m$ heißt *Zähler* und die Zahl $n$ *Nenner* des Bruchs.\</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>Ein Bruch ist also ein Quotient, der Zähler ist der Divident, und der Nenner ist der Divisor:</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>\frac{m}{n}=m\div n, \quad \mathrm{mit} \ m, n \in \mathbb{Z} \ \mathrm{und}\ n \neq 0.</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>Es gelten folgende Regeln:</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Brüche, deren Zähler kleiner ist als der Nenner, heißen *echte Brüche*, z.B. $\frac{2}{3}$ (zwei Drittel), $\frac{5}{7}$ (fünf Siebtel).</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Brüche mit dem Zähler 1 heißen *Stammbrüche*, z.B. $\frac{1}{4}$ (ein Viertel), $\frac{1}{10}$ (ein Zehntel).</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Ganzzahlige Anteile *unechter* Brüchen können vorgezogen werden, z.B. $\frac{15}{4}=3\frac{3}{4}$.</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Der *Kehrwert* eines Bruchs $\frac{p}{q}$ ist der Bruch $\frac{q}{p}$, also der Bruch, bei dem Zähler und Nenner vertauscht sind.</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>Wir werden auch in dieser Lektion wieder mit Python rechnen.</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>Da Python nicht über einen "eingebauten" Datentyp *Fraction* (engl. für Bruch) verfügt, werden wir uns selbst einen solchen Datentyp "bauen".</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>Dafür verwenden wir das Konzept einer *Klasse*.</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>Klassen sind der Grundbaustein für die <span class="co">[</span><span class="ot">objektorientierte Programmierung</span><span class="co">](https://de.wikipedia.org/wiki/Objektorientierte_Programmierung)</span> (OOP).\</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>Eine Klasse ist dabei eine Art Schablone, aus der man beliebig viele *Instanzen* (Objekte) erzeugen kann, die dann die Eigenschaften der Klasse haben.</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>Klassen in Python haben zwei Typen von Eigenschaften, *Attribute* und *Methoden*:</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>*Attribute* sind Variable, die einer Klasse zugeordnet sind, d.h. wir können in jedem Objekt bestimmte Werte unter einem festen Namen speichern.</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>*Methoden* sind nichts anderes als Funktionen, die einer Klasse zugeordnet sind, d.h. wir können diese Methoden für jedes Objekt der Klasse aufrufen.</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>Unsere *initiale* Klassendefinition sieht folgendermaßen aus:</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Bruch:                                        <span class="co"># &lt;1&gt;</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, zähler, nenner):             <span class="co"># &lt;2&gt;</span></span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.zähler <span class="op">=</span> zähler                        <span class="co"># &lt;3&gt;</span></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nenner <span class="op">=</span> nenner</span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.zahl <span class="op">=</span> <span class="dv">0</span>                               <span class="co"># &lt;4&gt;</span></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> Bruch(<span class="dv">3</span>, <span class="dv">4</span>)                                     <span class="co"># &lt;5&gt;</span></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>a.zähler, a.nenner, a. zahl                         <span class="co"># &lt;6&gt;</span></span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Eine Klasse wird mit dem Schlüsselwort <span class="in">`class`</span> definiert, gefolgt vom Namen der Klasse (der Klassenname sollte der Python-Konvention folgend mit einem Großbuchstaben beginnen).</span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Definition der Methode <span class="in">`__init__`</span>. Die doppelten Unterstriche vor und nach dem Methodennamen zeigen an, dass es sich hier um eine besondere Methode handelt, die sogenannte Initialisierungsmethode.</span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>Jede Klasse muss über diese Methode verfügen; sie wird beim Erzeugen eines Objekt der Klasse automatisch aufgerufen.</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>Der erste Parameter <span class="in">`self`</span> der Methode ist ebenfalls ein spezieller Parameter: er referenziert das aktuelle Objekt.</span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Zuweisung des Parameters <span class="in">`zähler`</span> an das Attribut <span class="in">`self.zähler`</span>. Das Attribut wird dabei automatisch angelegt und erhält den Wert des entprechenden Arguments.</span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Definition eines zusätzlichen Attributs <span class="in">`zahl`</span>, dessen Wert immer 0 ist.</span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>Diese Attribut repräsentiert den ganzzahligen Anteil eines unechten Bruchs</span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>Instanziierung eines Objekts <span class="in">`a`</span> vom Typ <span class="in">`Bruch`</span> mit den Argumenten <span class="in">`3`</span> und <span class="in">`4`</span>.</span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>Die Argumente werden wie bei einer gewöhnlichen Funktion in runden Klammern angegeben.</span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>Auf die Attribute einer Objekts können wir mit der sogenannten *dot notation* zugreifen: <span class="in">`&lt;Objektname&gt;.&lt;Attribut&gt;`</span>.</span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a><span class="fu">## Erweitern und Kürzen</span></span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a>Um einfacher mit Brüchen zu können, gibt es die Möglichkeit, Brüche zu *kürzen* oder zu *erweitern*.</span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a>Ein Bruch $\frac{2}{3}$ kann z.B. auch so geschrieben werden $\frac{4}{6}$ oder $\frac{-6}{-9}$; das sind verschiedene Schreibweisen desselben Bruchs.</span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>Erweitern heißt, Zähler und Nenner eines Bruchs mit der selben Zahl zu miltiplizieren.</span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>Der Wert des Bruchs bleibt durch Erweitern unverändert.</span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a><span class="fu">## Erweitern</span></span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a>\frac{a}{b}=\frac{a\cdot c}{b\cdot c}=\frac{ac}{bc}, \quad \mathrm{mit} \ c\neq 0</span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a>$$ {#eq-erweitern}</span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true" tabindex="-1"></a>Ein Bruch kann auch mit einer Zahl multipliziert werden; das ist aber nicht das Gleiche wie Erweitern, da sich beim Multiplizieren der Wert des Bruchs ändert:</span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true" tabindex="-1"></a>::: {.callout-warning}</span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true" tabindex="-1"></a><span class="fu">## Unterscheide Erweitern und Multiplizieren</span></span>
<span id="cb5-81"><a href="#cb5-81" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Erweitern mit 3:</span>
<span id="cb5-82"><a href="#cb5-82" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-83"><a href="#cb5-83" aria-hidden="true" tabindex="-1"></a>\frac{2}{5}=\frac{2\cdot3}{5\cdot3}=\frac{6}{15}</span>
<span id="cb5-84"><a href="#cb5-84" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-85"><a href="#cb5-85" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Multiplizieren mit 3:</span>
<span id="cb5-86"><a href="#cb5-86" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-87"><a href="#cb5-87" aria-hidden="true" tabindex="-1"></a>\frac{2}{5}\cdot3=\frac{2\cdot3}{5}=\frac{6}{5}</span>
<span id="cb5-88"><a href="#cb5-88" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-89"><a href="#cb5-89" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb5-90"><a href="#cb5-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-91"><a href="#cb5-91" aria-hidden="true" tabindex="-1"></a>Kürzen heißt, Zähler und Nenner eines Bruchs durch die selbe Zahl zu dividieren.</span>
<span id="cb5-92"><a href="#cb5-92" aria-hidden="true" tabindex="-1"></a>Der Wert des Bruchs bleibt durch Kürzen unverändert.</span>
<span id="cb5-93"><a href="#cb5-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-94"><a href="#cb5-94" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb5-95"><a href="#cb5-95" aria-hidden="true" tabindex="-1"></a><span class="fu">## Kürzen</span></span>
<span id="cb5-96"><a href="#cb5-96" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-97"><a href="#cb5-97" aria-hidden="true" tabindex="-1"></a>\frac{a}{b}=\frac{a\div c}{b\div c}, \quad \mathrm{mit} \ c\neq 0</span>
<span id="cb5-98"><a href="#cb5-98" aria-hidden="true" tabindex="-1"></a>$$ {#eq-kurzen}</span>
<span id="cb5-99"><a href="#cb5-99" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb5-100"><a href="#cb5-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-101"><a href="#cb5-101" aria-hidden="true" tabindex="-1"></a>Ein Bruch kann auch durch eine Zahl dividiert werden; das ist aber nicht das Gleiche wie Kürzen, da sich beim Dividieren der Wert des Bruchs ändert:</span>
<span id="cb5-102"><a href="#cb5-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-103"><a href="#cb5-103" aria-hidden="true" tabindex="-1"></a>::: {.callout-warning}</span>
<span id="cb5-104"><a href="#cb5-104" aria-hidden="true" tabindex="-1"></a><span class="fu">## Unterscheide Kürzen und Dividieren</span></span>
<span id="cb5-105"><a href="#cb5-105" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Kürzen mit 3:</span>
<span id="cb5-106"><a href="#cb5-106" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-107"><a href="#cb5-107" aria-hidden="true" tabindex="-1"></a>\frac{6}{15}=\frac{6\div3}{15\div3}=\frac{2}{5}</span>
<span id="cb5-108"><a href="#cb5-108" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-109"><a href="#cb5-109" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Dividieren durch 3:</span>
<span id="cb5-110"><a href="#cb5-110" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-111"><a href="#cb5-111" aria-hidden="true" tabindex="-1"></a>\frac{6}{15}\div3=\frac{6\div3}{15}=\frac{2}{15}</span>
<span id="cb5-112"><a href="#cb5-112" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-113"><a href="#cb5-113" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb5-114"><a href="#cb5-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-115"><a href="#cb5-115" aria-hidden="true" tabindex="-1"></a><span class="fu">## Addieren und Subtrahieren</span></span>
<span id="cb5-116"><a href="#cb5-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-117"><a href="#cb5-117" aria-hidden="true" tabindex="-1"></a>Beim Addieren und Subtrahieren von Brüchen muss man unterscheiden zwischen *gleichnamigen* und *ungleichnamigen* Brüchen:</span>
<span id="cb5-118"><a href="#cb5-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-119"><a href="#cb5-119" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>*Gleichnamige* Brüche sind Brüche mit dem gleichen Nenner.</span>
<span id="cb5-120"><a href="#cb5-120" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>*Ungleichnamige* Brüche sind Brüche mit verschiedenen Nennern.</span>
<span id="cb5-121"><a href="#cb5-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-122"><a href="#cb5-122" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb5-123"><a href="#cb5-123" aria-hidden="true" tabindex="-1"></a><span class="fu">## Addieren und Subtrahieren gleichnamiger Brüche</span></span>
<span id="cb5-124"><a href="#cb5-124" aria-hidden="true" tabindex="-1"></a>Gleichnamige Brüche werden addiert oder subtrahiert, indem man die Zähler addiert oder subtrahiert und den Nenner beibehält:</span>
<span id="cb5-125"><a href="#cb5-125" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-126"><a href="#cb5-126" aria-hidden="true" tabindex="-1"></a>\frac{a}{c}\pm\frac{b}{c}=\frac{a\pm b}{c}</span>
<span id="cb5-127"><a href="#cb5-127" aria-hidden="true" tabindex="-1"></a>$$ {#eq-add-gleich}</span>
<span id="cb5-128"><a href="#cb5-128" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb5-129"><a href="#cb5-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-130"><a href="#cb5-130" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb5-131"><a href="#cb5-131" aria-hidden="true" tabindex="-1"></a><span class="fu">## Addieren und Subtrahieren ungleichnamiger Brüche</span></span>
<span id="cb5-132"><a href="#cb5-132" aria-hidden="true" tabindex="-1"></a>Ungleichnamige Brüche werden addiert oder subtrahiert, indem man sie auf den *Hauptnenner* bringt, also durch Erweitern gleichnamig macht:</span>
<span id="cb5-133"><a href="#cb5-133" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-134"><a href="#cb5-134" aria-hidden="true" tabindex="-1"></a>\frac{a}{b}\pm\frac{c}{d}=\frac{a\cdot d}{b\cdot d}\pm\frac{c\cdot b}{d\cdot b}=\frac{ad\pm bc}{bd}</span>
<span id="cb5-135"><a href="#cb5-135" aria-hidden="true" tabindex="-1"></a>$$ {#eq-add-ungleich}</span>
<span id="cb5-136"><a href="#cb5-136" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb5-137"><a href="#cb5-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-138"><a href="#cb5-138" aria-hidden="true" tabindex="-1"></a>Mit dieser Formel berechnen wir den Hauptnenner, indem wir die beiden Nenner miteinander multiplizieren: $b\cdot d= d\cdot b=bd$.\</span>
<span id="cb5-139"><a href="#cb5-139" aria-hidden="true" tabindex="-1"></a>Dann müssen wir auch die Zähler der Brüche mit dem jeweils anderen Nenner multiplizieren (erweitern), um den Wert der Brüche nicht zu verändern: $a\cdot d$ und $c\cdot b$.\</span>
<span id="cb5-140"><a href="#cb5-140" aria-hidden="true" tabindex="-1"></a>Dann können wir die jetzt gleichnamigen Brüche addieren oder subtrahieren, indem wir ihre Zähler addieren oder subtrahieren ($ad\pm bc$) und den Nenner $bd$ beibehalten.</span>
<span id="cb5-141"><a href="#cb5-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-142"><a href="#cb5-142" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb5-143"><a href="#cb5-143" aria-hidden="true" tabindex="-1"></a><span class="fu">## Beispiele</span></span>
<span id="cb5-144"><a href="#cb5-144" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\frac{2}{3}+\frac{4}{5}$. Der Hauptnenner ist $3\cdot5=15$.</span>
<span id="cb5-145"><a href="#cb5-145" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-146"><a href="#cb5-146" aria-hidden="true" tabindex="-1"></a>\frac{2}{3}+\frac{4}{5}=\frac{2\cdot5}{3\cdot5}\pm\frac{4\cdot3}{5\cdot3}=\frac{10+12}{15}=\frac{22}{15}</span>
<span id="cb5-147"><a href="#cb5-147" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-148"><a href="#cb5-148" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\frac{3}{4}-\frac{5}{6}$. Der Hauptnenner ist $4\cdot6=24$.</span>
<span id="cb5-149"><a href="#cb5-149" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-150"><a href="#cb5-150" aria-hidden="true" tabindex="-1"></a>\frac{3}{4}-\frac{5}{6}=\frac{18}{24}-\frac{20}{24}=-\frac{2}{24}=-\frac{1}{12}</span>
<span id="cb5-151"><a href="#cb5-151" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-152"><a href="#cb5-152" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb5-153"><a href="#cb5-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-154"><a href="#cb5-154" aria-hidden="true" tabindex="-1"></a>Im zweiten Beispiel haben wir das Ergebnis $-\frac{2}{24}$ mit $2$ gekürzt und als Endergebnis $-\frac{1}{12}$ erhalten.</span>
<span id="cb5-155"><a href="#cb5-155" aria-hidden="true" tabindex="-1"></a>Woher wissen wir aber, mit welchen Faktor wir kürzen sollen?</span>
<span id="cb5-156"><a href="#cb5-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-157"><a href="#cb5-157" aria-hidden="true" tabindex="-1"></a>Der Kürzungsfaktor ist gemäß @eq-kurzen ein gemeinsamer Teiler des Zählers und des Nenners.</span>
<span id="cb5-158"><a href="#cb5-158" aria-hidden="true" tabindex="-1"></a>Wenn wir einen Bruch vollständig kürzen wollen, so dass keine weitere Kürzung mehr möglich ist, dann suchen wir nach dem größtmöglichen Kürzungsfaktor, also dem *größten gemeinsamen Teiler* des Zählers und des Nenners.</span>
<span id="cb5-159"><a href="#cb5-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-160"><a href="#cb5-160" aria-hidden="true" tabindex="-1"></a>In Lektion <span class="co">[</span><span class="ot">Teiler und Vielfache</span><span class="co">](2-teiler.qmd#sec-ggT)</span> haben wir bereits eine Funktion <span class="in">`eukild_modern`</span> definiert, die den *größten gemeinsamen Teiler* zweier Zahlen mit Hilfe des *modernen euklidischen Algorithmus* berechnet.</span>
<span id="cb5-161"><a href="#cb5-161" aria-hidden="true" tabindex="-1"></a>Diese Funktion wollen wir nun unserer Klasse <span class="in">`Bruch`</span> als neue Methode <span class="in">`ggT`</span> hinzufügen:</span>
<span id="cb5-162"><a href="#cb5-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-165"><a href="#cb5-165" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb5-166"><a href="#cb5-166" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> euklid_modern(<span class="va">self</span>, a, b):                      <span class="co"># &lt;1&gt;</span></span>
<span id="cb5-167"><a href="#cb5-167" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> b <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb5-168"><a href="#cb5-168" aria-hidden="true" tabindex="-1"></a>    a, b <span class="op">=</span> b, a <span class="op">%</span> b</span>
<span id="cb5-169"><a href="#cb5-169" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> a</span>
<span id="cb5-170"><a href="#cb5-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-171"><a href="#cb5-171" aria-hidden="true" tabindex="-1"></a>Bruch.ggT <span class="op">=</span> euklid_modern                           <span class="co"># &lt;2&gt;</span></span>
<span id="cb5-172"><a href="#cb5-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-173"><a href="#cb5-173" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> Bruch(<span class="dv">12</span>, <span class="dv">18</span>)                                   <span class="co"># &lt;3&gt;</span></span>
<span id="cb5-174"><a href="#cb5-174" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> b.ggT(b.nenner, b.zähler) <span class="op">==</span> <span class="dv">6</span>               <span class="co"># &lt;4&gt;</span></span>
<span id="cb5-175"><a href="#cb5-175" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-176"><a href="#cb5-176" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Definition von <span class="in">`euklid_modern`</span> als "gewöhnliche" Funktion.</span>
<span id="cb5-177"><a href="#cb5-177" aria-hidden="true" tabindex="-1"></a>Wenn wir eine Funktion außerhalb der eigentlichen Klassendefinition zu einer Klasse hinzufügen wollen, dann muss der erste Parameter der Funktion das Objekt <span class="in">`self`</span> sein, d.h. eine Referenz auf die Klasse.</span>
<span id="cb5-178"><a href="#cb5-178" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Zuweisung der Funktion <span class="in">`euklid_modern`</span> an die neue Methode <span class="in">`ggT`</span> der Klasse <span class="in">`Bruch`</span>.</span>
<span id="cb5-179"><a href="#cb5-179" aria-hidden="true" tabindex="-1"></a>Bei der Zuweisung lassen wir die Klammern der Funktion weg, da wir die Funktion nicht aufrufen wollen. Mit diese Schreibweise weisen wir das *Funktionsobjekt* <span class="in">`euklid_modern`</span> einem neuen Objekt des gleichen Typs der Klasse zu.</span>
<span id="cb5-180"><a href="#cb5-180" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Initialisierung des Objekts <span class="in">`b`</span> vom Typ <span class="in">`Bruch`</span> mit 12 als Zähler und 18 als Nenner.</span>
<span id="cb5-181"><a href="#cb5-181" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Aufruf der Methode <span class="in">`ggT`</span> des Objekts <span class="in">`b`</span> mit Nenner und Zähler des Objekts.</span>
<span id="cb5-182"><a href="#cb5-182" aria-hidden="true" tabindex="-1"></a>Die Reihenfolge der Argumente dieser Methode spielt keine Rolle.</span>
<span id="cb5-183"><a href="#cb5-183" aria-hidden="true" tabindex="-1"></a>Ich habe aber den größeren der beide Werte zuerst genannt, da diese Variante etwas effizienter ist.</span>
<span id="cb5-184"><a href="#cb5-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-185"><a href="#cb5-185" aria-hidden="true" tabindex="-1"></a>Wir können die Methode <span class="in">`ggt`</span> jetzt verwenden, um eine neue Methode <span class="in">`kürze`</span> zu definieren:</span>
<span id="cb5-186"><a href="#cb5-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-189"><a href="#cb5-189" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb5-190"><a href="#cb5-190" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kürze_Bruch(<span class="va">self</span>):</span>
<span id="cb5-191"><a href="#cb5-191" aria-hidden="true" tabindex="-1"></a>    faktor <span class="op">=</span> <span class="va">self</span>.ggT(<span class="va">self</span>.nenner, <span class="va">self</span>.zähler)                 <span class="co"># &lt;1&gt;</span></span>
<span id="cb5-192"><a href="#cb5-192" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Bruch(<span class="va">self</span>.zähler <span class="op">//</span> faktor, <span class="va">self</span>.nenner <span class="op">//</span> faktor)  <span class="co"># &lt;2&gt;</span></span>
<span id="cb5-193"><a href="#cb5-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-194"><a href="#cb5-194" aria-hidden="true" tabindex="-1"></a>Bruch.kürze <span class="op">=</span> kürze_Bruch</span>
<span id="cb5-195"><a href="#cb5-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-196"><a href="#cb5-196" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> b.kürze()                                                   <span class="co"># &lt;3&gt;</span></span>
<span id="cb5-197"><a href="#cb5-197" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> (b.zähler, b.nenner) <span class="op">==</span> (<span class="dv">2</span>, <span class="dv">3</span>)</span>
<span id="cb5-198"><a href="#cb5-198" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-199"><a href="#cb5-199" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Berechnung des Kürzungsfaktors über den *ggT*</span>
<span id="cb5-200"><a href="#cb5-200" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Rückgabe eines neuen Bruchs, der mit dem <span class="in">`faktor`</span> gekürzt ist.</span>
<span id="cb5-201"><a href="#cb5-201" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Aufruf der Methode <span class="in">`kürze`</span> des Objekts <span class="in">`b`</span> und Zuweisung des Ergebnisses an das Objekt <span class="in">`b`</span>.</span>
<span id="cb5-202"><a href="#cb5-202" aria-hidden="true" tabindex="-1"></a>Das ursprüngliche Objekt <span class="in">`b`</span> wird dabei überschrieben und ist nicht mehr verfügbar.</span>
<span id="cb5-203"><a href="#cb5-203" aria-hidden="true" tabindex="-1"></a>Beachte, dass wir die Methode <span class="in">`kürze`</span> ohne Argument aufrufen; der Parameter <span class="in">`self`</span> der Funktion wurde beim Zuweisen der Funktion an die Klasse bereits gesetzt.</span>
<span id="cb5-204"><a href="#cb5-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-205"><a href="#cb5-205" aria-hidden="true" tabindex="-1"></a>Der Bruch $b=\frac{12}{18}$ wird korrekt gekürzt zu $b=\frac{2}{3}$.</span>
<span id="cb5-206"><a href="#cb5-206" aria-hidden="true" tabindex="-1"></a>Damit können wir jetzt die Addition von Brüchen gemäß den Formeln @eq-add-gleich und @eq-add-ungleich als neue Methode der Klasse <span class="in">`Bruch`</span> definieren:</span>
<span id="cb5-207"><a href="#cb5-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-210"><a href="#cb5-210" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb5-211"><a href="#cb5-211" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> addiere_Bruch(<span class="va">self</span>, other):</span>
<span id="cb5-212"><a href="#cb5-212" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> <span class="va">self</span>                                                  <span class="co"># &lt;1&gt;</span></span>
<span id="cb5-213"><a href="#cb5-213" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="va">self</span>.nenner <span class="op">==</span> other.nenner:                             <span class="co"># &lt;2&gt;</span></span>
<span id="cb5-214"><a href="#cb5-214" aria-hidden="true" tabindex="-1"></a>        res <span class="op">=</span> Bruch(<span class="va">self</span>.zähler <span class="op">+</span> other.zähler, <span class="va">self</span>.nenner)</span>
<span id="cb5-215"><a href="#cb5-215" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:                                                       <span class="co"># &lt;3&gt;</span></span>
<span id="cb5-216"><a href="#cb5-216" aria-hidden="true" tabindex="-1"></a>        res <span class="op">=</span> Bruch(<span class="va">self</span>.zähler<span class="op">*</span>other.nenner <span class="op">+</span> <span class="va">self</span>.nenner<span class="op">*</span>other.zähler,</span>
<span id="cb5-217"><a href="#cb5-217" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.nenner<span class="op">*</span>other.nenner)</span>
<span id="cb5-218"><a href="#cb5-218" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res.kürze()                                          <span class="co"># &lt;4&gt;</span></span>
<span id="cb5-219"><a href="#cb5-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-220"><a href="#cb5-220" aria-hidden="true" tabindex="-1"></a>Bruch.add <span class="op">=</span> addiere_Bruch</span>
<span id="cb5-221"><a href="#cb5-221" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-222"><a href="#cb5-222" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Initialisierung des Ergebnisses</span>
<span id="cb5-223"><a href="#cb5-223" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Addition eines gleichnamigen Bruchs mit der entsprechendene Formel</span>
<span id="cb5-224"><a href="#cb5-224" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Addition eines ungleichnamigen Bruchs mit der der entsprechenden Formel</span>
<span id="cb5-225"><a href="#cb5-225" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Kürzen und Rückgabe des Ergebnisses</span>
<span id="cb5-226"><a href="#cb5-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-227"><a href="#cb5-227" aria-hidden="true" tabindex="-1"></a>Wir wollen testen, ob unsere Methode <span class="in">`add`</span> für folgende Beispiele korrekt arbeitet:</span>
<span id="cb5-228"><a href="#cb5-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-229"><a href="#cb5-229" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb5-230"><a href="#cb5-230" aria-hidden="true" tabindex="-1"></a><span class="fu">## Beispiele für Addition von Brüchen</span></span>
<span id="cb5-231"><a href="#cb5-231" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\frac{1}{2}+\frac{1}{3}=\frac{3}{6}+\frac{2}{6}=\frac{5}{6}$</span>
<span id="cb5-232"><a href="#cb5-232" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\frac{1}{6}+\frac{3}{9}=\frac{1}{6}+\frac{1}{3}=\frac{3}{18}+\frac{6}{18}=\frac{9}{18}=\frac{1}{2}$</span>
<span id="cb5-233"><a href="#cb5-233" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb5-236"><a href="#cb5-236" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb5-237"><a href="#cb5-237" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> Bruch(<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb5-238"><a href="#cb5-238" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> Bruch(<span class="dv">1</span>, <span class="dv">3</span>)</span>
<span id="cb5-239"><a href="#cb5-239" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> a.add(b)</span>
<span id="cb5-240"><a href="#cb5-240" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> (c.zähler, c.nenner) <span class="op">==</span> (<span class="dv">5</span>, <span class="dv">6</span>)</span>
<span id="cb5-241"><a href="#cb5-241" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> Bruch(<span class="dv">1</span>, <span class="dv">6</span>)</span>
<span id="cb5-242"><a href="#cb5-242" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> Bruch(<span class="dv">3</span>, <span class="dv">9</span>)</span>
<span id="cb5-243"><a href="#cb5-243" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> a.add(b)</span>
<span id="cb5-244"><a href="#cb5-244" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> (c.zähler, c.nenner) <span class="op">==</span> (<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb5-245"><a href="#cb5-245" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-246"><a href="#cb5-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-247"><a href="#cb5-247" aria-hidden="true" tabindex="-1"></a>Schließlich wollen wir noch eine Methode definieren, die einen Bruch in einer leichter lesbaren Form ausgibt und dabei gegebenenfall einen ganzzahligen Anteil berücksichtigt.</span>
<span id="cb5-248"><a href="#cb5-248" aria-hidden="true" tabindex="-1"></a>Dazu müssen wir zunächst den ganzzahligen Anteil berechnen, falls es sich um einen *unechten Bruch* handelt.</span>
<span id="cb5-249"><a href="#cb5-249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-252"><a href="#cb5-252" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb5-253"><a href="#cb5-253" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ganzzahliger_anteil(<span class="va">self</span>):</span>
<span id="cb5-254"><a href="#cb5-254" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> <span class="va">self</span>.kürze()                                        <span class="co"># &lt;1&gt;</span></span>
<span id="cb5-255"><a href="#cb5-255" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> b.zähler <span class="op">==</span> b.nenner:                                <span class="co"># &lt;2&gt;</span></span>
<span id="cb5-256"><a href="#cb5-256" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> Bruch(<span class="va">None</span>, <span class="va">None</span>)</span>
<span id="cb5-257"><a href="#cb5-257" aria-hidden="true" tabindex="-1"></a>        b.zahl <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb5-258"><a href="#cb5-258" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> b.zähler <span class="op">&gt;</span> b.nenner:                               <span class="co"># &lt;3&gt;</span></span>
<span id="cb5-259"><a href="#cb5-259" aria-hidden="true" tabindex="-1"></a>        zahl <span class="op">=</span> b.zähler <span class="op">//</span> b.nenner</span>
<span id="cb5-260"><a href="#cb5-260" aria-hidden="true" tabindex="-1"></a>        rest <span class="op">=</span> b.zähler <span class="op">%</span> b.nenner</span>
<span id="cb5-261"><a href="#cb5-261" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> Bruch(rest, b.nenner)</span>
<span id="cb5-262"><a href="#cb5-262" aria-hidden="true" tabindex="-1"></a>        b.zahl <span class="op">=</span> zahl</span>
<span id="cb5-263"><a href="#cb5-263" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> b</span>
<span id="cb5-264"><a href="#cb5-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-265"><a href="#cb5-265" aria-hidden="true" tabindex="-1"></a>Bruch.gza <span class="op">=</span> ganzzahliger_anteil</span>
<span id="cb5-266"><a href="#cb5-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-267"><a href="#cb5-267" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> Bruch(<span class="dv">12</span>, <span class="dv">9</span>)</span>
<span id="cb5-268"><a href="#cb5-268" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> a.gza()</span>
<span id="cb5-269"><a href="#cb5-269" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> (a.zahl, a.zähler, a.nenner) <span class="op">==</span> (<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">3</span>)</span>
<span id="cb5-270"><a href="#cb5-270" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-271"><a href="#cb5-271" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Zuerst kürzen wird den Bruch.</span>
<span id="cb5-272"><a href="#cb5-272" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Wenn der Zähler gleich dem Nenner ist, dann ist der Wert des Bruchs immer 1.</span>
<span id="cb5-273"><a href="#cb5-273" aria-hidden="true" tabindex="-1"></a>In diesem Fall erzeugen wir einen Bruch mit undefiniertem Zähler und Nenner, indem wir beiden den Wert <span class="in">`None`</span> zuweisen.</span>
<span id="cb5-274"><a href="#cb5-274" aria-hidden="true" tabindex="-1"></a>Das Attribut <span class="in">`zahl`</span> des Bruchs setzen wir auf 1.</span>
<span id="cb5-275"><a href="#cb5-275" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Wenn es sich um einen *unechten Bruch* handelt (Zähler größer als der Nenner), dann berechnen wir die ganze Zahl als ganzzahlige Division von Zähler und Nenner, und den Rest der Division mit dem Modulo Operator <span class="in">`%`</span>.</span>
<span id="cb5-276"><a href="#cb5-276" aria-hidden="true" tabindex="-1"></a>Schließlich erzeugen wir einen neuen Bruch mit diesen Werten.</span>
<span id="cb5-277"><a href="#cb5-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-278"><a href="#cb5-278" aria-hidden="true" tabindex="-1"></a>Der Bruch $\frac{12}{9}$ im Code-Beispiel wird gekürzt zu $\frac{4}{3}$ und der ganzzahlige Anteil mit 1 berechnet; der verbleibende Bruch hat den Wert $\frac{1}{3}$.\</span>
<span id="cb5-279"><a href="#cb5-279" aria-hidden="true" tabindex="-1"></a>Mit Hilfe dieser Methode können wir nun den Bruch in einer neuen Methode anzeigen:</span>
<span id="cb5-280"><a href="#cb5-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-283"><a href="#cb5-283" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb5-284"><a href="#cb5-284" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> zeige_Bruch(<span class="va">self</span>):</span>
<span id="cb5-285"><a href="#cb5-285" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> <span class="va">self</span>.gza()                                      <span class="co"># &lt;1&gt;</span></span>
<span id="cb5-286"><a href="#cb5-286" aria-hidden="true" tabindex="-1"></a>    anzeige <span class="op">=</span> <span class="bu">str</span>(b.zahl) <span class="cf">if</span> b.zahl <span class="cf">else</span> <span class="st">""</span>             <span class="co"># &lt;2&gt;</span></span>
<span id="cb5-287"><a href="#cb5-287" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> b.zähler <span class="kw">and</span> b.nenner:                           <span class="co"># &lt;3&gt;</span></span>
<span id="cb5-288"><a href="#cb5-288" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>anzeige<span class="sc">}</span><span class="ss">+</span><span class="sc">{</span>b<span class="sc">.</span>z<span class="sc">ä</span>hler<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>b<span class="sc">.</span>nenner<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-289"><a href="#cb5-289" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb5-290"><a href="#cb5-290" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(anzeige)                                  <span class="co"># &lt;4&gt;</span></span>
<span id="cb5-291"><a href="#cb5-291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-292"><a href="#cb5-292" aria-hidden="true" tabindex="-1"></a>Bruch.zeige <span class="op">=</span> zeige_Bruch</span>
<span id="cb5-293"><a href="#cb5-293" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-294"><a href="#cb5-294" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Berechnung des ganzzahligen Anteils des Bruchs.</span>
<span id="cb5-295"><a href="#cb5-295" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Wenn der Bruch einen ganzzahligen Anteil hat, dann fügen wir diesen zum Ausgabe-*string* hinzu.</span>
<span id="cb5-296"><a href="#cb5-296" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Wenn Zähler und Nenner definiert sind, dann geben wir sie zusammen mit dem ganzzahligen Anteil aus.</span>
<span id="cb5-297"><a href="#cb5-297" aria-hidden="true" tabindex="-1"></a>Ich habe mich hier für das Ausgabeformat $Z+zähler/nenner$ entschieden.</span>
<span id="cb5-298"><a href="#cb5-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-299"><a href="#cb5-299" aria-hidden="true" tabindex="-1"></a>Beachte, dass wir in dieser Implementierung nie mit dem ganzzahligen Anteil eines Bruchs rechnen;</span>
<span id="cb5-300"><a href="#cb5-300" aria-hidden="true" tabindex="-1"></a>wir benutzen ihn ausschließlich zur Ausgabe eines Bruchs:</span>
<span id="cb5-301"><a href="#cb5-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-304"><a href="#cb5-304" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb5-305"><a href="#cb5-305" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> Bruch(<span class="dv">12</span>, <span class="dv">9</span>)</span>
<span id="cb5-306"><a href="#cb5-306" aria-hidden="true" tabindex="-1"></a>a.zeige()</span>
<span id="cb5-307"><a href="#cb5-307" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> Bruch(<span class="dv">4</span>, <span class="dv">4</span>)</span>
<span id="cb5-308"><a href="#cb5-308" aria-hidden="true" tabindex="-1"></a>b.zeige()</span>
<span id="cb5-309"><a href="#cb5-309" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> a.add(b)</span>
<span id="cb5-310"><a href="#cb5-310" aria-hidden="true" tabindex="-1"></a>c.zeige()</span>
<span id="cb5-311"><a href="#cb5-311" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"a = "</span>, a.zahl, a.zähler, a.nenner)</span>
<span id="cb5-312"><a href="#cb5-312" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"b = "</span>, b.zahl, b.zähler, b.nenner)</span>
<span id="cb5-313"><a href="#cb5-313" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"c = "</span>, c.zahl, c.zähler, c.nenner)</span>
<span id="cb5-314"><a href="#cb5-314" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-315"><a href="#cb5-315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-316"><a href="#cb5-316" aria-hidden="true" tabindex="-1"></a><span class="fu">## Multiplizieren von Brüchen</span></span>
<span id="cb5-317"><a href="#cb5-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-318"><a href="#cb5-318" aria-hidden="true" tabindex="-1"></a>Das Multiplizieren von Brüchen ist einfacher als das Addieren, da wir hier nicht auf *Gleichnamigkeit* achten müssen:</span>
<span id="cb5-319"><a href="#cb5-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-320"><a href="#cb5-320" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb5-321"><a href="#cb5-321" aria-hidden="true" tabindex="-1"></a><span class="fu">## Multiplizieren von Brüchen</span></span>
<span id="cb5-322"><a href="#cb5-322" aria-hidden="true" tabindex="-1"></a>Brüche werden miteinander multipliziert, indem man Zähler mit Zähler und Nenner mit Nenner multipliziert. For dem Multiplizieren sollte man kürzen.</span>
<span id="cb5-323"><a href="#cb5-323" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-324"><a href="#cb5-324" aria-hidden="true" tabindex="-1"></a>\frac{a}{b}\cdot\frac{c}{d}=\frac{a\cdot c}{b\cdot d}=\frac{ac}{bd}</span>
<span id="cb5-325"><a href="#cb5-325" aria-hidden="true" tabindex="-1"></a>$$ {#eq-mult}</span>
<span id="cb5-326"><a href="#cb5-326" aria-hidden="true" tabindex="-1"></a>Sonderfall: Ein Bruch wird mit einer einer Zahl multipliziert, indem man nur den Zähler mit der Zahl multipliziert.</span>
<span id="cb5-327"><a href="#cb5-327" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-328"><a href="#cb5-328" aria-hidden="true" tabindex="-1"></a>\frac{a}{b}\cdot c=\frac{a\cdot c}{b}=\frac{ac}{b}</span>
<span id="cb5-329"><a href="#cb5-329" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-330"><a href="#cb5-330" aria-hidden="true" tabindex="-1"></a>:::</span>
</code><button title="In die Zwischenablage kopieren" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>