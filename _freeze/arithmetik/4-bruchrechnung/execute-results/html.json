{
  "hash": "3e8ef517102e5de9314a93165de7ae16",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Bruchrechnung\n---\n\n## Definitionen\n\n::: {.callout-important}\n## Bruch\nEin **Bruch** ist eine Zahl, die durch einen Ausdruck $\\frac{m}{n}$ ($m$ geteilt durch $n$) dargestellt wird.\nDie Zahl $m$ heißt *Zähler* und die Zahl $n$ *Nenner* des Bruchs.\\\nEin Bruch ist also ein Quotient, der Zähler ist der Divident, und der Nenner ist der Divisor:\n$$\n\\frac{m}{n}=m\\div n, \\quad \\mathrm{mit} \\ m, n \\in \\mathbb{Z} \\ \\mathrm{und}\\ n \\neq 0.\n$$\n:::\n\nEs gelten folgende Regeln:\n\n- Brüche, deren Zähler kleiner ist als der Nenner, heißen *echte Brüche*, z.B. $\\frac{2}{3}$ (zwei Drittel), $\\frac{5}{7}$ (fünf Siebtel).\n- Brüche mit dem Zähler 1 heißen *Stammbrüche*, z.B. $\\frac{1}{4}$ (ein Viertel), $\\frac{1}{10}$ (ein Zehntel).\n- Ganzzahlige Anteile *unechter* Brüchen können vorgezogen werden, z.B. $\\frac{15}{4}=3\\frac{3}{4}$.\n- Der *Kehrwert* eines Bruchs $\\frac{p}{q}$ ist der Bruch $\\frac{q}{p}$, also der Bruch, bei dem Zähler und Nenner vertauscht sind.\n\nWir werden auch in dieser Lektion wieder mit Python rechnen.\nDa Python nicht über einen \"eingebauten\" Datentyp *Fraction* (engl. für Bruch) verfügt, werden wir uns selbst einen solchen Datentyp \"bauen\".\nDafür verwenden wir das Konzept einer *Klasse*.\n\nKlassen sind der Grundbaustein für die [objektorientierte Programmierung](https://de.wikipedia.org/wiki/Objektorientierte_Programmierung) (OOP).\\\nEine Klasse ist dabei eine Art Schablone, aus der man beliebig viele *Instanzen* (Objekte) erzeugen kann, die dann die Eigenschaften der Klasse haben.\n\nKlassen in Python haben zwei Typen von Eigenschaften, *Attribute* und *Methoden*:\n\n- *Attribute* sind Variable, die einer Klasse zugeordnet sind, d.h. wir können in jedem Objekt bestimmte Werte unter einem festen Namen speichern.\n- *Methoden* sind nichts anderes als Funktionen, die einer Klasse zugeordnet sind, d.h. wir können diese Methoden für jedes Objekt der Klasse aufrufen.\n\nUnsere *initiale* Klassendefinition sieht folgendermaßen aus:\n\n::: {#a7aaed75 .cell execution_count=2}\n``` {.python .cell-code}\nclass Bruch:                                        # <1>\n    def __init__(self, zähler, nenner):             # <2>\n        self.zähler = zähler                        # <3>\n        self.nenner = nenner\n        self.zahl = 0                               # <4>\n\na = Bruch(3, 4)                                     # <5>\na.zähler, a.nenner, a. zahl                         # <6>\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n(3, 4, 0)\n```\n:::\n:::\n\n\n1. Eine Klasse wird mit dem Schlüsselwort `class` definiert, gefolgt vom Namen der Klasse (der Klassenname sollte der Python-Konvention folgend mit einem Großbuchstaben beginnen).\n2. Definition der Methode `__init__`. Die doppelten Unterstriche vor und nach dem Methodennamen zeigen an, dass es sich hier um eine besondere Methode handelt, die sogenannte Initialisierungsmethode.\nJede Klasse muss über diese Methode verfügen; sie wird beim Erzeugen eines Objekt der Klasse automatisch aufgerufen.\nDer erste Parameter `self` der Methode ist ebenfalls ein spezieller Parameter: er referenziert das aktuelle Objekt.\n3. Zuweisung des Parameters `zähler` an das Attribut `self.zähler`. Das Attribut wird dabei automatisch angelegt und erhält den Wert des entprechenden Arguments.\n4. Definition eines zusätzlichen Attributs `zahl`, dessen Wert immer 0 ist.\nDiese Attribut repräsentiert den ganzzahligen Anteil eines unechten Bruchs\n5. Instanziierung eines Objekts `a` vom Typ `Bruch` mit den Argumenten `3` und `4`.\nDie Argumente werden wie bei einer gewöhnlichen Funktion in runden Klammern angegeben.\n6. Auf die Attribute einer Objekts können wir mit der sogenannten *dot notation* zugreifen: `<Objektname>.<Attribut>`.\n\n## Erweitern und Kürzen\n\nUm einfacher mit Brüchen zu können, gibt es die Möglichkeit, Brüche zu *kürzen* oder zu *erweitern*.\nEin Bruch $\\frac{2}{3}$ kann z.B. auch so geschrieben werden $\\frac{4}{6}$ oder $\\frac{-6}{-9}$; das sind verschiedene Schreibweisen desselben Bruchs.\n\nErweitern heißt, Zähler und Nenner eines Bruchs mit der selben Zahl zu miltiplizieren.\nDer Wert des Bruchs bleibt durch Erweitern unverändert.\n\n::: {.callout-important}\n## Erweitern\n$$\n\\frac{a}{b}=\\frac{a\\cdot c}{b\\cdot c}=\\frac{ac}{bc}, \\quad \\mathrm{mit} \\ c\\neq 0\n$$ {#eq-erweitern}\n:::\n\nEin Bruch kann auch mit einer Zahl multipliziert werden; das ist aber nicht das Gleiche wie Erweitern, da sich beim Multiplizieren der Wert des Bruchs ändert:\n\n::: {.callout-warning}\n## Unterscheide Erweitern und Multiplizieren\n- Erweitern mit 3:\n$$\n\\frac{2}{5}=\\frac{2\\cdot3}{5\\cdot3}=\\frac{6}{15}\n$$\n- Multiplizieren mit 3:\n$$\n\\frac{2}{5}\\cdot3=\\frac{2\\cdot3}{5}=\\frac{6}{5}\n$$\n:::\n\nKürzen heißt, Zähler und Nenner eines Bruchs durch die selbe Zahl zu dividieren.\nDer Wert des Bruchs bleibt durch Kürzen unverändert.\n\n::: {.callout-important}\n## Kürzen\n$$\n\\frac{a}{b}=\\frac{a\\div c}{b\\div c}, \\quad \\mathrm{mit} \\ c\\neq 0\n$$ {#eq-kurzen}\n:::\n\nEin Bruch kann auch durch eine Zahl dividiert werden; das ist aber nicht das Gleiche wie Kürzen, da sich beim Dividieren der Wert des Bruchs ändert:\n\n::: {.callout-warning}\n## Unterscheide Kürzen und Dividieren\n- Kürzen mit 3:\n$$\n\\frac{6}{15}=\\frac{6\\div3}{15\\div3}=\\frac{2}{5}\n$$\n- Dividieren durch 3:\n$$\n\\frac{6}{15}\\div3=\\frac{6\\div3}{15}=\\frac{2}{15}\n$$\n:::\n\n## Addieren und Subtrahieren\n\nBeim Addieren und Subtrahieren von Brüchen muss man unterscheiden zwischen *gleichnamigen* und *ungleichnamigen* Brüchen:\n\n- *Gleichnamige* Brüche sind Brüche mit dem gleichen Nenner.\n- *Ungleichnamige* Brüche sind Brüche mit verschiedenen Nennern.\n\n::: {.callout-important}\n## Addieren und Subtrahieren gleichnamiger Brüche\nGleichnamige Brüche werden addiert oder subtrahiert, indem man die Zähler addiert oder subtrahiert und den Nenner beibehält:\n$$\n\\frac{a}{c}\\pm\\frac{b}{c}=\\frac{a\\pm b}{c}\n$$ {#eq-add-gleich}\n:::\n\n::: {.callout-important}\n## Addieren und Subtrahieren ungleichnamiger Brüche\nUngleichnamige Brüche werden addiert oder subtrahiert, indem man sie auf den *Hauptnenner* bringt, also durch Erweitern gleichnamig macht:\n$$\n\\frac{a}{b}\\pm\\frac{c}{d}=\\frac{a\\cdot d}{b\\cdot d}\\pm\\frac{c\\cdot b}{d\\cdot b}=\\frac{ad\\pm bc}{bd}\n$$ {#eq-add-ungleich}\n:::\n\nMit dieser Formel berechnen wir den Hauptnenner, indem wir die beiden Nenner miteinander multiplizieren: $b\\cdot d= d\\cdot b=bd$.\\\nDann müssen wir auch die Zähler der Brüche mit dem jeweils anderen Nenner multiplizieren (erweitern), um den Wert der Brüche nicht zu verändern: $a\\cdot d$ und $c\\cdot b$.\\\nDann können wir die jetzt gleichnamigen Brüche addieren oder subtrahieren, indem wir ihre Zähler addieren oder subtrahieren ($ad\\pm bc$) und den Nenner $bd$ beibehalten.\n\n::: {.callout-tip}\n## Beispiele\n- $\\frac{2}{3}+\\frac{4}{5}$. Der Hauptnenner ist $3\\cdot5=15$.\n$$\n\\frac{2}{3}+\\frac{4}{5}=\\frac{2\\cdot5}{3\\cdot5}\\pm\\frac{4\\cdot3}{5\\cdot3}=\\frac{10+12}{15}=\\frac{22}{15}\n$$\n- $\\frac{3}{4}-\\frac{5}{6}$. Der Hauptnenner ist $4\\cdot6=24$.\n$$\n\\frac{3}{4}-\\frac{5}{6}=\\frac{18}{24}-\\frac{20}{24}=-\\frac{2}{24}=-\\frac{1}{12}\n$$\n:::\n\nIm zweiten Beispiel haben wir das Ergebnis $-\\frac{2}{24}$ mit $2$ gekürzt und als Endergebnis $-\\frac{1}{12}$ erhalten.\nWoher wissen wir aber, mit welchen Faktor wir kürzen sollen?\n\nDer Kürzungsfaktor ist gemäß @eq-kurzen ein gemeinsamer Teiler des Zählers und des Nenners.\nWenn wir einen Bruch vollständig kürzen wollen, so dass keine weitere Kürzung mehr möglich ist, dann suchen wir nach dem größtmöglichen Kürzungsfaktor, also dem *größten gemeinsamen Teiler* des Zählers und des Nenners.\n\nIn Lektion [Teiler und Vielfache](2-teiler.qmd#sec-ggT) haben wir bereits eine Funktion `eukild_modern` definiert, die den *größten gemeinsamen Teiler* zweier Zahlen mit Hilfe des *modernen euklidischen Algorithmus* berechnet.\nDiese Funktion wollen wir nun unserer Klasse `Bruch` als neue Methode `ggT` hinzufügen:\n\n::: {#33aee3ea .cell execution_count=3}\n``` {.python .cell-code}\ndef euklid_modern(self, a, b):                      # <1>\n  while b != 0:\n    a, b = b, a % b\n  return a\n\nBruch.ggT = euklid_modern                           # <2>\n\nb = Bruch(12, 18)                                   # <3>\nassert b.ggT(b.nenner, b.zähler) == 6               # <4>\n```\n:::\n\n\n1. Definition von `euklid_modern` als \"gewöhnliche\" Funktion.\nWenn wir eine Funktion außerhalb der eigentlichen Klassendefinition zu einer Klasse hinzufügen wollen, dann muss der erste Parameter der Funktion das Objekt `self` sein, d.h. eine Referenz auf die Klasse.\n2. Zuweisung der Funktion `euklid_modern` an die neue Methode `ggT` der Klasse `Bruch`.\nBei der Zuweisung lassen wir die Klammern der Funktion weg, da wir die Funktion nicht aufrufen wollen. Mit diese Schreibweise weisen wir das *Funktionsobjekt* `euklid_modern` einem neuen Objekt des gleichen Typs der Klasse zu.\n3. Initialisierung des Objekts `b` vom Typ `Bruch` mit 12 als Zähler und 18 als Nenner.\n4. Aufruf der Methode `ggT` des Objekts `b` mit Nenner und Zähler des Objekts.\nDie Reihenfolge der Argumente dieser Methode spielt keine Rolle.\nIch habe aber den größeren der beide Werte zuerst genannt, da diese Variante etwas effizienter ist.\n\nWir können die Methode `ggt` jetzt verwenden, um eine neue Methode `kürze` zu definieren:\n\n::: {#bf9c562b .cell execution_count=4}\n``` {.python .cell-code}\ndef kürze_Bruch(self):\n    faktor = self.ggT(self.nenner, self.zähler)                 # <1>\n    return Bruch(self.zähler // faktor, self.nenner // faktor)  # <2>\n\nBruch.kürze = kürze_Bruch\n\nb = b.kürze()                                                   # <3>\nassert (b.zähler, b.nenner) == (2, 3)\n```\n:::\n\n\n1. Berechnung des Kürzungsfaktors über den *ggT*\n2. Rückgabe eines neuen Bruchs, der mit dem `faktor` gekürzt ist.\n3. Aufruf der Methode `kürze` des Objekts `b` und Zuweisung des Ergebnisses an das Objekt `b`.\nDas ursprüngliche Objekt `b` wird dabei überschrieben und ist nicht mehr verfügbar.\nBeachte, dass wir die Methode `kürze` ohne Argument aufrufen; der Parameter `self` der Funktion wurde beim Zuweisen der Funktion an die Klasse bereits gesetzt.\n\nDer Bruch $b=\\frac{12}{18}$ wird korrekt gekürzt zu $b=\\frac{2}{3}$.\nDamit können wir jetzt die Addition von Brüchen gemäß den Formeln @eq-add-gleich und @eq-add-ungleich als neue Methode der Klasse `Bruch` definieren:\n\n::: {#6489324c .cell execution_count=5}\n``` {.python .cell-code}\ndef addiere_Bruch(self, other):\n    res = self                                                  # <1>\n    if self.nenner == other.nenner:                             # <2>\n        res = Bruch(self.zähler + other.zähler, self.nenner)\n    else:                                                       # <3>\n        res = Bruch(self.zähler*other.nenner + self.nenner*other.zähler,\n                    self.nenner*other.nenner)\n    return res.kürze()                                          # <4>\n\nBruch.add = addiere_Bruch\n```\n:::\n\n\n1. Initialisierung des Ergebnisses\n2. Addition eines gleichnamigen Bruchs mit der entsprechendene Formel\n3. Addition eines ungleichnamigen Bruchs mit der der entsprechenden Formel\n4. Kürzen und Rückgabe des Ergebnisses\n\nWir wollen testen, ob unsere Methode `add` für folgende Beispiele korrekt arbeitet:\n\n::: {.callout-tip}\n## Beispiele für Addition von Brüchen\n- $\\frac{1}{2}+\\frac{1}{3}=\\frac{3}{6}+\\frac{2}{6}=\\frac{5}{6}$\n- $\\frac{1}{6}+\\frac{3}{9}=\\frac{1}{6}+\\frac{1}{3}=\\frac{3}{18}+\\frac{6}{18}=\\frac{9}{18}=\\frac{1}{2}$\n:::\n\n::: {#4bfa8c9c .cell execution_count=6}\n``` {.python .cell-code}\na = Bruch(1, 2)\nb = Bruch(1, 3)\nc = a.add(b)\nassert (c.zähler, c.nenner) == (5, 6)\na = Bruch(1, 6)\nb = Bruch(3, 9)\nc = a.add(b)\nassert (c.zähler, c.nenner) == (1, 2)\n```\n:::\n\n\nSchließlich wollen wir noch eine Methode definieren, die einen Bruch in einer leichter lesbaren Form ausgibt und dabei gegebenenfall einen ganzzahligen Anteil berücksichtigt.\nDazu müssen wir zunächst den ganzzahligen Anteil berechnen, falls es sich um einen *unechten Bruch* handelt.\n\n::: {#57ed54b1 .cell execution_count=7}\n``` {.python .cell-code}\ndef ganzzahliger_anteil(self):\n    b = self.kürze()                                        # <1>\n    if b.zähler == b.nenner:                                # <2>\n        b = Bruch(None, None)\n        b.zahl = 1\n    elif b.zähler > b.nenner:                               # <3>\n        zahl = b.zähler // b.nenner\n        rest = b.zähler % b.nenner\n        b = Bruch(rest, b.nenner)\n        b.zahl = zahl\n    return b\n\nBruch.gza = ganzzahliger_anteil\n\na = Bruch(12, 9)\na = a.gza()\nassert (a.zahl, a.zähler, a.nenner) == (1, 1, 3)\n```\n:::\n\n\n1. Zuerst kürzen wird den Bruch.\n2. Wenn der Zähler gleich dem Nenner ist, dann ist der Wert des Bruchs immer 1.\nIn diesem Fall erzeugen wir einen Bruch mit undefiniertem Zähler und Nenner, indem wir beiden den Wert `None` zuweisen.\nDas Attribut `zahl` des Bruchs setzen wir auf 1.\n3. Wenn es sich um einen *unechten Bruch* handelt (Zähler größer als der Nenner), dann berechnen wir die ganze Zahl als ganzzahlige Division von Zähler und Nenner, und den Rest der Division mit dem Modulo Operator `%`.\nSchließlich erzeugen wir einen neuen Bruch mit diesen Werten.\n\nDer Bruch $\\frac{12}{9}$ im Code-Beispiel wird gekürzt zu $\\frac{4}{3}$ und der ganzzahlige Anteil mit 1 berechnet; der verbleibende Bruch hat den Wert $\\frac{1}{3}$.\\\nMit Hilfe dieser Methode können wir nun den Bruch in einer neuen Methode anzeigen:\n\n::: {#75ed0dff .cell execution_count=8}\n``` {.python .cell-code}\ndef zeige_Bruch(self):\n    b = self.gza()                                      # <1>\n    anzeige = str(b.zahl) if b.zahl else \"\"             # <2>\n    if b.zähler and b.nenner:                           # <3>\n        print(f\"{anzeige}+{b.zähler}/{b.nenner}\")\n    else:\n        print(anzeige)                                  # <4>\n\nBruch.zeige = zeige_Bruch\n```\n:::\n\n\n1. Berechnung des ganzzahligen Anteils des Bruchs.\n2. Wenn der Bruch einen ganzzahligen Anteil hat, dann fügen wir diesen zum Ausgabe-*string* hinzu.\n3. Wenn Zähler und Nenner definiert sind, dann geben wir sie zusammen mit dem ganzzahligen Anteil aus.\nIch habe mich hier für das Ausgabeformat $Z+zähler/nenner$ entschieden.\n\nBeachte, dass wir in dieser Implementierung nie mit dem ganzzahligen Anteil eines Bruchs rechnen;\nwir benutzen ihn ausschließlich zur Ausgabe eines Bruchs:\n\n::: {#ae08a77a .cell execution_count=9}\n``` {.python .cell-code}\na = Bruch(12, 9)\na.zeige()\nb = Bruch(4, 4)\nb.zeige()\nc = a.add(b)\nc.zeige()\nprint(\"a = \", a.zahl, a.zähler, a.nenner)\nprint(\"b = \", b.zahl, b.zähler, b.nenner)\nprint(\"c = \", c.zahl, c.zähler, c.nenner)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1+1/3\n1\n2+1/3\na =  0 12 9\nb =  0 4 4\nc =  0 7 3\n```\n:::\n:::\n\n\n## Multiplizieren von Brüchen\n\nDas Multiplizieren von Brüchen ist einfacher als das Addieren, da wir hier nicht auf *Gleichnamigkeit* achten müssen:\n\n::: {.callout-important}\n## Multiplizieren von Brüchen\nBrüche werden miteinander multipliziert, indem man Zähler mit Zähler und Nenner mit Nenner multipliziert. For dem Multiplizieren sollte man kürzen.\n$$\n\\frac{a}{b}\\cdot\\frac{c}{d}=\\frac{a\\cdot c}{b\\cdot d}=\\frac{ac}{bd}\n$$ {#eq-mult}\nSonderfall: Ein Bruch wird mit einer einer Zahl multipliziert, indem man nur den Zähler mit der Zahl multipliziert.\n$$\n\\frac{a}{b}\\cdot c=\\frac{a\\cdot c}{b}=\\frac{ac}{b}\n$$\n:::\n\n",
    "supporting": [
      "4-bruchrechnung_files"
    ],
    "filters": [],
    "includes": {}
  }
}