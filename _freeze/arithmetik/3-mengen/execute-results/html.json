{
  "hash": "e58ffd1ff422c299783766a00e35378f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Zahlenbereiche und Zahlensysteme\"\n---\n\nBisher haben wir wie selbstverständlich von natürlichen und reellen Zahlen gesprochen, ohne überhaupt genau zu wissen, was wir darunter verstehen wollen.\n\nIn dieser Lektion werden wir uns den Zahlenbegriff, so wie er der gesamten Mathematik zugrunde liegt, näher anschauen.\nDafür werden wir zunächst die Grundbegriffe der Mengenlehre kennenlernen und die Zahlen in Zahlenbereiche einteilen.\nSchließlich wollen wir auch noch verschiedene Zahlensysteme erkunden.\n\n## Elementare Mengenlehre {#sec-mengen}\n\nIn der Mathematik wird jede Zusammenfassung von bestimmten, wohlunterscheidbaren Objekten zu einer *Gesamtheit* eine **Menge** genannt.\nEine Menge ist definiert, wenn feststeht, welche Objekte zu dieser Menge gehören und welche nicht.\nDie zur Menge gehörenden Objekte heißen ihre *Elemente*.\nMengen werden meistens mit großen lateinischen Buchstaben bezeichnet und die Elemente mit kleinen Buchstaben.\n\n::: {.callout-important}\n## Definition von Mengen\nEs gibt zwei Möglichkeiten, Mengen zu definieren:\n\n- Durch Aufzählen ihrer Elemente, die in beliebiger Reihenfolge zwischen geschweiften Klammern (Mengenklammern) gesetzt sind und durch Komma getrennt werden: $\\{x_1, x_2, x_3, \\dots\\}$\n- Durch Angabe einer die Elemente charakteresierenden Eigenschaft: $\\{x \\mid \\mathrm{Eigenschaft}\\}$.\nDer vertikale Strich $\\mid$ wird gelesen als \"für die gilt\".\n:::\n\n::: {.callout-tip}\n## Beispiele für Mengendefinitionen\n- $A=\\{1,2,3\\}$: die Menge $A$ besteht aus den Elementen 1, 2 und 3.\n- $B=\\{x \\mid x^2-1=0\\}$: die Menge $B$ besteht aus den Elementen $x$, für die $x^2-1=0$ gilt.\n- $B=\\{1,-1\\}$: da die Gleichung $x^2-1=0$ die Lösungen $x_1= 1$ und $x_2=-1$ besitzt, kann man die Menge $B$ auch in dieser Form schreiben.\n:::\n\nGehört ein Objekt $a$ einer Menge $M$ an, so schreibt man $a \\in M$ (gelesen als: $a$ ist Element von $M$).\nGehört $a$ nicht zu $M$, so schreibt man $a \\notin M$.\n\nWenn jedes Element einer Menge $M$ auch Element einer Menge $N$ ist, so nennt man $M$ Teilmenge von $N$ und schreibt $M \\subset N$.\nDiese Schreibweise bedeutet auch, dass $M$ eine *echte* Teilmenge von $N$ ist; es gilt also $M\\neq N$.\nWollte man zulassen, dass $M$ auch gleich $N$ sein könnte, also $M=N$, dann würde man $M\\subseteq N$ schreiben.\\\nDie leere Menge $\\emptyset=\\{\\}$ enthält kein Element.\n\nDie Zugehörigkeit von Objekten zu Mengen kann man auch grafisch in einem *Mengendiagramm* darstellen, wobei Mengen als Kreise oder Ellipsen dargestellt werden, und Elemente, die zur Menge gehören, in den Kreis geschrieben werden.\n\n![Euler-Diagramm: Zugehörigkeit zu Mengen](media/images/euler/euler-diagramm.png){#fig-euler}\n\nAuf Mengen sind folgende Operationen definiert, deren Ergebnis jeweils wieder eine Menge ist:\n\n::: {.callout-important}\n## Vereinigungsmenge\nDie Vereinigung $A \\cup B$ zweier Mengen $A$ und $B$ besteht aus denjenigen Elementen, die in $A$ oder in $B$, also in mindestens einer der beiden Mengen $A, B$ enthalten sind:\n$$\nA \\cup B = \\{x \\mid x \\in A \\ \\mathrm{oder} \\ x \\in B\\}\n$$\n:::\n\n::: {.callout-important}\n## Schnittmenge\nDie Durchschnitt $A\\cap B$ zweier Mengen $A$ und $B$ besteht aus denjenigen Elementen, die sowohl in $A$ als auch in $B$, also gleichzeitig in beiden Mengen $A, B$ enthalten sind:\n$$\nA \\cap B = \\{x \\mid x \\in A \\ \\mathrm{und} \\ x \\in B\\}\n$$\n:::\n\n::: {.callout-important}\n## Differenz\nDie Differenz $A \\backslash B$ zweier Mengen $A$ und $B$ besteht aus denjenigen Elementen, die in $A$, aber nicht in $B$ enthalten sind:\n$$\nA \\backslash B = \\{x \\mid x \\in A \\ \\mathrm{und} \\ x \\notin B\\}\n$$\n:::\n\n::: {.callout-important}\n## Symmetrische Differenz\nDie symmetrische Differenz $A \\Delta B$ zweier Mengen $A$ und $B$ besteht aus denjenigen Elementen, die in $A$ oder $B$ enthalten sind, aber nicht in der Schnittmenge von $A$ und $B$:\n$$\nA \\Delta B = (A \\cup B) \\backslash (A \\cap B)=(A \\backslash B) \\cup (B \\backslash A)\n$$\n:::\n\nDiese Mengenoperationen können mit einem sogenannten *Venn-Diagramm* veranschaulicht werden, in dem die Ergebnismenge einer Operation entsprechend eingefärbt wird (in diesem Beispiel in Rot):\n\n![Venn-Diagramm der Operationen auf Mengen](media/images/venn/venn-diagramm.png){#fig-venn}\n\nWir können auch in Python mit Mengen rechnen (wir beschränken uns dabei auf ganze Zahlen).\nDazu müssen wir die Zahlen, die zu einer Menge gehören sollen, in einem Datentyp `set`  zusammenfassen, der weitgehend unserem Mengenbegriff entpricht.\nDa alle Schlüsselwörter in Python (und damit auch die Bezeichnungen der Datentypen) in englischer Sprache angegeben werden, verwenden wir in diesem Tutorial ausschließlich die englischen Bezeichnungen.\n\n::: {#a2ea8e26 .cell execution_count=2}\n``` {.python .cell-code}\nA = {1,2,3}                         # <1>\nB = set()                           # <2>\nassert (len(A), len(B)) == (3, 0)   # <3>\n```\n:::\n\n\n1. Definition eines `set` A mit Mengenklammern\n2. Definition eines leeren `set` B\n3. Die Anzahl der Elemente eines `set` (auch die Kardinalität einer Menge genannt) wird mit der Funktion `len()` berechnet.\nWir haben hier auf der linken und rechten Seite des `==` jeweils zwei Werte zu einem sogenannten `tuple` zusammengeführt, einem anderen Datentyp, bei dem die Elemente in runden Klammern angegeben werden. Auch ein `tuple` kann offensichtlich auf Gleichheit getestet werden.\n\nDer Test auf Mitgliedschaft in einer Menge ($\\in$) wird mit dem Schlüsselwort `in` durchgeführt, das Gegenstück ($\\notin$) mit `not in`, wobei `not` ein sogenannter *Bool'scher Operator* ist, der das gegebene Argument verneint:\n\n::: {#4f47f3f3 .cell execution_count=3}\n``` {.python .cell-code}\nassert 1 in A\nassert 1 not in B\n```\n:::\n\n\nDie beiden anderen Bool'schen Operatoren in Python sind `and` und `or` mit denen wir zwei Wahrheitsaussagen verknüpfen können:\n\n::: {#cdcbc10f .cell execution_count=4}\n``` {.python .cell-code}\nassert (1 in A) or (1 in B)         # <1>\nB.add(1)                            # <2>\nassert (1 in A) and (1 in B)        # <3>\n```\n:::\n\n\n1. Wenn (mindestens) eine der beiden Aussagen wahr ist, dann ist auch die mit `or` verknüpfte Aussage wahr.\n2. Wir fügen dem `set` B das Element 1 hinzu.\n3. Nur wenn beide Aussagen wahr sind, dann ist auch die mit `and` verknüpfte Aussage wahr.\n\nOb ein `set` B eine *echte* Teilmenge vom `set` A ist ($B\\subset A$), kann mit dem Operator `B < A` getstet werden. Das ist dann gleichbedeutend mit `A > B`, d.h. A ist die *Obermenge* von B:\n\n::: {#a396ce5e .cell execution_count=5}\n``` {.python .cell-code}\nassert B < A\nassert A > B\n```\n:::\n\n\nUnd schließlich können wir auch die Mengenoperationen auf `set` A und B ausführen:\n\n::: {#c4e27ba5 .cell execution_count=6}\n``` {.python .cell-code}\nB.add(-1)\nprint(\"A = \", A)\nprint(\"B = \", B)\n\n# Vereinigungsmenge A ∪ B\nprint(\"A ∪ B = \", A.union(B))\nassert A.union(B) == A | B\n\n# Schnittmenge A ∩ B\nprint(\"A ∩ B = \", A.intersection(B))\nassert A.intersection(B) == A & B\n\n# Differenz A \\ B\nprint(\"A \\\\ B = \", A.difference(B))\nassert A.difference(B) == A - B\n\n# Symmetrische Differenz A ∆ B\nprint(\"A ∆ B = \", A.symmetric_difference(B))\nassert A.symmetric_difference(B) == A ^ B\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA =  {1, 2, 3}\nB =  {1, -1}\nA ∪ B =  {1, 2, 3, -1}\nA ∩ B =  {1}\nA \\ B =  {2, 3}\nA ∆ B =  {2, 3, -1}\n```\n:::\n:::\n\n\n## Zahlenbereiche\n\nDie Zahlen, mit denen wir rechnen, lassen sich in Teilmengen einteilen, die **Zahlenbereiche** genannt werden und üblicherweise in Mengenschreibweise dargestellt werden.\n\n![Die Zahlenbereiche in Mengendarstellung](media/images/zahlenbereiche/zahlenbereiche.png){#fig-zahlenbereiche}\n\n### Natürliche Zahlen\n\nDie einfachsten Zahlen sind die, mit denen wir als Kind zählen gelernt haben: die Menge der **natürlichen Zahlen**.\nWir benutzen diese Zahlen, um die *Anzahl* von Objekten einer Menge zu bestimmen, also zum *Zählen*.\n\n::: {.callout-important}\n## Natürliche Zahlen\nDie Menge der natürlichen Zahlen sind die ganzen positiven Zahlen:\n$$\n\\mathbb{N} = \\{1,2,3,\\dots\\},\n$$\nwobei die drei Punkte anzeigen, dass die Folge der Zahlen nach dem gegeben Muster fortgeführt wird.\n:::\n\n\n### Ganze Zahlen {#sec-zahlen}\n\n::: {.callout-important}\n## Ganze Zahlen\nDie Menge der ganzen Zahlen ist wie folgt definiert:\n$$\n\\mathbb{Z}=\\{\\dots,-3,-2,-1,0,1,2,3,\\dots\\}\n$$\nDas lässt sich dann unter Verwendung von Eigenschaften so schreiben:\n$$\n\\mathbb{Z}=\\{z \\mid abs(z) \\in \\mathbb{N}\\} \\cup \\{0\\},\n$$\nwobei $abs(z)$ für den absoluten Wert von $z$ steht, also $z$ ohne Vorzeichen.\n:::\n\nEs hat in Europa bis zum Ende des Mittelalters gedauert, bis sich die Verwendung von 0 als Zahl und die Rechnung mit negativen Zahlen durchgesetzt hat.\nDas erscheint auf den ersten Blick verwunderlich, da wir heute ganz selbstverständlich mit negativen Zahlen rechnen.\nFolgender Witz illustriert, was für ein großer intellektueller Schritt das war:\n\n::: {.callout-note}\n## Mathematiker Witz\nStehen ein Theologe, ein Physiker und ein Mathematiker vor einem leeren Raum.\nGemeinsam beobachten sie, wie drei Personen den Raum betreten und kurze Zeit fünf Personen wieder herauskommen.\\\n\"Ein Wunder!\", ruft der Theologe.\\\n\"Muss sich um einen Messfehler handeln\", murmelt der Physiker.\\\nDer Mathematiker entgegnet nur trocken: \"Jetzt müssen nur zwei Leute wieder hineingehen, damit der Raum wieder leer ist\".\n:::\n\nMit der Mengenschreibweise können wir jetzt auch etwas komliziertere Mengen darstellen, zum Beispiel:\n\n::: {.callout-tip}\n## Gerade und ungerade Zahlen\n\n- Menge der geraden natürlichen Zahlen: $\\{2n \\mid n \\in \\mathbb{N}\\}$\n- Menge der ungeraden ganzen Zahlen: $\\{2z-1 \\mid z \\in \\mathbb{Z}\\}$\n:::\n\nSolche Zahlenmengen lassen sich auch in Python mit sogenannten *set comprehensions* erstellen, die eng an die mathematische Schreibweise von Mengen angelehnt sind:\n\n::: {#c05976ff .cell execution_count=7}\n``` {.python .cell-code}\n# Menge der geraden natürlichen Zahlen bis 20\nN = {1,2,3,4,5,6,7,8,9,10}\n{2*n for n in N}\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n{2, 4, 6, 8, 10, 12, 14, 16, 18, 20}\n```\n:::\n:::\n\n\nHier haben wir gegenüber der mathematischen Notation lediglich den vertikalen Strich $\\mid$ durch das Schlüsselwort `for` ersetzt, und die Menge der natürlichen Zahlen, für die die Anweisung gelten soll, zuvor explizit als `set` definiert.\n\nNatürlich ist es etwas umständlich, die Elemente der Ausgangsmenge konkret aufzuzählen; Python bieter daher eine `range()` Funktion an, die zwei ganze Zahlen als Argumente akzeptiert und daraus ein Intervall berechnet, das als Ausgangsmenge dienen kann: \n\n::: {#489913e9 .cell execution_count=8}\n``` {.python .cell-code}\n# Menge der ungeraden Zahlen im Intervall [-5, 17)\n{2*z-1 for z in range(-2, 9)}\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n{-5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15}\n```\n:::\n:::\n\n\nUm zu verstehen was hier passiert, müssen wir uns mit der Intervallschreibweise von Zahlenmengen vertraut machen:\n\n::: {.callout-important}\n## Intervalle\nZahlenmengen können mit Hilfe von Intervallen beschrieben werden.\nWenn die Intervallgrenzen mit den ganzen Zahlen $a,b$ angegeben werden, dann besteht ein Intervall aus allen ganzen Zahlen $x$, die zwischen diesen Grenzen liegen.\nFür so beschränkte Intervalle gelten folgende Regeln:\n\n- $[a,b]= \\{x \\mid x \\in \\mathbb{Z} \\ \\mathrm{und} \\ a \\leq x \\leq b\\}$ (geschlossenes Intervall)\n- $(a,b)= \\{x \\mid x \\in \\mathbb{Z} \\ \\mathrm{und} \\ a < x < b\\}$ (offenes Intervall)\n:::\n\nEckige Klammern $[]$ bedeuten also, dass der jeweilige Begrenzer mit zur Menge gehört, runde Klammern $()$dagegen, dass der Begrenzer nicht mehr zur Menge gehört.\nIn Python erzeugt der Aufruf von `range(a, b)` immer ein halboffenes Intervall in der Form $[a, b)$, so dass also `a` zur Menge gehört, `b` aber nicht.\nDas erklärt, warum im letzten Code-Beispiel das Intervall $[-5, 17)$ angegeben wurde, mit dem Ergebnis $\\{-5,-3,\\dots,13,15\\}$, da 17 nicht mehr zum Intervall gehört.\n\nDie Angabe der *range* mit `range(-2, 9)` ist trotzdem etwas verwirrend, liegt aber daran, dass $2\\cdot -2-1=-5$ und $2\\cdot 8-1=15$ ist (die 9 in der `range` gehört nicht mehr zum Intervall und Python wählt den nächstkleineren Wert 8).\\\nUm diese Verwirrung auszuschließen, können wir eine *set comprehension* auch anders definieren, und zwar indem wir die Forderung für *ungerade* als zusätzliche Bedingung formulieren:\n\n::: {#98d67143 .cell execution_count=9}\n``` {.python .cell-code}\n# Menge der ungeraden Zahlen im Intervall [-5, 17)\n{z for z in range(-5, 17) if z % 2 != 0}\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n{-5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15}\n```\n:::\n:::\n\n\nHier haben wir den Modulo Operator `%` verwendet, der den Rest einer [ganzzahligen Division](2-teiler.qmd#sec-division) ausgibt, um zu testen, ob `z` eine ungerade Zahl ist.\n\n### Rationale Zahlen\n\nEine **rationale Zahl** ist eine Zahl, die als Verhältnis (lateinisch *ratio*) zweier ganzer Zahlen dargestellt werden kann.\nUm die Menge aller rationalen Zahlen zu bezeichnen, wird das Zeichen $\\mathbb{Q}$ verwendet (von *Quotient*).\n$\\mathbb{Q}$ umfasst alle Zahlen, die sich als Bruch darstellen lassen, der sowohl im Zähler als auch im Nenner ganze Zahlen enthält.\n\n::: {.callout-important}\n## Rationale Zahlen\nDie Menge der rationalen Zahlen ist wie folgt definiert:\n$$\n\\mathbb{Q}=\\left\\{\\frac{m}{n} \\mid m, n \\in \\mathbb{Z}, n \\neq 0\\right\\}\n$$\n:::\n\nDer Nenner darf dabei nicht Null sein, da die Division durch 0 nicht definiert ist.\nWir werden im Rahmen der Lektion [Bruchrechnung]() näher auf das Rechnen mit Brüchen und damit auf das Rechnen mit rationalen Zahlen eingehen.\n\nJede rationale Zahl kann als endlicher oder unendlich periodischer Dezimalbruch dargestellt werden.\n\n::: {.callout-note}\n## Dezimalbruch\nDer Dezimalbruch einer rationalen Zahl ist die Darstellung der rationalen Zahl als Dezimalzahl, aslo als Zahl mit Stellen hinter dem Komma.\nBei einem endlichen Dezimalbruch ist die Anzahl der Stellen hinter dem Komma endlich, bei einem periodischen Dezimalbruch wiederholen sich die Stellen nach dem Komma nach einem gewissen Muster (Periode).\n:::\n\n::: {.callout-tip}\n## Beispiele für Dezimalbrüche\n\n- $\\frac{3}{2}=1,5$\n- $-\\frac{1}{8}=-0,125$\n- $\\frac{4}{3}=1,33333=1,\\overline{3}$ (der periodische Teil wird überstrichen)\n- $-\\frac{16}{11}=-1,454545=-1,\\overline{45}$\n:::\n\nIn Python erzeugt der Divisionsoperator `/` eine Dezimalzahl, die hier allerdings *floating point number* genannt wird und dem Datentyp `float` zugeordnet ist.\nBeachte den **point** in der englischen Bezeichnung: das deutsche *Dezimalkomma* wird zum *Dezimalpunkt* im gesamten englischen Sprachraum: $1,5 (de)= 1.5(en)$.\n\n::: {#0344997d .cell execution_count=10}\n``` {.python .cell-code}\nprint(\"3/2 =\", 3 / 2)\nprint(\"-1/8 =\", -1 / 8)\nprint(\"4/3 =\", 4 / 3)\n\n# eine periodische Darstellung ist nicht möglich, aber wir können runden\nprint(\"-16/11 =\", round(-16/11, 2)) # runden auf 2 Stellen nach dem Punkt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3/2 = 1.5\n-1/8 = -0.125\n4/3 = 1.3333333333333333\n-16/11 = -1.45\n```\n:::\n:::\n\n\n### Reelle Zahlen\n\nDie Menge der **reellen Zahlen** erweitert den Zahlenbereich der *rationalen Zahlen* um die **irrationalen Zahlen**, also Zahlen, die sich nicht als Bruch zweier ganzer Zahlen darstellen lassen, und damit auch nicht als endliche oder periodische Dezimalzahl.\nDie Menge der reellen Zahlen wird mit $\\mathbb{R}$ bezeichnet.\n\n::: {.callout-important}\n## Irrationale Zahlen\nAls irrationale Zahlen bezeichnen wir die Menge aller Elemente von $\\mathbb{R}$, die nicht in $\\mathbb{Q}$ liegen:\n$$\n\\mathrm{irrationale \\ Zahlen:} \\quad \\mathbb{R} \\ \\backslash \\ \\mathbb{Q}\n$$\n:::\n\nIn der Antike hatten die *Pythagoräer* (die Schüler des berühmten Mathematikers *Pythagoras*) angenommen, dass sich alles im Universum mit rationalen Zahlen darstellen lässt.\nBetrachtet man aber ein Quadrat der Seitenlänge eins, so sollte die Länge $x$ von dessen Diagonale, folgend dem *Satz des Pythagoras*, die Gleichung $x^2 = 2$ erfüllen, und damit $x=\\sqrt{2}$.\\\nAus rein geometrischen Überlegungen sollte es also eine Zahl geben, die diese Darstellung besitzt.\nTragischerweise hat ausgerechnet *Hippasos*, ein Schüler des *Pythagoras*, mit Hilfe dessen Satzes bewiesen, dass $\\sqrt{2}$ keine rationale Zahl sein kann. (siehe ???).\n\nDie erste bekannte irrationale Zahl ist also $\\sqrt{2}$; aus der Wurzelrechnung ??? folgt aber, dass es noch unendlich viele weitere solcher irrationaler Zahlen gibt, die auch als *algebraische* irrationale Zahlen bezeichnet werden.\\\n*Algebraisch* deshalb, weil sie als Lösung einer \"gewöhnlichen\" algebraischen Gleichung angegben werden können, zum Beispiel ist $\\sqrt{5}$ die Lösung der Gleichung $x^2=5$.\n\nEs gibt aber auch irrationale Zahlen, die nicht als Lösung einer algebraischen Gleichung angegeben werden können, man sagt, sie \"übersteigen\" (*transzendieren*) die Möglichkeiten der Algebra, und nennt sie daher *transzendente Zahlen*.\nDie bekanntesten dieser *transzendenten* Zahlen sind die Kreiszahl $\\pi$ und die eulersche Zahl $e$.\n\nDie Zahlen in $\\mathbb{R}$ können in einer *Zahlengeraden* veranschaulicht werden, die verdeutlicht, dass die Menge der reelen Zahlen über die Vergleiche $< \\mathrm{und}>$ eine *lineare Ordnung* bildet.\nDas beudeutet, dass wir für zwei verschiedene reelle Zahlen immer sagen können, welche von beiden größer bzw. kleiner ist:\n\n![Ausschnitt der Zahlengeraden der reellen Zahlen](media/images/zahlengerade/zahlengerade.png){#fig-gerade}\n\nInfolge dieser *linearen Ordung* sind Intervalle (siehe @sec-zahlen) auch in $\\mathbb{R}$ eindeutig definiert, z.B. enthält das Intervall $(e, \\pi)$ alle reellen Zahlen, die größer als $e$ und kleiner als $\\pi$ sind.\n\n## Zahlensysteme\n\nEs gibt verschiedene Möglichkeiten zur Darstellung von *Zahlen*.\nDie einzelnen Zeichen zur Darstellung von Zahlen sind die *Ziffern*.\nGrundsätzlich unterscheidet man zwischen sogenannten Positionssystemen und Additionssystemen.\n\n::: {.callout-note}\n## Positions- und Additionssysteme\nBei einem *Positionssystem* (auch *Stellenwertsystem* genannt) ist der Wert einer Ziffer abhängig von der *Position* dieser Ziffer innerhalb der Zahl.\\\nBei *Additionssystemen* wird der Wert aller Ziffern einfach addiert, um den Wert der Zahl festzulegen.\n:::\n\n### Römische Zahlen\n\n**Römische Zahlen** sind ein Beispiel eines Additionssytems.\nDie Ziffern sind hier lateinische Großbuchstaben, denen ein fester Wert zugewiesen wird:\n\n| Buchstabe | `I` | `V` | `X`  | `L`  | `C`   | `D`   | `M`  |\n|-----------+-----+-----+------+------+-------+-------+------|\n| Wert      | 1   | 5   | 10   | 50   | 100   |   500 | 1000 |\n: Römische Ziffern {#tbl-ziffern}\n\nDa die Werte der Ziffern bei einem Additionssystem einfach zusammengezählt werden, ist z.B. der Wert der römischen Zahl `XVII` gleich 17.\n\n::: {.callout-note}\n## Subtraktionsregel\nDie Subtraktionsregel ist eine übliche, verkürzende Schreibweise, mit der vermieden wird, vier gleiche Ziffern in direkter Aufeinanderfolge zu schreiben.\\\nDie Subtraktionsregel besagt, dass die Ziffern `I`, `X` und `C` einer ihrer beiden jeweils nächstgrößeren Ziffern vorangestellt werden dürfen und dann in ihrem Zahlwert von dessen Wert abzuziehen sind:\n\n- `I` vor `V` oder `X`: `IV` = 4, `IX` = 9\n- `X` vor `L` oder `C`: `XL` = 40, `XC` = 90\n- `C` vor `D` oder `M`: `CD` = 400, `CM` = 900\n:::\n\n::: {.callout-tip}\n## Der Wert der römischen Zahl `MCMLXXXIV`\n`MCMLXXXIV` = $1000+(1000-100)+50+(3\\cdot10)+(5-1)=1984$\n:::\n\nDas Rechnen mit römischen Zahlen ist allerdings recht schwierig; hierfür wurden Hilfsmittel wie das [Rechenbrett](https://de.wikipedia.org/wiki/Rechnen_auf_Linien) und der [Abakus](https://de.wikipedia.org/wiki/Abakus_(Rechenhilfsmittel)) verwendet.\nDabei werden die römischen Zahlen in ein Positionssystem überführt und Werten in der Form von Rechenmünzen oder Kugeln zugeordnet, mit denen dann die Rechenoperationen durchgeführt werden.\nDas Rechnen mit Rechenbrett und Abakus war bis zum Ende des Mittelalters weit verbreitet und wurde erst durch die Einführung der indischen Zahlenschrift und des heute gebräuchlichen Dezimalsystems (siehe @sec-dezimal) abgelöst.\n\nWir wollen aber nicht mit dem Abakus rechnen, sondern mit Python; dazu entwickeln wir eine Funktion, die römische Zahlen in das Dezimalsystem überführt.\nAls ersten Schritt definieren wir hierzu ein *dictionary*, ein Objekt mit dem Datentyp `dict`:\n\n::: {#81aa7744 .cell execution_count=11}\n``` {.python .cell-code}\nrom = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n```\n:::\n\n\nEin `dict` ist ein Objekt, dessen Elemente sogenannte *key-value pairs* sind, also Paare von Schlüsseln und zugehörigen Werten.\nDiese Paare werden in Mengenklammern geschrieben und mit einem Komma voneinander getrennt.\nEin einzelnes Paar wird dabei in Form `k: v` geschrieben, also Schlüssel, gefolgt von Doppelpunkt, gefolgt von zugeordnetem Wert.\nDas Leerzeichen ist optional und kann weggelassen werden.\nWir haben unser *dictionary* `rom` mit den Werten aus @tbl-ziffern initialisiert.\n\nDie Elemente können dann in einer `for` Schleife durchlaufen und ausgegeben oder manipuliert werden:\n\n::: {#1fc748d1 .cell execution_count=12}\n``` {.python .cell-code}\nfor (k, v) in rom.items():\n  print(\"Schlüssel: \", k, \", \",\"Wert: \", v)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSchlüssel:  I ,  Wert:  1\nSchlüssel:  V ,  Wert:  5\nSchlüssel:  X ,  Wert:  10\nSchlüssel:  L ,  Wert:  50\nSchlüssel:  C ,  Wert:  100\nSchlüssel:  D ,  Wert:  500\nSchlüssel:  M ,  Wert:  1000\n```\n:::\n:::\n\n\nDamit können wir dann die eigentliche Funktion definieren:\n\n::: {#843e6f77 .cell execution_count=13}\n``` {.python .cell-code}\ndef roman_to_decimal(roman):                        # <1>\n  res = 0                                           # <2>\n  for i in range(len(roman)):                       # <3>\n    if i > 0 and rom[roman[i]] > rom[roman[i-1]]:   # <4>\n      res += rom[roman[i]] - 2 * rom[roman[i-1]]    # <5>\n    else:\n      res += rom[roman[i]]                          # <6>\n  return res                                        # <7>\n\nassert roman_to_decimal(\"MCMLXXXIV\") == 1984\n```\n:::\n\n\n1. Signatur der Funktion `roman_to_decimal`.\nWir könnten die Bezeichner in Python auch in Deutsch angeben.\nUm nicht deutschsprachigen Entwicklern aber die Möglichkeit zu geben, unsere Programme zu verstehen, verwenden wie lieber aussagekräftige englische Bezeichner.\nDer Python Konvention folgend, verwenden wir dabei für zusammengesetzte Wörter die sogenannte *snake case* Schreibweise, bei der die einzelnen Worte mit Unterstich verbunden werden.\n2. Initialisierung des Ergebnisses mit `0`. Wir verwenden hier den Bezeichner `res`, als Kurzform des englischen *result*.\n3. Beginn der `for` Schleife: wenn wir uns in der Schleife auf den Index des zu durchlaufenden Objekts beziehen (also auf die Position des aktuellen Wertes in dem Objekt), dann bezeichen wir die Schleifenvariable meist mit `i`.\nDas zu durchlaufende Objekt ist in diesem Fall eine `range`, also ein Intervall.\nWenn die `range()` Funktion mit nur einem Argument $a$ aufgerufen wird (hier die Länge der Zeichenkette (engl. *string*) `roman`), dann erzeugt Python ein Intervall $[0, a)$.\n4. Wir testen, ob der Wert der aktuellen Ziffer größer ist als der Wert der vorhergehenden Ziffer. In diesem Fall müssen wir die Subtraktionsregel anwenden. Der Test wird nicht für die erste Ziffer durchgeführt.\n5. Wenn die Subtraktionsregel greift, dann ziehen wir zweimal den Wert der vorhergehenden Ziffer vom bisherigen Resultat ab.\nWir müssen zweimal abziehen, da im vorangehenden Schleifendurchlauf dieser Wert fälschlicherweise addiert statt subtrahiert wurde.\n6. Wenn die Subtraktionsregel nicht greift, dann addieren wir einfach den Wert der aktuellen Ziffer zum bisherigen Ergebnis.\n7. Rückgabe des Ergebnisses als Wert der Funktion.\n\n### Dezimalsystem {#sec-dezimal}\n\nDas **Dezimalsystem** ist ein Positionssystem mit zehn Ziffern (von lateinisch *decem*, zehn) und ist die heute gebräuchliche Darstellung der Zahlen.\nDas Dezimalsystem hat sich aus dem indischen Zahlensystem entwickelt, das bereits ab dem 3. Jahrhundert v. Chr. in Indien in Gebrauch war.\nIm Jahr 628 n. Chr. führte der indische Mathematiker *Brahmagupta* die 0 als vollwertige Ziffer ein.\n\nWir verwenden heute aber nicht indische, sondern arabischen Ziffern. Das liegt daran, das sich das indische Zahlensystem im Mittelalter über den arabischen Sprachraum nach Europa ausgebreitet hat.\nDie Regeln für das Rechnen mit arabischen Zahlen wurden in Europa erstmals von dem italienischen Mathematiker *Leonardo da Pisa* (besser bekannt als *Fibonacci*) beschrieben, die er in seinem \"Rechenbuch\" *Liber abbaci* im Jahr 1201 zusammengefasst hat.\n\nDer Wert einer Ziffer in einer Dezimalzahl ergibt sich durch die Position der Ziffer innerhalb der Zahl.\nUm diesen Wert zu bestimmen, multiplizieren wir die Ziffer mit einer Zehnerpotenz $10^i$, wobei $i$ die Position der Ziffer in der Zahl ist.\nBei ganzen Zahlen wird dabei der Einerstelle (die letzte Ziffer ganz rechts in der Zahl) der Wert $i=0$ zugeordnet, der Zehnerstelle der Wert $i=1$, der Hunderterstelle der Wert $i=2$, usw.\nDie sich daraus ergebenden Werte werden dann addiert:\n\n::: {.callout-tip}\n## Berechnung des Wertes einer ganzen Zahl\n$1984 = 4\\cdot10^0+8\\cdot 10^1+9\\cdot10^2+1\\cdot10^3=4+80+900+1000$\n:::\n\nDie Berechnung des Wertes eines Dezimalbruchs (einer Dezimalzahl mit Stellen nach dem Komma) erfolgt analog:\nder Wert einer Ziffer innerhalb der Zahl ergibt sich dadurch, dass die $n$-te Stelle vor dem Komma mit $10^{n-1}$ und die $m$-te Stelle nach dem Komma mit $10^{-m}$ multipliziert wird.\n\n::: {.callout-important}\n## Der Wert einer Dezimalzahl\nIst $a$ eine Zahl mit den Ziffern $a_n,a_{n-1},\\cdots,a_1,a_0$ vor dem Komma und den Ziffern $a_{-1},a_{-2},\\cdots,a_{-m}$ nach dem Komma, dann gilt:\n$$\na=\\sum_{i=-m}^n a_i\\cdot 10^i\n$$ {#eq-dezimalzahl}\nDie Stellen mit $i \\geq 0$ bilden den ganzen Teil, die mit $i<0$ den gebrochenen Teil der Zahl.\n:::\n\n::: {.callout-tip}\n## Berechnung des Wertes einer Dezimalzahl\n$$\n\\begin{align}\n486,25 &= 4\\cdot10^2+8\\cdot10^1+6\\cdot10^0+2\\cdot10^{-1}+5\\cdot10^{-2}\\\\\n&= 400+80+6+0,2+0,05\n\\end{align}\n$$\n:::\n\nAus diesem gleichförmigen Aufbau der Dezimalzahlen ergeben sich dann die einfachen Rechenoperationen, die wir schon aus der Grundschule kennen.\nZum Beispiel können wir Dezimalzahlen addieren, indem wir ihre jeweiligen Dezimalstellen addieren und bei einem Ergbnis $\\geq 10$ die $1$ auf die nächste Stelle übertragen:\n\n::: {#fig-addition}\n\n{{< video media/videos/addition/480p15/addition.mp4 >}}\n\n\nAddition mit Übertrag\n:::\n\nHier sehen wir auch die besondere Rolle der $0$: obwohl sie selbst keinen Wert besitzt, ist sie doch als Platzhalter in einem Positionssystem unentbehrlich.\n\n### Dualsystem\n\nDas **Dualsystem** ist ein Positionssystem zur Basis 2, es gibt also nur zwei Ziffern $0,1$.\nEs wird deshalb auch *Binärsystem* oder *Zweiersystem* genannt.\n\nDas Dualsystem spielt eine entscheidende Rolle in der Digitaltechnik, in der Zahlen durch elektrische Zustände dargestellt werden.\nIn einem elektronischen Schaltkreis gibt es nur zwei Zustände: entweder es liegt ein Signal vor (Strom an), oder eben nicht (Strom aus).\nDiese Zustände werden zu Binärzahlen kombiniert, mit denen dann ein Computer \"rechnet\".\\\n*Informatiker* (Menschen, die Computerwissenschaften studiert haben) erzählen sich gerne folgenden Witz:\n\n::: {.callout-note}\n## Informatiker Witz\nEs gibt 10 Arten von Menschen:\n\n- diejenigen, die das Binärsystem verstanden haben\n- diejenigen, die es *nicht* verstanden haben\n:::\n\nWenn du darüber lachen kannst, dann hast du es verstanden.\n\nAuch Python rechnet intern mit Binärzahlen, d.h. jede Eingabe von Dezimalzahlen wird in Binärzahlen umgewandelt, mit denen die notwendigen Berechnungen durchgeführt werden.\nBei der Ausgabe des Ergebnisses werden diese Binärzahlen dann wieder zurück ins Dezimalsystem konvertiert.\n\nDieser Vorgang ist für den Anwender *transparent*, d.h. wir als Programmierer merken nichts von der internen Umwandlung.\nFür die Berechnung des Wertes einer ganzen Binärzahl gelten die Regeln aus @sec-dezimal analog, nur dass wir jede Ziffer nun mit einer Zweierpotenz $2^i$ multiplizieren; jede Ziffer hat dann den doppelten Stellenwert der ihr rechts folgenden Ziffer:\n\n::: {.callout-tip}\n## Berechnung des Wertes einer Dualzahl\n$$\n\\begin{align}\n0100\\ 1101_2&=0\\cdot2^7+1\\cdot2^6+0\\cdot2^5+0\\cdot2^4+1\\cdot2^3+1\\cdot2^2+0\\cdot2^1+1\\cdot2^0\\\\\n&=0+64+0+0+8+4+0+1=77_{10}\n\\end{align}\n$$\n:::\n\nWerden mehrere Zahlensysteme gleichzeitig benutzt, so ist es zur Vermeidung von Irrtümern üblich, die Basis als Index anzuhängen.\nDualzahlen stellen wir zur besseren Lesbarkeit in Vierer-Blöcken dar.\n\nDie Berechnung reeller Zahlen im Dualsystem erfolgt analog zu @eq-dezimalzahl.\nDer Wert einer Ziffer im Dualsytem (engl. *bit*, als Kurzform für *binary digit*) ergibt sich dadurch, dass die $n$-te Stelle mit $2^{n-1}$ und die $m$-te Stelle nach dem Komma mit $2^{-m}$ multipliziert wird:\n\n::: {.callout-important}\n## Der Wert einer Dualzahl\n$$\nb=\\sum_{i=-m}^n b_i\\cdot 2^i\n$$ {#eq-dualzahl}\n:::\n\n::: {.callout-tip}\n## Berechnung einer reellen Zahl im Dualsystem\n$$\n\\begin{align}\n1011,01_2&=1\\cdot2^3+0\\cdot2^2+1\\cdot2^1+1\\cdot2^0+0\\cdot2^{-1}+1\\cdot2^{-2}\\\\\n&=8+2+1+\\frac{1}{4}=11,25_{10}\n\\end{align}\n$$\n:::\n\nMit der Berechnung des Wertes einer Dualzahl haben wir diese Zahl in eine Dezimalzahl umgerechnet; dies wird auch als *Konvertierung* bezeichnet.\nMit diesen Regeln können wir jetzt eine Dualzahl mit Python in eine Dezimalzahl konvertieren:\n\n::: {#d135f2d6 .cell execution_count=14}\n``` {.python .cell-code}\ndef bin_to_dec(binary):\n  assert type(binary) == str            # <1>\n  s = binary.split(',')                 # <2>\n  n = len(s[0])                         # <3>\n  m = 1\n  decimal = 0\n  for bit in s[0]:                      # <4>\n    decimal += int(bit) * 2**(n-1)\n    n -= 1\n  for bit in s[1]:                      # <5>\n    decimal += int(bit) * 2**(-m)\n    m += 1\n  return decimal\n\nassert bin_to_dec(\"1011,01\") == 11.25\n```\n:::\n\n\n1. Wir erwarten, dass die Funktion mit einem Argument vom Typ `str` (also einer Zeichenkette) aufgerufen wird.\nWenn nicht, dann ergeben die nachfolgenden Berechnungen keinen Sinn, und wir brechen das Programm ab.\n2. Teilen des Eingabestrings in zwei Hälften, den Teil vor dem Komma und den Teil nach dem Komma.\nDas Ergebnis ist eine Liste mit zwei Teilstrings.\n3. Belegen der Variablen `n` mit der Länge des ersten Teilstrings (zur Erinnerung: der Index in Python beginnt mit 0).\n4. Wir durchlaufen die Zeichen im ersten Teilstring (die Ziffern vor dem Komma) und berechnen den Wert der jeweiligen Ziffer nach der Formel von @eq-dualzahl.\nDie Schleifenvariable haben wir hier `bit` genannt.\nNach jedem Durchlauf verringern wir den Wert von `n` um 1.\n5. Berechnung der Werte für die *bits* nach dem Komma.\nHier erhöhen wir den Wert von `m` nach jedem Durchlauf um 1.\n\nFür das Rechnen mit Binärzahlen stellt Python sogenannte *bitwise operations* bereit:\n\n| Operation | Ergebnis                                     |\n|:---------:|:-------------------------------------------- |\n| `x | y`   | bitwise *or* \\ von `x` und `y`               |\n| `x ^ y`   | bitwise *exclusive or* \\ von `x` und `y`     |\n| `x & y`   | bitwise *and* \\ von `x` und `y`              |\n| `x << n`  | `x` um `n` bits nach links verschoben        |\n| `x >> n`  | `x` um `n` bits nach rechts verschoben       |\n| `~x`      | bitwise *not* \\ : die bits von `x` umgekehrt |\n\nBinärzahlen werden in der Regel zu Einheiten von acht *bits* zusammengefasst, die wir dann *byte* nennen.\nWenn wir ein *byte* in der Form $b=b_7 \\ b_6 \\ b_5 \\ b_4 \\ b_3 \\ b_2 \\ b_1 \\ b_0$ darstellen, dann können wir die *bitwise operations* als Mengenoperationen (siehe @sec-mengen) auf *bytes* begreifen, indem wir jedes gesetzte *bit* über seinen Index darstellen:\n\n::: {#b5815449 .cell execution_count=15}\n``` {.python .cell-code}\nx = 0b10000010                                   # <1>\ny = 0b10010000\nprint(f\"x = {x:#0b}\", \"= {7, 1}\")                # <2>\nprint(f\"y = {y:#0b}\", \"= {7, 4}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx = 0b10000010 = {7, 1}\ny = 0b10010000 = {7, 4}\n```\n:::\n:::\n\n\n1. Definition von `x` als Binärzahl: wir verwenden hierzu das Präfix `0b`.\n2. Ausgabe von `x` im Binärformat und der Menge der gesetzten Indizes, das sind die Stellen der Binärzahl, an denen ein *bit* auf 1 gesetzt ist. Wir verwenden hierzu einen sogenannten `f-string` für engl. *formatted string*.\n\nDie Mengenoperationen können dann so ausgeführt werden:\n\n::: {#152d21f5 .cell execution_count=16}\n``` {.python .cell-code}\n# bitwise or\nprint(f\"Vereinigungsmenge (x|y): {x|y:#0b}\", \"= {7, 4, 1}\")\n\n# bitwise and\nprint(f\"Schnittmenge (x&y): {x&y:#0b}\", \"= {7}\")\n\n# bit clear (and not)\nprint(f\"Differenz (x&~y): {x&~y:#0b}\", \"= {1}\")\n\n# bitwise xor\nprint(f\"Symmetrische Differenz (x^y): {x^y:#0b}\", \"= {4, 1}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVereinigungsmenge (x|y): 0b10010010 = {7, 4, 1}\nSchnittmenge (x&y): 0b10000000 = {7}\nDifferenz (x&~y): 0b10 = {1}\nSymmetrische Differenz (x^y): 0b10010 = {4, 1}\n```\n:::\n:::\n\n\nDie *shift* Operatoren `<<` und `>>` verschieben die *bits* einer Binärzahl um $n$ Stellen nach links bzw. rechts.\nDabei wird die Zahl bei *links-shift* mit `<<` von rechts mit 0-*bits* aufgefüllt, der Wert der Zahl verdoppelt sich also mit jedem *shift*.\nDemnach ist z.B. `x << 3` gleichbedeutend mit $x\\cdot2^3$.\n\n::: {#e673c562 .cell execution_count=17}\n``` {.python .cell-code}\na = 5\nprint(f\"a = {a:#0b} = {a}\")\nb = a << 3\nprint(f\"b = {b:#0b} = {b}\")\nassert b == a * 2**3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na = 0b101 = 5\nb = 0b101000 = 40\n```\n:::\n:::\n\n\nBei einem rechts-*shift* mit `x >> n` werden `n` Stellen am rechten Ende von `x` abgeschnitten, der Wert der Zahl halbiert sich also mit jedem *shift*.\nWenn das letzte bit $b_0$ dabei gesetzt ist, die Zahl also ungerade ist, dann geht der Rest der Division durch 2 dabei verloren; es gilt also: `x >> 1` ist gleichbedeutend mit `x // 2`.\n\n::: {#b53bbbfb .cell execution_count=18}\n``` {.python .cell-code}\nprint(f\"a = {a:#0b} = {a}\")\nc = a >> 1\nprint(f\"c = {c:#0b} = {c}\")\nassert c == a // 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na = 0b101 = 5\nc = 0b10 = 2\n```\n:::\n:::\n\n\n## Übungen\n\nDie Übungen dieser Lektion findest du im Notebook `arithmetik/_mengen.ipynb`.\nÖffne diese Datei in *Jupyter* und erforsche des Rechnen mit verschiedenen Zahlensystemen.\n\n",
    "supporting": [
      "3-mengen_files"
    ],
    "filters": [],
    "includes": {}
  }
}