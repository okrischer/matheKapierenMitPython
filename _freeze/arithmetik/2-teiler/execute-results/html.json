{
  "hash": "610e6baad873f3006e085f29f3532565",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Teiler und Vielfache\n---\n\nIn diesem Kapitel machen wir einen kleinen Ausflug in die Welt der Zahlen und beschäftigen uns mit der Teilbarkeit natürlicher Zahlen.\nAußerdem wollen wir unsere ersten Funktionen in Python definieren und einen ersten Algorithmus implementieren.\n\n## Primfaktorzerlegung {#sec-primfaktor}\n\nPrimzahlen spielen in der Mathematik eine erstaunlich große Rolle, wir wollen sie hier aber nur im Rahmen der Teilbarkeit von natürlichen Zahlen betrachten.\n\nEine Primzahl ist eine natürliche Zahl, die genau zwei Teiler hat (und somit größer als 1 ist).\nDiese zwei Teiler sind 1 und die Zahl selber.\nEine Primzahl kann daher nicht als das *Produkt* zweier kleineren Zahlen geschrieben werden, also nicht in *Faktoren* zerlegt werden.\nAlle anderen natürlichen Zahlen können dagegen in *Primfaktoren* zerlegt werden, d.h. sie können als das Produkt von zwei oder mehr Primzahlen geschrieben werden.\n\n::: {.callout-important}\n## Fundamentalsatz der Arithmetik\nJede natürliche Zahl $n>1$ besitzt eine (bis auf die Reihenfolge) eindeutige **Primfakorzerlegung**, d.h. zwei unterschiedliche Zerlegungen unterscheiden sich nur in der Reihenfolge der Faktoren.\n:::\n\n::: {.callout-tip}\n## Beispiele für Primfaktorzerlegungen\n- $30=2\\cdot 3 \\cdot 5$\n- $37=37$ (Primzahl)\n- $1001=7\\cdot 11 \\cdot 13$\n- $1024=\\underbrace{2\\cdots 2}_\\text{10 mal}=2^{10}$ (Zweierpotenz)\n- $6936=2\\cdot 2\\cdot 2\\cdot 3\\cdot 17\\cdot 17=2^3\\cdot 3\\cdot 17^2$\n- $10000=2^4\\cdot 5^4$ (Zehnerpotenz)\n:::\n\nWenn du mit der Potenzdartsellung von Zahlen noch nicht vertraut bist, schaue dir ??? an; dort erhältst du eine Einführung in Potenzrechnung.\n\n::: {.callout-caution}\n## Zwischenübung\nZerlege die Zahlen 12, 60, 128 und 1.000 in ihre Primfaktoren und stelle sie in Potenzen dieser Faktoren dar.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Lösung\n- $12=2\\cdot 2\\cdot 3=2^2\\cdot 3^1$\n- $60=2\\cdot 2\\cdot 3\\cdot 5=2^2\\cdot 3^1\\cdot 5^1$\n- $128=\\underbrace{2\\cdots 2}_\\text{7 mal}=2^7$ (Zweierpotenz)\n- $1.000=2^3\\cdot 5^3=10\\cdot 10\\cdot 10=10^3$ (Zehnerpotenz: die drei Nullen der Ausgangszahl führen zur dritten Potenz von 10)\n:::\n\n\n## Division mit Rest {#sec-division}\n\nWenn zwei natürliche Zahlen, der Dividend $n$, und der Divisor $m$ (ungleich 0) mit Rest dividiert werden sollen, wenn also $n\\div m$ berechnet werden soll, so wird gefragt, wie man die Zahl $n$ als Vielfaches von $m$ und einem Rest darstellen kann:\n\n::: {.callout-important}\n## Division mit Rest\n$$\nn = m \\cdot q + r, \\quad 0 \\leq r < m.\n$$ {#eq-divmitrest}\nHier ist $q$ der sogenannte *Ganzzahlqotient* und $r$ der *Rest* der Division.\nEntscheidende Nebenbedingung ist, dass $r$ eine ganze Zahl größer oder gleich 0 und kleiner $m$ ist.\n:::\n\nDer Rest ist also die Differenz zwischen dem Dividenden $n$ und dem größten Vielfachen des Divisors $m$, das höchstens so groß ist wie der Dividend: $\\ r=n-m\\cdot q$.\\\nEin Rest ungleich 0 ergibt sich folglich genau dann, wenn der Dividend kein Vielfaches des Divisors ist.\nMan sagt auch: Der Dividend ist nicht durch den Divisor teilbar, weshalb ein Rest übrigbleibt.\n\n::: {.callout-tip}\n## Beispiele für Division mit Rest\n- $9 \\div 4 = 2 \\ $ mit Rest $1$, weil $\\ 9=4\\cdot 2 + 1$ (vier passt zweimal in neun und es bleibt eins übrig)\n- $2 \\div 4 = 0 \\ $ mit Rest $2$, weil $\\ 2=4\\cdot 0 + 2$\n- $4 \\div 4 = 1 \\ $ mit Rest $0$, weil $\\ 4=4\\cdot 1 + 0$\n:::\n\n::: {.callout-caution}\n## Zwischenübung\nStelle das Ergebnis der fogenden Divisionen als ganze Zahl mit Rest dar:\n\n- $128\\div 127$\n- $127\\div 128$\n- $777\\div 11$\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Lösung\n- $128\\div 127=1$, Rest 1\n- $127\\div 128=0$, Rest 127\n- $777\\div 11=70$, Rest 7\n:::\n\nMan kann eine Funktion definieren, die jedem Zahlenpaar $(n, m)$ einen eindeutigen Teilerrest $r$ zuordnet. Diese Funktion nennt man *Modulo* und kürzt sie meistens mit *mod* ab.\n\nWir werden uns in späteren Kapiteln ausführlich mit Funktionen beschäftigen (siehe ???);\nohne auf die Details einzugehen, wollen wir an dieser Stelle die Funktion Modulo in Python implementieren, um uns mit der Syntax einer Funktionsdefinition vertraut zu machen.\nVergegenwärtigen wir uns hierzu nochmal die obige Definition des Restes einer ganzzahligen Division:\n$$\nr=n-m\\cdot q,\n$$\nwobei $q$ der ganzzahlige Quotient von $n \\div m$ ist.\n\n::: {#586d9b4f .cell execution_count=1}\n``` {.python .cell-code}\ndef mod(n, m):                  # <1>\n  q = n // m                    # <2>\n  r = n - m * q                 # <3>\n  return r                      # <4>\n\nassert mod(9,4) == 1\nassert mod(2,4) == 2\nassert mod(4,4) == 0\n```\n:::\n\n\n1. Eine Funtionsdefinition wird eingeleitet mit dem Schlüsselwort `def`, gefolgt von den Parametern der Funktion in Klammern und einem Doppelpunkt `:`, der den Beginn eines Code-Blocks signalisiert.\nAlle nachfolgenden Zeilen, die zu diesem Code-Block gehören sollen, werden um die selbe Anzahl von Stellen eingerückt.\n2. Zuweisung des Ergebnisses der ganzzahligen Division $n \\div m$ an den Bezeichner `q`. Wir wählen hier die selben Bezeichner, die wir auch in der mathematischen Definition verwendet haben.\n3. Berechnung des Restes der Division gemäß der mathematischen Definition und Zuweisung an den Bezeichner `r`.\n4. Die Funtion liefert den Rest der Division `r` als ihr Ergebnis zurück.\nDies wird mit dem Schlüsselwort `return` angezeigt.\n\n## Gößter gemeinsamer Teiler {#sec-ggT}\n\nDer **größte gemeinsame Teiler** (*ggT*) ist die größte natürliche Zahl, durch die sich zwei ganze Zahlen jeweils ohne Rest teilen lassen.\nDer *ggT* zweier ganzer Zahlen $a$ und $b$ ist demnach eine ganze Zahl $m$ mit der Eigenschaft, dass sie Teiler sowohl von $a$ als auch von $b$ ist und dass jede ganze Zahl, die ebenfalls die Zahlen $a$ und $b$ teilt, auch Teiler von $m$ ist.\n\nMan kann den *ggT* über die *Primfaktorzerlegung* der beiden gegebenen Zahlen bestimmen.\nWir wollen das einmal exemplarisch für die beiden Zahlen 3528 und 3780 durchführen:\n\n::: {.callout-tip}\n## Primfaktozerlegung für 3528 und 3780\n- $3528=2^3\\cdot 3^2\\cdot 5^0\\cdot 7^2$\n- $3780=2^2\\cdot 3^3\\cdot 5^1\\cdot 7^1$\n:::\n\n::: {#e4de0a78 .cell execution_count=2}\n``` {.python .cell-code}\nassert 2**3 * 3**2 * 5**0 * 7**2 == 3528\nassert 2**2 * 3**3 * 5**1 * 7**1 == 3780\n```\n:::\n\n\nPrimfaktoren, die in einer der beiden Zahlen nicht vorkommen, können wir dabei in der Form $x^0$ darstellen, um einen besseren Überblick über die Faktoren zu erhalten.\n$x^0$ ergibt immer 1, daher hat dieser zusätzliche Faktor keinen Einfluß auf das ensprechende Produkt.\n\nFür den *ggT* nimmt man die Primfaktoren, die in beiden Zerlegungen vorkommen, und als zugehörigen Exponenten den jeweils *kleineren* der Ausgangsexponenten:\n\n::: {.callout-tip}\n## Größter gemeinsamer Teiler für 3528 und 7380\n$ggT(3528, 3780)=2^2\\cdot 3^2\\cdot 5^0\\cdot 7^1=252$\n:::\n\n::: {#4279a874 .cell execution_count=3}\n``` {.python .cell-code}\nassert 2**2 * 3**2 * 5**0 * 7**1 == 252\n```\n:::\n\n\nDie Berechnung der Primfaktorzerlegung großer Zahlen und damit auch die Bestimmung des größten gemeinsamen Teilers über die Primfaktorzerlegungen ist sehr aufwändig.\nMit dem *euklidischen Algorithmus* existiert jedoch auch ein effizientes Verfahren, um den größten gemeinsamen Teiler zweier Zahlen zu berechnen.\n\nUnter einem *Algorithmus* verstehen wir eine detaillierte, schrittweise Rechenvorschrift, in der sich möglichweise einige Schritte wiederholen, die am Ende das gewünschte Resultat ausgibt.\n\n::: {.callout-note}\n## Klassischer euklidischer Algorithmus\nDer *klassische* euklidische Algorithmus berechnet den größten gemeinsamen Teiler, indem er nach einem gemeinsamen Maß für die Längen zweier Linien sucht:\n\n1. Die kleinere zweier Längen wird von der größeren mehrfach abgezogen, bis ein Ergebnis übrig bleibt, das kleiner als die kleinere Länge ist.\n2. Bei einer Differenz von 0 ist man fertig und die kleinere Länge das Ergebnis.\n3. Andernfalls wiederholt man dieses Abziehen – jetzt aber mit der kleineren Länge anstelle der größeren und der letzten Differenz anstelle der kleineren Länge.\n:::\n\n::: {.callout-tip}\n## Berechnung des *ggT* von 143 und 65\n- $143-65=78$\n- $78-65=13, \\quad (<65)$\n- $65-13=52$\n- $52-13=39$\n- $39-13=26$\n- $26-13=13$\n- $13-13=0, \\quad ggT = 13$\n:::\n\n::: {.callout-caution}\n## Zwischenübung\nPrüfe, ob du diese Rechenvorschrift verstanden hast, indem du sie mit den Werten 60 und 24 selbst durchführst.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Lösung\n- $60-24=36$\n- $36-24=12, \\quad (<24)$\n- $24-12=12$\n- $12-12=0, \\quad ggt = 12$\n:::\n\nMit diesem Wissen können wir jetzt den Algorithmus in Python implementieren:\n\n::: {#097a6dc4 .cell execution_count=4}\n``` {.python .cell-code}\ndef euklid_klassisch(a, b):                 # <1>\n  if b > a: a, b = b, a                     # <2>\n  zähler = 1                               # <3>\n  d = a - b                                 # <4>\n  while d > 0:                              # <5>\n    if d < b: a, b = b, d                   # <6>\n    else: a = d                             # <7>\n    d = a - b                               # <8>\n    zähler += 1                            # <9>\n  print(zähler)                            # <10>\n  return b                                  # <11>\n```\n:::\n\n\n1. Definition der Funktion `euklid_klassisch`.\nUm genau zu sein, bezeichen wir diese Zeile als die *Signatur* der Funktion, die den Namen der Funktion und deren Parameter enthält. Der nachfolgende (eingerückte) Code-Block gehört ebenfalls zur Funktionsdefinition.\n2. Wir wollen immer die kleinere von der größeren Länge abziehen.\nDa wir aber nicht wissen, welche der gegebenen Funktionsparameter der größere ist, testen wir das mit `if b > a`: wenn `b` größer ist als `a`, dann vertauschen wir die Parameter.\nAuf diese Weise stellen wir sicher, dass `a` immer die größere Länge bezeichnet.\n3. Diese Zeile ist für den Algorithmus eigentlich nicht notwendig.\nWir wollen aber die Anzahl der durchgeführten Subtraktionen nachverfolgen, um eine Aussage über die Effizienz des Algorithmus machen zu können.\nAlso legen wir einen Zähler an, den wir mit 1 initialisieren, da wir in der folgenden Zeile gleich die erste Subtraktion durchführen.\n4. Bestimmen der ersten Differenz zwischen `a` und `b`. Wir wissen aus (2), dass `a` immer die größere Länge ist.\n5. Der Algorithmus besagt in seinem 1. Schritt, das wir wiederholt die kleinere von der größeren Länge abziehen müssen.\nDaher starten wir eine Programm-Schleife mit dem Schlüsselwort `while` und geben als Schleifenbedingung `d > 0` an.\nDamit werden die Anweisungen in der Schleife solange wiederholt bis die Differenz gleich 0 ist.\nWir wissen aus Schritt 2 des Algorithmus, dass wir dann fertig sind.\n6. Innerhalb der Schleife prüfen wir zuerst, ob die letzte Differenz kleiner ist als die kleinere Länge (`b`). Falls ja, vertauschen wir `a` mit `b`, und `b` mit `d`, so wie in Schritt 3 des Algorithmus gefordert.\n7. Anderenfalls ersetzen wir `a` mit `d`, wie in Schritt 1 des Algorithmus gefordert.\n8. In beiden Fällen berechnen wir schließlich die Differenz der neuen großen und kleinen Länge.\n9. Als letzte Anweisung in der Schleife erhöhen wir den Zähler um 1.\n10. Nach der Schleife geben wir die Gesamtanzahl der durchgeführten Subtraktionen aus.\n11. Die letze Anweisung der Funktion gibt die aktuelle kleinere Länge als Funktionswert zurück.\nGemäß Schritt 2 des Algorithmus ist das unser Ergebnis: der kleinste gemeinsame Teiler von `a` und `b`.\n\n::: {#6f7c1471 .cell execution_count=5}\n``` {.python .cell-code}\nassert euklid_klassisch(143, 65) == 13\nassert euklid_klassisch(3528, 3780) == 252\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n7\n15\n```\n:::\n:::\n\n\nWir sehen, dass es keine Rolle spielt, in welcher Reihenfolge wir die Argumente der Funktion angeben, es wird immer das korrekte Ergebnis ausgegeben.\n\n::: {.callout-note}\n## Parameter und Argumente\nDie Variablen, die wir in der Funktionsdefinition in Klammern angeben, heißen **Parameter** der Funktion. Wenn wir eine Funktion dann mit konkreten Werten aufrufen, nennen wir diese Werte **Argumente** der Funktion. \n:::\n\nWir sehen aber auch, dass die Anzahl der notwendigen Operationen (in diesem Fall Subtraktionen) zunimmt, wenn die Argumente größer werden.\nDies kann bei sehr großen Zahlen zu Effizienzproblemen führen, im schlimmsten Fall dazu, dass die Funktion kein Ergebnis mehr liefert.\nWenn wir Algorithmen in einer Programmiersprache implementieren, wollen wir also auch immer darauf achten, eine möglichst effiziente Lösung zu finden, d.h. eine Lösung, die mit weniger Operationen auskommt.\n\nIn unserem Beispiel `euklid_klassisch(143, 65)` sehen wir, dass die Funktion 7 Subtraktionen für die Berechnung des Ergebnisses benötigt; das stimmt mit unserer manuellen Berechnung überein, die nachfolgend noch einmal angegeben wird:\n\n::: {.callout-tip}\n## Berechnung des *ggT* von 143 und 65\n- $143-65=78$\n- $78-65=13, \\quad (<65)$\n- $65-13=52$\n- $52-13=39$\n- $39-13=26$\n- $26-13=13$\n- $13-13=0, \\quad ggT = 13$\n:::\n\nBei näherer Betrachtung erkennen wir, dass zunächst zweimal `65` von `143` abgezogen wird, und dann fünfmal `13` von `65` abgezogen wird.\nDas ist kein Zufall, denn `65` passt zweimal in `143` und `13` passt fünfmal in `143`, da $2\\cdot 65+rest=143$ und $5\\cdot 13+rest=65$, wobei der Rest im ersten Fall 13 ist und im zweiten Fall 0, d.h. `13` passt *genau* fünfmal in `65`.\nDas erinnert doch sehr an die Division mit Rest aus @sec-division.\n\nAnstatt also $n$-mal `b` von `a` abzuziehen , können wir `a` durch `b` teilen, mit dem Ergebnis $n$ und Rest $r$.\nAm ganzzahligen Quotienten $n$ sind wir gar nicht interessiert, sondern wir können gleich mit dem Rest $r$ weiterrechnen, so wie in den Zeilen 3 bis 7 der manuellen Berechnung (der Rest $r$ ist hier 13).\n\nDiese Überlegungen führen zum sogenannten *modernen euklidischen Algorithmus*:\n\n::: {.callout-note}\n## Moderner euklidischer Algorithmus\nIn den aufeinanderfolgenden Schritten wird jeweils eine Division mit Rest durchgeführt, wobei im nächsten Schritt der Divisor zum neuen Dividenden und der Rest zum neuen Divisor wird.\nDer Divisor, bei dem sich Rest 0 ergibt, ist der größte gemeinsame Teiler der Ausgangszahlen.\n:::\n\nFür unsere Beispielzahlen ergibt sich daraus folgende Berechnung:\n\n::: {.callout-tip}\n## Berechnung des *ggT* nach dem modernen euklidischen Algorithmus\n- $143\\div 65=2, \\quad\\mathrm{Rest} \\ 13$\n- $65\\div 13=5, \\quad\\mathrm{Rest } \\ 0$\n- $ggT(143, 65)=13$\n:::\n\nWir brauchen also nur zwei Schritte zur Berechnung des *ggT* mit dem modernen Algorithmus, genauso wie für unser Beispiel aus der Primfaktorzerlegung:\n\n::: {.callout-caution}\n## Zwischenübung\nFühre die Berechnung des *ggT* für die Werte 3780 und 3528 gemäß dem letzten Beispiel durch.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Lösung\n- $3780\\div 3528=1, \\quad\\mathrm{Rest} \\ 252$\n- $3528\\div 252=14, \\quad\\mathrm{Rest} \\ 0$\n- $ggT(3780, 3528)=252$\n:::\n\nMit diesem Wissen können wir den modernen euklidischen Algorithmus in Python implementieren:\n\n::: {#a3086c19 .cell execution_count=6}\n``` {.python .cell-code}\ndef euklid_modern(a, b):\n  zähler = 0\n  while b != 0:           # <1>\n    r = mod(a, b)         # <2>\n    a = b                 # <3>\n    b = r                 # <4>\n    zähler += 1\n  print(zähler)\n  return a                # <5>\n```\n:::\n\n\n1. Beginn der Programmschleife mit Schleifenbedingung `b != 0`; die Schleife wird also ausgeführt, solange `b` nicht 0 ist.\n2. Wir führen eine Division mit Rest aus und verwenden dafür unsere `mod()` Funktion aus @sec-division.\n3. Dann machen wir den Divisor zum neuen Dividenden...\n4. und den Rest der Division `r` zum neuen Divisor.\n5. Eigentlich sollten wir den letzten Divisor `b` als Ergebnis ausgeben, wenn `mod(a, b)` gleich 0 ist.\nDa dieser Test aber erst vor dem nächsten Schleifendurchlauf durchgeführt wird (1), wird im letzten Durchlauf nochmal `a = b` (2) und `b = r` (3) gesetzt.\nDas führt dazu, dass nach Beendigung der Schleife `b` immer gleich 0 ist; wir müssen also `a` als letzten Divisor ausgeben.\n\n::: {#8d38fb57 .cell execution_count=7}\n``` {.python .cell-code}\nassert euklid_modern(143, 65) == 13\nassert euklid_modern(3780, 3528) == 252\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n2\n```\n:::\n:::\n\n\nAufgrund der Möglichkeit, in Python mehrere Zuweisungen gleichzeitig vorzunehmen, indem wir die Bezeichner und die zugewiesen Werte jeweils mit einem Komma trennen, hätten wir den kompletten Algorithmus der Zeilen (2) bis (4) auch in eine Zeile schreiben können:\\\n`a, b = b, mod(a, b)`.\n\nAuch bei dieser Implementierung spielt die Reihenfolge der Argumente keine Rolle:\n\n::: {#69b5b0c1 .cell execution_count=8}\n``` {.python .cell-code}\nassert euklid_modern(143, 65) == euklid_modern(65, 143)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n3\n```\n:::\n:::\n\n\nWir sehen aber, dass eine zusätzliche Operation notwendig wird, wenn das kleinere Argument zuerst kommt.\nDas liegt daran, dass $65 \\div 143$ gleich 0, mit Rest 65 ist, d.h. beim nächsten Schleifendurchlauf wird `mod(143, 65)` aufgerufen, die Variante mit dem größeren Argument zuerst.\nDie zusätzliche Operation können wir aus Effizienzsicht gut verkraften, da wir uns ja den Test auf `b > a` sparen.\n\nDer *ggT* wird häufig auch als *rekursive* Funktion realisiert.\nWir werden [Rekursion](5-rekursion.qmd) in einer späteren Lektion ausführlich behandeln; ich möchte die Implementierung eines rekursiven *ggT* hier aber schon als kleinen Vorgeschmack vorstellen:\n\n::: {#fe08ae59 .cell execution_count=9}\n``` {.python .cell-code}\ndef ggT(a, b):\n  if b == 0:                    # <1>\n    return a                    # <2>\n  else:\n    return ggT(b, mod(a, b))    # <3>\n```\n:::\n\n\n1. Abbruchbedingung: wenn `b` gleich 0 ist, dann wird die Rekursion gestoppt.\n2. Wenn die Abbruchbedingung greift, geben wir `a` als Ergebnis der Berechnung aus, und der Programmablauf ist beendet.\n3. Rekursiver Aufruf: die Funktion ruft sich selbst mit neuen Argumenten auf.\nDie Argumente werden entsprechend dem Algorithmus gesetzt:\nder Divisor wird zum neuen Dividenden und der Rest zum neuen Divisor.\n\n::: {#5afd59ed .cell execution_count=10}\n``` {.python .cell-code}\nassert ggT(143, 65) == 13\nassert ggT(3780, 3528) == 252\n```\n:::\n\n\nDie *rekursive* Implementierung kommt ohne zusätzliche Variablen aus, und wir benötigen auch keine explizite Schleife, da diese durch den rekursiven Aufruf ersetzt wird.\nDas kann zu einem sehr übesichtlichen und eleganten Programm führen, dessen Bedeutung sich dem Leser sofort erschließt.\nViele erfahrene Programmierer bevorzugen daher eine rekursive Implementierung.\n\nAuf der anderen Seite ist es nicht immer sofort ersichtlich, wie eine *iterative* Implementierung (d.h. eine Implementierung mit Schleifen) in eine rekursive Variante überführt werden kann.\nDazu bedarf es einiger Erfahrung; ich erwarte nicht, dass du jetzt bereits eigene rekursive Programme schreiben kannst.\n\n\n## Kleinstes gemeinsames Vielfaches\n### Das *kgV* von zwei Zahlen\n\nDas **kleinste gemeinsame Vielfache** (*kgV*) zweier ganzer Zahlen $m$ und $n$ ist die kleinste positive natürliche Zahl, die sowohl Vielfaches von $m$ als auch Vielfaches von $n$ ist.\nZusätzlich wird für den Fall $m = 0$ oder $n = 0$ das *kgV* definiert als: $kgV ⁡(m, n) = 0$.\n\n::: {.callout-tip}\n## Berechnung des *kgV* von 12 und 18 über die Vielfachen\n- Die Vielfachen von 12 sind: 12, 24, 36, 48, 60, 72, 84, 96, 108,... \n- Die Vielfachen von 18 sind: 18, 36, 54, 72, 90, 108, ...\n- Die gemeinsamen Vielfachen von 12 und 18 sind also: 36, 72, 108, ...\n- und das kleinste von diesen ist 36: $kgV(12, 18)=36$.\n:::\n\nMan kann das *kgV* über die Primfaktorzerlegung (siehe @sec-primfaktor) der beiden gegebenen Zahlen bestimmen.\nWir nehmen hierzu wieder das Beispiel aus @sec-division:\n\n::: {.callout-tip}\n## Primfaktozerlegung für 3528 und 3780\n- $3528=2^3\\cdot 3^2\\cdot 7^2$\n- $3780=2^2\\cdot 3^3\\cdot 5^1\\cdot 7^1$\n:::\n\nFür das *kgV* nimmt man die Primfaktoren, die in mindestens einer der beiden Zerlegungen vorkommen, und als zugehörigen Exponenten den jeweils *größeren* der Ausgangsexponenten:\n\n::: {.callout-tip}\n## Kleinstes gemeinsames Vielfaches für 3528 und 7380\n$kgV(3528, 3780)=2^3\\cdot 3^3\\cdot 5^1\\cdot 7^2=52.920$\n:::\n\n::: {#2843f8a9 .cell execution_count=11}\n``` {.python .cell-code}\nassert 2**3 * 3**3 * 5**1 * 7**2 == 52920\n```\n:::\n\n\n::: {.callout-caution}\n## Zwischenübung\nBestimme das *kgV* von 60 und 24 über die Primfaktorzerlegung.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Lösung\n- $60=2^2\\cdot 3^1\\cdot 5^1$\n- $24=2^3\\cdot 3^1\\cdot 5^0$\n- $kgV(60, 24)=2^3\\cdot 3^1\\cdot 5^1=120$\n:::\n\n\nMan kann das *kgV* aber auch mit Hilfe des *ggT* berechnen; es gilt der folgende Grundsatz:\n\n::: {.callout-important}\n## Produkt von *ggT* und *kgV*\nDas Produkt des *ggT* und des *kgV* zweier natürlicher Zahlen ist gleich dem Produkt beider Zahlen: \n$$\nggT(m, n) \\cdot kgV(m, n) = m \\cdot n\n$$ {#eq-produkt}\n:::\n\nWenn der *ggT* zweier Zahlen bekannt ist, dann kann man das *kgV* also wie folgt berechnen:\n\n::: {.callout-important}\n## Berechnung des *kgV* aus dem *ggT*\n$$\nkgV(m, n)=(m\\cdot n)\\div ggT(m, n)\n$$ {#eq-kgV}\n:::\n\nFür die Zahlen 12 und 18 ergibt sich also folgende Berechnung:\n\n::: {.callout-tip}\n## Berechnung des *kgV* von 12 und 18 über den *ggT*\n- $ggT(12, 18)=6$\n- $kgV(12, 18)=(12\\cdot 18)\\div 6=12\\cdot 3=36$\n:::\n\n::: {.callout-caution}\n## Zwischenübung\nBestimme das *kgV* von 60 und 24 über den *ggT*.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Lösung\n- $ggT(60, 24)=12$\n- $kgV(60, 24)=(60\\cdot 24)\\div 12=60\\cdot 2=120$\n:::\n\nDa wir aus @sec-ggT bereits über eine Funktion zur Berechnung des *ggT* verfügen, ist die Implementierung des *kgV* in Python einfach:\n\n::: {#9f6cacd8 .cell execution_count=12}\n``` {.python .cell-code}\ndef kgv_2(m, n): return m * n // ggT(m, n)\n\nassert kgv_2(12, 18) == 36\nassert kgv_2(60, 24) == 120\nassert kgv_2(3528, 3780) == 52920\n```\n:::\n\n\n### Das kgV von mehreren Zahlen\n\nMan verwendet zur Berechnung des *kgV* mehrerer Zahlen alle Primfaktoren, die in mindestens einer der Zahlen vorkommen, mit der jeweils höchsten vorkommenden Potenz, zum Beispiel:\n\n::: {.callout-tip}\n## *kgV* der Zahlen 144, 160 und 175\n- $144=2^4\\cdot 3^2$\n- $160=2^5\\cdot 5^1$\n- $175=5^2\\cdot 7^1$\n- $kgV(144, 160, 175)=2^5\\cdot 3^2\\cdot 5^2\\cdot 7^1=50.400$\n:::\n\n::: {#9e6c3cb5 .cell execution_count=13}\n``` {.python .cell-code}\nassert 2**5 * 3**2 * 5**2 * 7**1 == 50400\n```\n:::\n\n\nWir könnten auch zunächst $kgV ⁡(144, 160)=1440$ berechnen und danach $kgV(1440, 175)= 50.400$, denn als eine zweistellige Verknüpfung auf den ganzen Zahlen ist das *kgV* assoziativ:\n\n::: {.callout-important}\n## Assoziativität des *kgV*\n$$\nkgv(m, kgV(n, p))=kgV(kgV(m, n), p)\n$$ {#eq-kgv-assoz}\n:::\n\nWir machen uns diesen Umstand zunütze und definieren eine neue Funktion in Python für die Berechnung des *kgV* für drei Zahlen:\n\n::: {#5be712dc .cell execution_count=14}\n``` {.python .cell-code}\ndef kgv_3(m, n, p):                 # <1>\n  kgv_mn = kgv_2(m, n)              # <2>\n  return kgv_2(kgv_mn, p)           # <3>\n\nassert kgv_3(144, 160, 175) == 50400\n```\n:::\n\n\n1. Signatur für die Funktion `kgv_3` mit drei Parametern\n2. Berechnung des *kgV* für die ersten beiden Parameter\n3. Berechnung und Rückgabe des *kgV* mit dem dritten Parameter\n\nPython unterstützt nicht das Überladen von Funktionen.\nWenn wir zwei verschiedene Varianten einer Funktion definieren wollen (z.B. eine Variante, die zwei Argumente akzeptiert und eine Variante, die drei Argumente akzeptiert, wie in unserem Fall), dann müssen wir diesen Funktionen in Python verschiedene Namen geben.\nDas ist der Grund, weshalb ich die Variante für zwei Argumente `kgv_2` genannt habe, und die Variante für drei Argumente `kgv_3`.\n\n::: {.callout-note}\n## Überladen von Funktionen\nEinige *statisch kompilierte* Programmiersprachen (z.B. Java und C++) bieten die Möglichkeit, denselben Funtionsnamen für verwandte Funtionen zu verwenden.\nDas nennt man dann **Überladen** der Funktion.\n\nDie Signaturen der Funktionen müssen sich dann aber unterscheiden lassen: entweder durch die Anzahl der zugelassenen Parameter, oder dadurch, dass den Parametern unterschiedliche *Datentypen* zugeordnet werden.\n\nDa Python aber eine *dynamische* Spache ist (d.h. eine Funktion wird erst dann kompiliert, wenn sie aufgerufen wird), und weil die Datentypen der Parameter zum Zeitpunkt der Kompilierung noch nicht bekannt sind, ist es in Python nicht möglich, Funktionen zu überladen.\n:::\n\nWir können das Problem aber umgehen, indem wir einen zusätzlichen Standardparameter definieren und innerhalb der Funktion prüfen, ob dieser beim Aufruf der Funktion gesetzt wurde:\n\n::: {#29163113 .cell execution_count=15}\n``` {.python .cell-code}\ndef kgV(m, n, p=None):              # <1>\n  if p:                             # <2>\n    kgv_mn = kgV(m, n)              # <3>\n    return kgV(kgv_mn, p)           # <3>\n  else:\n    return m * n // ggT(m, n)       # <4>\n\nassert kgV(144, 160, 175) == 50400\n```\n:::\n\n\n1. Signatur der Funktion `kgV` mit drei Parameterm.\nDer dritte Parameter `p` wird als Standardparameter definiert, indem wir ihm den Wert `None` zuweisen.\nWenn wir später die Funktion mit nur zwei Argumenten aufrufen, dann ist `p` undefiniert.\nWenn wir sie mit drei Argumenten aufrufen, dann ist `p` gleich dem dritten Argument.\n2. Test, ob `p` gesetzt ist, d.h. ob drei Argumente angegeben wurden.\n3. Falls ja, berechnen wir das Ergebnis so wie in `kgv_3`, nur dass wir eben wieder *kgV* mit zwei Argumenten aufrufen.\n4. Falls `p` nicht gesetzt ist, berechnen wir das *kgV* wie in `kgv_2`.\n\nOb diese Lösung dann leichter verständlich ist, kannst für dich selbst entscheiden; grundsätzlich sind beide Varianten gleichwertig und führen zum selben Ergebnis.\n\n## Übungen\n\nDu bist jetzt bereit, deine ersten mathematischen Probleme mit Python zu lösen.\n\nFalls du Python und Jupyter noch nicht installiert hast, dann sieh in Lektion [Rechenregeln](1-rechenregeln.qmd#sec-ubung) nach und richte deine Arbeitsumgebung ein.\n\nUm mit den Jupyter-Notebooks dieses Tutorials arbeiten zu können, musst du sie dir zunächst herunterladen.\nDafür brauchst du das Programm *Git*, dass du gemäß diesen [Installationsanleitungen](https://github.com/git-guides/install-git) installieren kannst.\n\nWenn *Git* installiert ist, setze in deiner Kommandozeile den Befehl `git clone https://github.com/okrischer/matheKapierenMitPython.git` ab.\nWechsle dann in das Verzeichnis `matheKapierenMitPython` und aktiviere deine Arbeitsumgebung mit `conda activate matheKapieren`.\n\nJetzt kannst du mit `jupyter lab` *Jupyter* starten, und es sollte sich ein neues Browser-Fenster öffnen.\nÖffne dort im *File Browser* (der Spalte ganz links im Browser-Fenster) das Verzeichnis `arithmetik` und dann mit einem Doppel-Klick das Notebook `_teiler.ipynb`.\nFolge dann den Anweisungen im Notebook.\n\n",
    "supporting": [
      "2-teiler_files"
    ],
    "filters": [],
    "includes": {}
  }
}