{
  "hash": "4954cc1998152720e65d3d67e8c30139",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Rekursion\"\n---\n\nRekursion ist eine wichtige Problemlösungsstrategie der Mathematik und der Programmierung.\nKomplexe Sachverhalte können oft mit rekursiv formulierten Regeln sehr elegant erfasst werden.\nDas Grundprinzip der Rekursion besteht darin, eine komplexe Aufgabe in gleichförmige Teilaufgaben zu zerlegen, die dann einfach gelöst werden können.\n\n::: {.callout-important}\n## Rekursion\nAls Rekursion wird ein prinzipiell unendlicher Vorgang bezeichnet, der sich selbst als Teil enthält oder mithilfe von sich selbst definierbar ist.\\\nDie bei der Rekursion aufeinander folgenden Teilvorgänge sind nicht unabhängig voneinander, sondern zwischen jedem Schrittpaar besteht eine besondere, die *rekursive Beziehung*.\n:::\n\nDas klingt erstmal nicht besonders einleuchtend.\nEin alltägliches Beispiel kann das Funktionsprinzip der Rekursion vielleicht erhellen:\n\n::: {.callout-tip}\n## Einschrauben ein Glühbirne\n**Frage**: Wie viele Umdrehungen sind nötig, um eine Glühbirne einzuschrauben?\\\n**Antwort**: Ist sie bereits eingeschraubt? Dann ist die Antwort null.\nWenn nicht, dann drehe sie einmal, frage mich erneut, und addiere 1 zu meiner Antwort.\n:::\n\n## Mathematische Beispiele\n\nMathematische Objekte werden häufig *rekursiv* definiert, d.h. mit Bezug auf sich selbst.\nSolche Objekte können dann mit Hilfe von Rekursion bestimmt werden.\n\n### Fakultät\n\nAls erstes Beispiel für Rekursion wollen wir die Berechnung der *Fakultät* untersuchen.\n\n::: {.callout-important}\n## Fakultät\nDie Funktion Fakultät ($n!$) einer natürlichen Zahl $n \\geq 1$ ist definiert als das Produkt der Zahlen 1 bis $n$:\n$$\nn! = 1\\cdot2\\cdot3\\cdots n=\\prod_{k=1}^n{k}\n$$ {#eq-fakt}\n:::\n\n::: {.callout-tip}\n## Beispiele\n$$\n\\begin{align}\n1! &= 1 &= & 1 \\\\\n2! &= 1\\cdot2 &= & 2 \\\\\n3! &= 1\\cdot2\\cdot3 &= & 6 \\\\\n4! &= 1\\cdot2\\cdot3\\cdot4 &= & 24 \\\\\n\\end{align}\n$$\n:::\n\nSoll diese Liste fortgesetzt werden, ergibt sich die Rekursivität nahezu von selbst.\nFür die Berechnung von $5!$ wollen wir nicht von vorn beginnen, sondern wir greifen auf das vorherige Ergebniss zurück, also $5! = 4! \\cdot 5=24\\cdot5=120$.\n\n::: {.callout-important}\n## Rekursive Definition der Fakultät\nVerallgemeinert lässt sich die Funktion Fakultät somit *rekursiv* definieren:\n$$\nn! =\n\\begin{cases}\n1 &\\text{, falls} \\ n=1 &\\text{(Rekursionsanfang)}\\\\\nn \\cdot (n-1)! &\\text{, sonst} &\\text{(Rekursionsschritt)}\n\\end{cases}\n$$ {#eq-fakt-rek}\n:::\n\n\nWir können den Wert der Fakultät also mittes Rekursion in Python bestimmen:\n\n::: {#665842a3 .cell execution_count=2}\n``` {.python .cell-code}\ndef fakultät(n):                                                    # <1>\n    if n == 1:                                                      # <2>\n        return 1\n    else:\n        return n * fakultät(n-1)                                    # <3>\n\nassert fakultät(5) == 120\n```\n:::\n\n\n1. Signatur der rekursiven Funktion `fakultät`.\nDas entspricht einer \"gewöhnlichen\" Funktionsdefinition; eine rekursive Funktion muss in Python nicht besonders gekennzeichnet werden.\n2. **Rekursionsanfang**: Test, ob der Eingabewert dem definierten Rekursionsanfang entspricht.\nFalls ja, geben wir den Wert 1 zurück.\n3. **Rekursionsschritt**: Wenn der Eingabewert nicht dem Rekursionsanfang entspricht, dann wird das Ergebnis rekursiv berechnet, d.h. die Funktion ruft sich selbst mit neuem Argument auf.\nDas neue Argument ist in diesem Fall `n-1`.\n\n::: {.callout-note}\n## Rekursive Funktion\nRekursion wird in der Programmierung über eine *rekursive Funktion* abgebildet, d.h. mit einer Funktion, die sich selbst wiederholt aufruft.\\\nEntsprechend der rekursiven Definition muss auch eine rekursive Funktion dabei immer zwei Fälle berücksichtigen:\n\n- **Rekursionsanfang**: Falls der definierte Wert für den Rekursionsanfang erreicht ist, gibt die Funktion das dafür definierte Ergebnis aus.\nIn diesem Fall darf kein weiterer rekursiver Aufruf erfolgen.\n- **Rekursionsschritt**: Falls der Eingabewert nicht dem Rekursionsanfang entspricht, wird der nächste Schritt der Berechnung durchgeführt, indem sich die Funktion mit einem neuen Argument selbst wieder aufruft.\n\n**Beachte**: Das neue Argument für den rekursiven Aufruf muss *immer* so gewählt werden, dass es sich dem Wert des Rekursionsanfangs annähert und am Ende auch diesen Wert erreicht.\n:::\n\nBei der Fakultät handelt es sich um eine *linear rekursive* Definition, bei der höchstens *ein* rekursiver Aufruf vorkommt.\nDie Berechnung mittels Python verläuft daher entlang einer Kette von Aufrufen.\nBei einer solchen Rekursion enthält der *Aufrufbaum* also keine Verzweigungen.\n\nUm die Abarbeitung des Aufrufbaums verdeutlichen, ergänzen wir die Funktion `fakultät` um zwei Ausgaben:\n\n::: {#b6c9a9e1 .cell execution_count=3}\n``` {.python .cell-code}\ndef fakultät(n):\n    if n == 1:\n        print(f\"n = {n}: Rekursionsanfang erreicht\")\n        return 1\n    else:\n        print(f\"n = {n}: Rekursionsschritt mit neuem Argument {n-1}\")\n        return n * fakultät(n-1)\n\nfakultät(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nn = 5: Rekursionsschritt mit neuem Argument 4\nn = 4: Rekursionsschritt mit neuem Argument 3\nn = 3: Rekursionsschritt mit neuem Argument 2\nn = 2: Rekursionsschritt mit neuem Argument 1\nn = 1: Rekursionsanfang erreicht\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n120\n```\n:::\n:::\n\n\nDamit ein rekursives Programm das Ergebnis berechnen kann, müssen alle bisherigen Teilergebnisse zwischengespeichert werden.\nDas passiert automatisch in einem besonderen Programmspeicher, dem sogenannten *program stack*.\nWenn es sich um eine sehr komplexe Berechnung handelt, oder wenn sich das Argument des rekursiven Aufrufs nicht dem Wert des Rekursionsanfangs annähert, dann muss das Programm sehr viele dieser Zwischenergebnisse speichern.\nIm schlimmsten Fall führt das zu einem Programmabruch, weil der Progammspeicher voll ist; das ist bekannt als *stack overflow*.\n\nEinige funktionale Programmiersprachen (wie z.B. Haskell, F# oder Scala) umgehen dieses Problem, indem sie eine optimierte Abarbeitung ermöglichen, die eine rekursive Schleife intern in eine iterative Schleife umwandelt.\nDazu muss aber eine sogenannte *endständige Rekursion* vorliegen, in der der rekursive Aufruf der letzte Aufruf der Funktion ist; außerdem dürfen bei diesem Aufruf keine weiteren Operationen durchgeführt werden.\n\nUnsere Funktion `fakultät` ist also nicht *endständig rekursiv*, da der rekursive Aufruf zusätzlich mit einer Multiplikation verknüpft ist.\nDas Problem kann aber gelöst werden, indem wir die Multiplikation vorher durchführen und das Produkt mit einem zusätzlichen Parameter dem rekursiven Aufruf hinzufügen.\n\n::: {#1e6cc079 .cell execution_count=4}\n``` {.python .cell-code}\ndef fakultät(n):                                                # <1>\n    def rek(n, p):                                              # <2>\n        if n == 1:\n            print(f\"Rekursionsanfang, Ergebnis = {p}\")\n            return p                                            # <3>\n        else:\n            p *= n                                              # <4>\n            print(f\"n = {n}, produkt = {p}\")\n            return rek(n-1, p)                                  # <5>\n    return rek(n, 1)                                            # <6>\n\nfakultät(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nn = 5, produkt = 5\nn = 4, produkt = 20\nn = 3, produkt = 60\nn = 2, produkt = 120\nRekursionsanfang, Ergebnis = 120\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n120\n```\n:::\n:::\n\n\n1. Definition einer \"gewöhnlichen\" Funktion.\n2. Definition einer inneren, rekursiven Funktion mit einem zweiten Parameter für die Speicherung der Zwischenergebnisse.\n3. Rekursionsanfang: wir geben hier anstelle der 1 das letzte Teilergebnis zurück.\n4. Durchführung der Multiplikation und Zuweisung an `p`, dem Teilergebnis.\n5. Rekursiver Aufruf mit neuem Argument und bisherigem Teilergebnis.\n6. Aufruf der rekursiven Funktion mit dem definierten Wert für den Rekursionsanfang.\n\nIn einer imperativen Sprachen wie Python ist diese Optimierung aber ohne Belang: der Compiler bzw. Interpreter kann kann eine endständige Rekursion nicht automatisch in eine iterative Schleife überführen.\\\nAber wir können eine lineare Rekursion auch explizit als iterative Schleife ausdrücken.\nDas Vorgehen hierzu entspricht dem der endständigen Rekursion: \n\n::: {#0a9a2dc1 .cell execution_count=5}\n``` {.python .cell-code}\ndef fakultät(n):\n    p = 1                                           # <1>\n    while n != 1:                                   # <2>\n        p *= n                                      # <3>\n        n -= 1                                      # <4>\n        print(f\"n = {n}, produkt = {p}\")\n    print(f\"Rekursionsanfang, Ergebnis = {p}\")\n    return p\n\nfakultät(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nn = 4, produkt = 5\nn = 3, produkt = 20\nn = 2, produkt = 60\nn = 1, produkt = 120\nRekursionsanfang, Ergebnis = 120\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n120\n```\n:::\n:::\n\n\n1. Initialisierung des Ergebnisses mit 1, dem Wert für den Rekursionsanfang.\n2. Beginn einer iterativen Schleife, deren Bedingung prüft, ob der Rekursionsanfang erreicht wurde.\n3. Durchführung der Multiplikation und Zuweisung an `p`, dem Teilergebnis.\n4. Verringerung der Schleifenvariablen um 1.\n\n### Größter gemeinsamer Teiler\n\nIn Lektion [Teiler und Vielfache](2-teiler.qmd#sec-ggT) haben wir den größten gemeinsamen Teiler zweier ganzer Zahlen iterativ berechnet mit folgender Funktion:\n\n::: {#8f503af6 .cell execution_count=6}\n``` {.python .cell-code}\ndef ggT_iter(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n```\n:::\n\n\nHier werden innerhalb der itertiven Schleife nur zwei Anweisungen wiederholt ausgeführt:\n\n> setze `a` gleich `b`, und `b` gleich `a % b`.\n\nGenauso, wie wir eine rekursive Schleife in eine iterative Schleife überführen können, können wir auch den umgekehrten Schritt machen: eine itertive Schleife als rekursive Schleife ausdrücken:\n\n::: {#c13e0fa5 .cell execution_count=7}\n``` {.python .cell-code}\ndef ggT_rek(a, b):\n    if b == 0: return a\n    else: return ggT_rek(b, a % b)\n```\n:::\n\n\nHier werden die selben Anweisungen ausgeführt, aber dieses mal in einer rekursiven Schleife, indem die Funktion mit den entprechenden Argumenten aufgerufen wird:\n\n> setze Parameter `a` auf `b`, und Parameter `b` auf `a % b`.\n\nWir haben in beiden Versionen exakt denselben Algorithmus implementiert, mit der Folge, dass die Funktionen das selbe Ergebnis mit der selben Anzahl von Berechnungsschritten liefern:\n\n::: {#72bcc180 .cell execution_count=8}\n``` {.python .cell-code}\nassert ggT_iter(143, 65) == ggT_rek(143, 65)\nassert ggT_iter(3780, 3528) == ggT_rek(3780, 3528)\n```\n:::\n\n\nEs besteht aber ein *semantischer* Unterschied, d.h. in der Art *wie* wir den Algorithmus ausdrücken.\\\nDie **iterative Variante** folgt diesem Muster:\n\n> solange der Rekursionsanfang *nicht* erreicht ist:\\\n> >>> wiederhole die Anweisungen\\\n> anderenfalls gib das Ergebnis aus\n\nDie **rekursive Variante** folgt diesem Muster:\n\n> wenn der Rekursionsanfang erreicht ist:\\\n> gib das Ergebnis aus\\\n> >>> anderenfalls wiederhole die Anweisungen\n\n\n\n\n### Fibonacci-Folge\n\nDas Paradebeispiel rekursiver Definitionen in der Mathematik ist die sogenannte *Fibonacci Folge*.\nBenannt ist die Folge nach dem italienischen Mathematiker Leonardo Fibonacci, den wir bereits in der Lektion [Zahlenbereiche und Zahlensysteme](3-mengen.qmd#sec-dezimal) kennengelernt haben.\nFibonacci hatte mit dieser Zahlenfolge in seinem Rechenbuch *Liber abbaci* das Wachstum einer (fiktiven) Kaninchenpopulation beschrieben.\n\nDie Fibonacci-Folge ist die unendliche Folge natürlicher Zahlen, die mit den Zahlen 0 und 1 beginnt, und bei der jede Zahl die Summe der beiden ihr vorangehenden Zahlen ist.\nDie Fibonacci-Folge ist also deshalb *rekursiv*, weil ihre Elemente in Bezug auf ihre jeweils vorangehenden Elemente definiert sind.\n\n::: {.callout-important}\n## Rekursive Definition der Fibonacci-Folge\nDie Fibonacci-Folge ist wie folgt mathematisch definiert:\n$$\n\\begin{align}\nF_0 &= 0 \\\\\nF_1 &= 1 \\\\\nF_n &= F_{n-1} + F_{n-2}\n\\end{align}\n$$ {#eq-fibonacci}\n:::\n\nWir können die Zahlen der Fibonacci-Folge also mittels Rekursion in Python bestimmen:\n\n::: {#f1649ddb .cell execution_count=9}\n``` {.python .cell-code}\ndef fib_rek(n):\n    if n < 2:                                           # <1>\n        return n\n    else:\n        return fib_rek(n-1) + fib_rek(n-2)          # <2>\n\nassert fib_rek(10) == 55\n```\n:::\n\n\n1. *Rekursionsanfang*: Test, ob `n` gleich 0 oder 1 ist. Falls ja, dann geben wir `n` als Ergebnis zurück\n2. *Rekursionsschritt*: Wenn `n` größer als 1 ist, dann wird das Ergebnis durch zwei rekursive Aufrufe der Funktion berechnet.\nDas Ergebnis ist dann die $n$-te Fibonacci-Zahl.\n\nDiese Rekursion ist also nicht linear, da hier zwei rekursive Aufrufe nacheinander vorkommen.\nMan nennt diese Form auch *kaskadenförmige* oder *verschachtelte* Rekursion, da die Aufrufe hier einen verschachtelten Baum bilden, der sich bei jedem Aufruf zweifach verzweigt.\n\nWir können auch das wieder veranschaulichen, indem wir Programmausgaben einfügen:\n\n::: {#bb9d1af1 .cell execution_count=10}\n``` {.python .cell-code}\ndef fib_print(n):\n    if n < 2:                                           # <1>\n        print(f\"Rekursionsanfang mit n = {n}\")\n        return n\n    else:\n        print(f\"Rekursionsschritt mit n = {n}\")\n        return fib_print(n-1) + fib_print(n-2)          # <2>\n\nfib_print(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRekursionsschritt mit n = 4\nRekursionsschritt mit n = 3\nRekursionsschritt mit n = 2\nRekursionsanfang mit n = 1\nRekursionsanfang mit n = 0\nRekursionsanfang mit n = 1\nRekursionsschritt mit n = 2\nRekursionsanfang mit n = 1\nRekursionsanfang mit n = 0\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n3\n```\n:::\n:::\n\n\nEs ist nicht notwendig, diesen Ablaufbaum im Detail zu verstehen, das kann bei einer verschachtelten Rekursion recht schwierig sein.\nWir wollen aber wissen, wie schnell der Baum wächst; ich habe dazu `fib_print` mit den Argumenten 3, 4 und 5 aufgerufen und jeweils die Ausgabezeilen gezählt:\n\n- $fib(3)=5$\n- $fib(4)=9$\n- $fib(5)=15$\n\nMit ein wenig Intuition (oder ausprobieren) finden wir heraus, dass die Wachstumsrate ungefähr gleich $2^{n-1}$ ist, d.h. der Aufwand steigt exponentiell in Abhängigkeit vom Eingabewert $n$.\nSchon bei einem Eingabewert größer als 30 müssen wir mit mehr als einer Milliarde Aufrufen rechnen.\nWir können die Bearbeitungszeit einer Anweisung in Python mit dem *magic command* `%time` messen:\n\n::: {#f523309c .cell execution_count=11}\n``` {.python .cell-code}\n%time fib_rek(35)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCPU times: user 850 ms, sys: 133 μs, total: 851 ms\nWall time: 850 ms\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n9227465\n```\n:::\n:::\n\n\nDie Bearbeitungszeit beträgt knapp 900 Millisekunden ($1ms = 10^{-3}s$), also fast eine Sekunde.\nDas ist für größere Eingabewerte nicht mehr praktikabel.\n\nEine Möglichkeit zur Lösung des Problems ist die Anwendung einer Technik, die als *memoization* bezeichnet wird.\nDabei werden Teilergebnisse, die bereits berechnet wurden, in einem Zwischenspeicher (engl. *cache*) gespeichert, und aus diesem cache abgerufen, ohne eine erneute Berechnung durchzuführen.\n\n::: {#863a3e9c .cell execution_count=12}\n``` {.python .cell-code}\ncache = {0: 0, 1: 1}                                # <1>\n\ndef fib_mem(n):\n    if n not in cache:                              # <2>\n        cache[n] = fib_mem(n-1) + fib_mem(n-2)      # <3>\n    return cache[n]                                 # <4>\n\nassert fib_mem(10) == fib_rek(10)\nprint(cache)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{0: 0, 1: 1, 2: 1, 3: 2, 4: 3, 5: 5, 6: 8, 7: 13, 8: 21, 9: 34, 10: 55}\n```\n:::\n:::\n\n\n1. Definition des Zwischenspeichers als `dict` mit den Werten aus dem Rekursionsanfang.\n2. Test, ob das Ergebnis für `n` bereits vorliegt.\n3. Falls nicht, berechnen wir das Ergebnisses für `n` mittels Rekursion und fügen es zum Zwischenspeicher hinzu.\n4. In jedem Fall geben wir das Ergebnis für `n` aus dem Zwischenspeicher aus, da der cache den Wert für `n` jetzt enthalten muss.\n\nNach der Ausführung der Funktion enthält der cache alle Fibonacci-Zahlen bis einschließlich $n$.\n\nWir messen die Bearbeitungszeit der neuen Version ebenfalls mit dem Eingabewert 35:\n\n::: {#26fa9f7b .cell execution_count=13}\n``` {.python .cell-code}\n%time fib_mem(35)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCPU times: user 10 μs, sys: 0 ns, total: 10 μs\nWall time: 12.2 μs\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n9227465\n```\n:::\n:::\n\n\nDie Bearbeitungszeit beträgt jetzt rund 11 Mikrosekunden ($1\\mu s=10^{-6}s$).\nDie neue Version ist damit um den Faktor $10^5$ schneller als die Version ohne *memoization*.\nEs lohnt sich also auf jeden Fall, Algorithmen mit einer exponentiellen Laufzeit zu optimieren.\n\nDie Fibonacci-Folge kann aber auch mit einer iterativen Schleife berechnet werden; hierfür benötigen wir zwei Variable, eine für die letzte und die andere für die vorletzte Zahl der bisherigen Folge:\n\n::: {#293aa30d .cell execution_count=14}\n``` {.python .cell-code}\ndef fib_iter(n):\n    a, b = 0, 1                                     # <1>\n    c = 0                                           # <2>\n    while c != n:                                   # <3>\n        a, b = b, a + b                             # <4>\n        c += 1                                      # <5>\n    return a\n\nassert fib_iter(10) == fib_mem(10)\n```\n:::\n\n\n1. Die ersten beiden Zahlen der Folge aus dem Rekursionsanfang.\n2. Initialisierung eines Zählers.\n3. Iterative Schleife: wiederhole die Anweisungen, solange `c != n`.\nWir verwenden hier einen Zähler als Schleifenvariable, um die Berechnung abzubrechen, sobald die gesuchte Fibonacci-Zahl berechnet wurde.\n4. Berechnung der nächsten Zahl der Folge als Summe der beiden vorangehenden Zahlen.\n5. Hochzählen des Zählers.\n\nWir messen erneut die Laufzeit der neuen Version:\n\n::: {#3fcc98dc .cell execution_count=15}\n``` {.python .cell-code}\n%time fib_iter(35)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCPU times: user 5 μs, sys: 0 ns, total: 5 μs\nWall time: 6.91 μs\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n9227465\n```\n:::\n:::\n\n\nDie Laufzeit beträgt hier nur noch rund 6 $\\mu s$; die iterative Version ist also ungefähr doppelt so schnell wie die optimierte rekursive Version.\n\nIn der Regel können verschachtelte Rekursionen aber nicht ohne Weiteres in iterative Schleifen überführt werden.\nBei der Fibonacci-Folge klappt das nur deshalb, weil es sich hier um eine sogenannte *primitive* Rekursion handelt, bei der das Ergebnis jeden Teilschrittes über eine einfache mathematische Operation (wie z.B. der Addition) berechnet werden kann.\nWir werden im nächsten Kapitel ein Beispiel einer nicht-primitiven Rekursion kennenlernen, die sich nicht direkt in eine iterative Schleife überführen läßt.\n\n::: {.callout-note}\n## Rekursion vs. Iteration\nEine **Rekursion** kommt i.d.R. mit weniger Quellcode aus und ist (für erfahrene Programmierer) übersichtlicher – es müssen hier keine Hilfsvariablen und Schleifenzähler definiert werden.\\\nIn der Abarbeitung sind **iterative Verfahren** meist effizienter und benötigen weniger Speicherplatz.\n:::\n\n## Die Türme von Hanoi\n\nDie Türme von Hanoi sind ein mathematisches Knobel- und Geduldsspiel, das als Standardbeispiel für rekursive Programmierung dient.\nDas Spiel wird von einer Person gespielt.\nEs besteht aus drei gleich großen Stäben, auf die mehrere gelochte Scheiben gesteckt werden, alle verschieden groß.\n\nZu Beginn liegen alle Scheiben auf dem linken Stab, der Größe nach geordnet, mit der größten Scheibe unten und der kleinsten oben.\n\n![Türme von Hanoi - Spielaufbau](https://upload.wikimedia.org/wikipedia/commons/0/07/Tower_of_Hanoi.jpeg){#fig-hanoi-aufbau}\n\nZiel des Spiels ist es, den kompletten Scheiben-Stapel vom linken Stab auf den rechten Stab zu versetzen, wobei der mittlere Stab als temporäre Ablage dient.\nHierbei gelten zwei Regeln:\n\n1. Es darf in jedem Zug nur eine Scheibe bewegt werden.\n2. Eine Scheibe muss immer auf einer größeren Scheibe abgelegt werden.\n\nFolglich sind zu jedem Zeitpunkt des Spieles die Scheiben auf jedem Stapel der Größe nach geordnet.\n\n### Lösungsansatz\n\nEs ist nicht sofort offensichtlich, wie das Spiel gelöst werden kann.\nIn der Praxis wird man durch Ausprobieren versuchen, ein Muster für geeignete Zugfolgen zu erkennen, und dieses Muster dann wiederholt anwenden, bis alle Scheiben auf dem Zielstab abgelegt sind.\n\nIn der Programmierung führt Ausprobieren in der Regel nicht zum Erfolg.\nStattdessen wollen wir uns *vor* der Implementierung überlegen, wie wir das Problem am besten lösen können.\nWir versuchen also, das Muster anhand theoretischer Überlegungen zu erkennen, und es dann in Form eines Algorithmus im Programm-Code abzubilden.\n\nAls erstes benennen wir dazu die bekannten Fakten:\nDen linken Stab (Start) nennen wir `A`, den mittleren (temporären) Stab `B` und den rechten Zielstab `C`.\\\nDie Anzahl der Scheiben, mit denen gespielt wird, nennen wir `n`, wobei die kleinste (oberste) Scheibe den Wert 1 erhält, und der Wert jeder weiteren darunter liegende Scheibe jeweils um eins vergrößert wird; die unterste (größte) Scheibe hat dann den Wert `n`.\n\nTypischerweise wird das Spiel mit acht Scheiben gespielt.\nUm uns die Analyse zu erleichtern, betrachten wir zunächst ein einfacheres Problem mit nur drei Schreiben.\nUm dieses Problem zu lösen, müssen wir\n\n1. die beiden kleinsten Scheiben (mit den Werten `1` und `2`) auf den temporären Stapel `B` verschieben\n2. die größte Scheibe mit dem Wert `3` auf den Zielstapel `C` verschieben\n3. die beiden kleinsten Scheiben vom temporären Stapel `B` auf den Zielstapel `C` verschieben.\n\n::: {#fig-hanoi-analyze}\n\n{{< video media/videos/hanoi_analyze/480p15/hanoi_analyze.mp4 >}}\n\n\nHanoi - Lösungsansatz in drei Schritten\n:::\n\nDas Muster ist nachvollziehbar, aber es scheint, als gäbe es ein Problem:\\\nin den Schritten 1 und 3 verschieben wir mehr als eine Scheibe, was nach den Regeln nicht erlaubt ist.\n\nWir könnten versuchen, das Problem iterativ zu lösen, indem wir explizite Zugfolgen für 2, 3, 4, oder mehr Scheiben berechnen, die verschoben werden sollen.\nBei näherer Betrachtung erkennen wir aber, dass das gar nicht notwendig ist:\n\n- Schritt 2 mit dem Verschieben einer einzelnen Scheibe ist trivial (das entspricht einem Rekursionsanfang mit `n==1`)\n- die Schritte 1 und 3 verschieben jeweils `n-1` Scheiben (das entspricht einem Rekursionsschritt mit neuem Argument `n-1`).\n\nEs handelt sich also offensichtlich um ein rekursives Problem, und wir können den Algorithmus beschreiben, indem wir unser Muster für ein beliebiges `n` verallgemeinern:\n\n::: {.callout-note}\n## Rekursiver Algorithmus\n1. Verschiebe die `n-1` kleinsten Scheiben rekursiv auf den temporären Stapel\n2. Verschiebe die verbleibende Scheibe auf den Zielstapel\n3. Verschiebe die `n-1` kleinsten Scheiben rekursiv vom temporären auf den Zielstapel.\n:::\n\nWenn wir den Algorithmus als verschachtelte Rekursion implementieren, d.h. alle drei Schritte als rekursive Aufrufe direkt nacheinander ausführen, dann wird zunächst Schritt 1 `n-1` mal aufgerufen, bevor in Schritt 2 tatsächlich nur eine Scheibe bewegt wird.\nWir bewegen also nie mehr als eine Scheibe mit einem einzelnen Aufruf, wie gefordert.\n\n### Implementierung\n\nFür unsere erste Implementierung verwenden wir zur Repräsentation der Scheibenstapel eine Datenstrukur [Stapel](https://de.wikipedia.org/wiki/Stapelspeicher).\nDie Elemente eines Stapels werden wie bei einem Stapel Spielkarten übereinander gelegt und in umgekehrter Reihenfolge vom Stapel genommen.\nDies wird auch Last-In-First-Out-Prinzip [LIFO](https://de.wikipedia.org/wiki/Last_In_%E2%80%93_First_Out) genannt.\n\nEin Stapel verfügt typischerweise über zwei Methoden `push` und `pop`, mit denen Elemente auf dem Stapel abgelegt bzw. wieder ausgelagert werden.\nDa Python nicht über einen eingebauten Datentyp *stack* verfügt, bauen wir uns einen eigenen mit Hilfe einer Liste:\n\n::: {#3a8db0f9 .cell execution_count=16}\n``` {.python .cell-code}\nclass Stapel():\n    def __init__(self):\n        self.speicher = []                             # <1>\n\n    def push(self, elem):\n        self.speicher.append(elem)                     # <2>\n\n    def pop(self):\n        return self.speicher.pop()                     # <3>\n\n    def __repr__(self):\n        return repr(self.speicher)                     # <4>\n```\n:::\n\n\n1. Initialisierung einer leeren Liste als Datenspeicher.\n2. Implementierung der `push` Methode: das neue Element wird am Ende der Liste angehängt.\n3. Implementierung der `pop` Methode: das letzte Element der Liste wird aus dem Datenspeicher entfernt und zurückgegeben.\n4. Ausgabe der Elemente im Datenspeicher.\n\n::: {#f5ef298c .cell execution_count=17}\n``` {.python .cell-code}\nn = 8\nA = Stapel()\nB = Stapel()\nC = Stapel()\nfor i in range(n, 0, -1):\n    A.push(i)\n\nA\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n[8, 7, 6, 5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\nIch habe hier den Startstapel mit den Werten 1 bis `n` befüllt, so dass, unserer Konvention folgend, das oberste Element (der letzte Eintrag in der Liste) den Wert 1 hat und das unterste Element (der erste Eintrag in der Liste) den Wert `n` hat.\n\nDiese Stapel können wir nun in einer rekursiven Funktion `hanoi` verwenden, um den rekursiven Algorithmus abzubilden:\n\n::: {#26d65614 .cell execution_count=18}\n``` {.python .cell-code}\ndef hanoi(start, ziel, temp, n):                    # <1>\n    if n == 1:\n        ziel.push(start.pop())                      # <2>\n    else:\n        hanoi(start, temp, ziel, n-1)               # <3>\n        hanoi(start, ziel, temp, 1)                 # <4>\n        hanoi(temp, ziel, start, n-1)               # <5>\n```\n:::\n\n\n1. Signatur mit vier Parametern: `start`, `ziel` und `temp`, die die jeweiligen Scheibenstapel repräsentieren; `n` für die Gesamtanzahl der Scheiben.\n2. Rekursionsanfang: wenn `n` gleich 1 ist, also die unterste Scheibe im Stapel erreicht ist, dann wird diese Scheibe vom Startstapel entfernt und auf dem Zielstapel abgelegt.\n3. Rekursionsschritt 1: verschieben der obersten `n-1` Scheiben von `start` nach `temp`.\nBeachte die Reihenfolge der Argumente: das erste Argument entpricht gemäß der Funktionssignatur dem Startstapel, das zweite dem Zielstapel und das dritte dem temporären Stapel.\n4. Rekursionsschritt 2: verschieben der untersten Scheibe von `start` nach `ziel`.\n5. Rekursionsschritt 3: verschieben der `n-1` Scheiben von `temp` nach `ziel`.\n\nMit dieser Implementierung wird offensichtlich, dass nur im Rekursionsanfang (`n==1`) tatsächlich eine Scheibe verschoben wird.\nDie Rekursionsschritte dienen lediglich dazu, die korrekte Reihenfolge der Züge zu berechnen.\n\nWir rufen `hanoi` mit den Scheibenstapeln `A`, `C` und `B` auf (beachte die Reihenfolge gem. Funktionssignatur) und prüfen das Ergebnis:\n\n::: {#b4764852 .cell execution_count=19}\n``` {.python .cell-code}\nhanoi(A, C, B, n)\nprint(A)\nprint(B)\nprint(C)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[]\n[]\n[8, 7, 6, 5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\nOffensichtlich wurden alle Scheiben in der richtigen Reihenfolge von `A` nach `C` verschoben.\nLeider gibt diese Implementierung keinen Aufschluss darüber, in welcher Reihenfolge die Scheiben *tatsächlich* verschoben wurden.\nWenn wir das Spiel manuell lösen wollen, haben wir also immer noch keinen brauchbaren Lösungsweg.\n\nUm den Lösungsweg zu erhalten, nehmen wir eine kleine Korrektur vor:\nanstatt konkrete Scheiben zu verschieben, zeichnen wir lediglich jeden Zug auf, der in Schritt 2 unseres Algorithmus ausgeführt wird.\n\n::: {#e085a241 .cell execution_count=20}\n``` {.python .cell-code}\nzüge = Stapel()\n\ndef hanoi(start, ziel, temp, n):\n    if n == 0: return                               # <1>\n    hanoi(start, temp, ziel, n-1)                   # <2>\n    züge.push((start, ziel))                        # <3>\n    hanoi(temp, ziel, start, n-1)                   # <4>\n```\n:::\n\n\n1. Rekursionsanfang: wenn alle Scheiben verschoben wurden (`n==0`), dann gibt es nichts mehr zu tun, und wir beenden das Programm.\nDamit sparen wir uns auch die `if-else` Verzweigung der bisherigen Version.\n2. Rekursionsschritt 1: verschiebe die obersten `n-1` Scheiben von `start` nach `temp`.\n3. Schritt 2: speichere den Zug der aktuellen Scheibe von `start` nach `ziel`.\nDazu muss sich die Funktion gar nicht rekursiv aufrufen, sondern die Speicherung erfolgt direkt hier.\n4. Rekursionsschritt 3: verschiebe die `n-1` Scheiben von `temp` nach `ziel`.\n\nWir rufen die neue Version jetzt nicht mit den konkreten Stapeln auf, sondern mit den Buchstaben 'A', 'B' und 'C', die diese Stapel repräsentieren.\n\n::: {#2cbd6857 .cell execution_count=21}\n``` {.python .cell-code}\nhanoi('A', 'C', 'B', 3)\nzüge\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n[('A', 'C'), ('A', 'B'), ('C', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('A', 'C')]\n```\n:::\n:::\n\n\nDie Züge sind wie folgt zu interpretieren:\njedes Paar in runden Klammern repräsentiert einen Zug, wobei jeweils die oberste Scheibe des erstgenannten Stapels auf den zweiten Stapel verschoben wird.\nDu kannst das z.B. mit einem Stapel verschiedengroßer Münzen ausprobieren und wirst feststellen, dass das Problem damit gelöst wird, und dass dabei nie eine größere auf einer kleineren Münze plaziert wird.\n\nIch habe die zweite Versionen der Funktion `hanoi` benutzt, um nachfolgende Animation für vier Scheiben zu erstellen.\nWenn du wissen willst wie das geht, dann sieh dir den Quellcode unter `arithmetik/hanoi_solve.py` an.\n\n::: {#fig-hanoi-solve}\n\n{{< video media/videos/hanoi_solve/480p15/hanoi_solve.mp4 >}}\n\n\nHanoi - Lösung für vier Scheiben\n:::\n\n\n### Laufzeitanalyse\n\nDas Problem ist gelöst.\nBleibt nur noch, die Anzahl der dazu notwendigen Schritte zu berechnen, um eine Aussage über die Effizienz des Algorithmus zu erhalten.\nWir rufen dafür die Funktion `hanoi` mit verschiedener Scheibenanzahl auf und zählen die Züge im jeweiligen Ergebnis:\n\n::: {#c88bbcb3 .cell execution_count=22}\n``` {.python .cell-code}\ndef size(self):\n    return len(self.speicher)\n\nStapel.size = size\n\nfor n in range(3, 9):\n    züge = Stapel()\n    hanoi('A', 'C', 'B', n)\n    print(f\"{n} Scheiben: {züge.size()} Züge\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3 Scheiben: 7 Züge\n4 Scheiben: 15 Züge\n5 Scheiben: 31 Züge\n6 Scheiben: 63 Züge\n7 Scheiben: 127 Züge\n8 Scheiben: 255 Züge\n```\n:::\n:::\n\n\nOffensichtlich ist die Anzahl der Züge $H_n$ abhängig von der Anzahl der Scheiben $n$, und mit etwas Intuition erkennen wir:\n$$\nH_n=2^n-1, \\quad \\mathrm{mit} \\ n \\geq 0.\n$$ {#eq-zuege}\nWir haben es also wieder mit einem exponentiellen Wachstum zu tun.\n\nWir wollen uns aber als angehende Mathematiker nicht auf unsere Intuition verlassen.\nAußerdem wollen wir prüfen, ob es, ähnlich wie bei der Fibonacci-Folge, eine effizientere Lösung gibt, indem wir z.B. die verschachtelte Rekursion in eine lineare Rekursion überführen.\n\nDazu analysieren wir nochmal unseren Algorithmus:\n\n- zuerst verschieben wir die `n-1` kleinsten Scheiben, was $H_{n-1}$ Züge erfordert\n- dann verschieben wir die größte Scheibe, was einen Zug erfordert\n- schließlich verschieben wir erneut `n-1` Scheiben, was weitere $H_{n-1}$ Züge erfordert.\n\nWir können also $n$ Scheiben in höchstens $2H_{n-1}+1$ Zügen verschieben:\n$$\nH_n \\leq 2H_{n-1} + 1, \\quad \\mathrm{mit} \\ n > 0.\n$$\n\nDie obige Formel verwendet $\\leq$ anstatt $=$, da wir bisher nur gezeigt haben, dass $2H_{n-1}+1$ Züge auf jeden Fall ausreichen.\nVielleicht gibt es aber einen schnelleren Weg zur Lösung.\n\nKönnen wir das tatsächlich besser machen?\\\nIrgendwann müssen wir die größte Scheibe verschieben.\nZu diesem Zeitpunkt müssen sich die `n-1` kleinsten Scheiben auf einem einzelnen Stapel befinden, und es hat mindestens $H_{n-1}$ Züge gebraucht, um sie dorthin zu bewegen.\\\nEs spielt keine Rolle, wie viele Züge wir für das Verschieben der größten Scheibe an die richtige Position brauchen.\nAber nach dem letzten Zug der größten Scheibe müssen wir die `n-1` kleinsten Scheiben (die dann wieder auf einem einzelnen Stapel liegen müssen), zurück auf die größte Scheibe verschieben; das erfordert wieder mindestens $H_{n-1}$ Züge.\nDaraus folgt\n$$\nH_n \\geq 2H_{n-1} + 1, \\quad \\mathrm{mit} \\ n > 0.\n$$\n\nDiese zwei Ungleichungen führen zu folgenden Gleichungen\n\n$$\n\\begin{align}\nH_0 &= 0\\\\\nH_n &= 2H_{n-1} + 1, \\quad \\mathrm{mit} \\ n > 0.\n\\end{align}\n$$ {#eq-recurrence}\n\nDas entspricht offensichtlich einer rekursiven Definition für die Anzahl der notwendigen Züge.\nWir wollen diese Anzahl aber nicht rekursiv berechnen, sondern wir suchen eine *geschlossene Formel*, mit der wir die Anzahl der Züge in einem Schritt berechnen können.\n\nEine Möglichkeit, eine rekursive Formel in eine geschlossene Formel zu überführen, ist die sogenannte *mathematische Induktion*.\nWir werden uns im Abschnitt [Beweise](???) dieses Tutorials ausführlich mit mathematischer Induktion beschäftigen.\nAn dieser Stelle geben wir aber schon mal ein Beispiel, um zu zeigen, wie eng das Prinzip der Induktion mit dem der Rekursion verwandt ist.\n\nDer Grundgedanke besteht darin, unsere Behauptung aus @eq-zuege (die *Induktionsbehauptung*) in die Gleichungen der rekursiven Definition (@eq-recurrence) einzusetzen und zu prüfen, ob die Gleichungen dann immer noch für jedes $n$ gelten.\n\nDer erste Fall für $n=0$ (*Induktionsanfang*) ist trivial, da $H_0 = 2^0-1=1-1=0$.\n\nFür den zweiten Fall $n\\neq0$ (*Induktionsschritt*) kann die Behauptung für jedes $n$ bewiesen werden, indem wir zeigen, dass sie auch für $n-1$ gilt:\n\n$$\nH_n=2H_{n-1}+1=2(2^{n-1}-1)+1=2^n-1.\n$$\n\nWir haben damit mathematisch bewiesen, dass die Anzahl der Züge *immer* gleich $2^n-1$ ist.\nDamit kann es auch keine effizientere Lösung für unser Problem geben: die verschachtelte Rekursion kann nicht in eine lineare Rekursion überführt werden.\n\n## Übungen\n\nDie Übungen zu dieser Lektion findest du im Notebook `artithmetik/_rekursion.ipynb`.\n\n",
    "supporting": [
      "6-rekursion_files"
    ],
    "filters": [],
    "includes": {}
  }
}