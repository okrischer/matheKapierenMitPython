[
  {
    "objectID": "arithmetik/3-mengen.html",
    "href": "arithmetik/3-mengen.html",
    "title": "Zahlenbereiche und Zahlensysteme",
    "section": "",
    "text": "Bisher haben wir wie selbstverständlich von natürlichen und reellen Zahlen gesprochen, ohne überhaupt genau zu wissen, was wir darunter verstehen wollen.\nIn dieser Lektion werden wir uns den Zahlenbegriff, so wie er der gesamten Mathematik zugrunde liegt, näher anschauen. Dafür werden wir zunächst die Grundbegriffe der Mengenlehre kennenlernen und die Zahlen in Zahlenbereiche einteilen. Schließlich wollen wir auch noch verschiedene Zahlensysteme erkunden.",
    "crumbs": [
      "Arithmetik",
      "Zahlenbereiche und Zahlensysteme"
    ]
  },
  {
    "objectID": "arithmetik/3-mengen.html#sec-mengen",
    "href": "arithmetik/3-mengen.html#sec-mengen",
    "title": "Zahlenbereiche und Zahlensysteme",
    "section": "1 Elementare Mengenlehre",
    "text": "1 Elementare Mengenlehre\nIn der Mathematik wird jede Zusammenfassung von bestimmten, wohlunterscheidbaren Objekten zu einer Gesamtheit eine Menge genannt. Eine Menge ist definiert, wenn feststeht, welche Objekte zu dieser Menge gehören und welche nicht. Die zur Menge gehörenden Objekte heißen ihre Elemente. Mengen werden meistens mit großen lateinischen Buchstaben bezeichnet und die Elemente mit kleinen Buchstaben.\n\n\n\n\n\n\nDefinition von Mengen\n\n\n\nEs gibt zwei Möglichkeiten, Mengen zu definieren:\n\nDurch Aufzählen ihrer Elemente, die in beliebiger Reihenfolge zwischen geschweiften Klammern (Mengenklammern) gesetzt sind und durch Komma getrennt werden: \\(\\{x_1, x_2, x_3, \\dots\\}\\)\nDurch Angabe einer die Elemente charakteresierenden Eigenschaft: \\(\\{x \\mid \\mathrm{Eigenschaft}\\}\\). Der vertikale Strich \\(\\mid\\) wird gelesen als “für die gilt”.\n\n\n\n\n\n\n\n\n\nBeispiele für Mengendefinitionen\n\n\n\n\n\\(A=\\{1,2,3\\}\\): die Menge \\(A\\) besteht aus den Elementen 1, 2 und 3.\n\\(B=\\{x \\mid x^2-1=0\\}\\): die Menge \\(B\\) besteht aus den Elementen \\(x\\), für die \\(x^2-1=0\\) gilt.\n\\(B=\\{1,-1\\}\\): da die Gleichung \\(x^2-1=0\\) die Lösungen \\(x_1= 1\\) und \\(x_2=-1\\) besitzt, kann man die Menge \\(B\\) auch in dieser Form schreiben.\n\n\n\nGehört ein Objekt \\(a\\) einer Menge \\(M\\) an, so schreibt man \\(a \\in M\\) (gelesen als: \\(a\\) ist Element von \\(M\\)). Gehört \\(a\\) nicht zu \\(M\\), so schreibt man \\(a \\notin M\\).\nWenn jedes Element einer Menge \\(M\\) auch Element einer Menge \\(N\\) ist, so nennt man \\(M\\) Teilmenge von \\(N\\) und schreibt \\(M \\subset N\\). Diese Schreibweise bedeutet auch, dass \\(M\\) eine echte Teilmenge von \\(N\\) ist; es gilt also \\(M\\neq N\\). Wollte man zulassen, dass \\(M\\) auch gleich \\(N\\) sein könnte, also \\(M=N\\), dann würde man \\(M\\subseteq N\\) schreiben.\nDie leere Menge \\(\\emptyset=\\{\\}\\) enthält kein Element.\nDie Zugehörigkeit von Objekten zu Mengen kann man auch grafisch in einem Mengendiagramm darstellen, wobei Mengen als Kreise oder Ellipsen dargestellt werden, und Elemente, die zur Menge gehören, in den Kreis geschrieben werden.\n\n\n\n\n\n\nAbbildung 1: Euler-Diagramm: Zugehörigkeit zu Mengen\n\n\n\nAuf Mengen sind folgende Operationen definiert, deren Ergebnis jeweils wieder eine Menge ist:\n\n\n\n\n\n\nVereinigungsmenge\n\n\n\nDie Vereinigung \\(A \\cup B\\) zweier Mengen \\(A\\) und \\(B\\) besteht aus denjenigen Elementen, die in \\(A\\) oder in \\(B\\), also in mindestens einer der beiden Mengen \\(A, B\\) enthalten sind: \\[\nA \\cup B = \\{x \\mid x \\in A \\ \\mathrm{oder} \\ x \\in B\\}\n\\]\n\n\n\n\n\n\n\n\nSchnittmenge\n\n\n\nDie Durchschnitt \\(A\\cap B\\) zweier Mengen \\(A\\) und \\(B\\) besteht aus denjenigen Elementen, die sowohl in \\(A\\) als auch in \\(B\\), also gleichzeitig in beiden Mengen \\(A, B\\) enthalten sind: \\[\nA \\cap B = \\{x \\mid x \\in A \\ \\mathrm{und} \\ x \\in B\\}\n\\]\n\n\n\n\n\n\n\n\nDifferenz\n\n\n\nDie Differenz \\(A \\backslash B\\) zweier Mengen \\(A\\) und \\(B\\) besteht aus denjenigen Elementen, die in \\(A\\), aber nicht in \\(B\\) enthalten sind: \\[\nA \\backslash B = \\{x \\mid x \\in A \\ \\mathrm{und} \\ x \\notin B\\}\n\\]\n\n\n\n\n\n\n\n\nSymmetrische Differenz\n\n\n\nDie symmetrische Differenz \\(A \\Delta B\\) zweier Mengen \\(A\\) und \\(B\\) besteht aus denjenigen Elementen, die in \\(A\\) oder \\(B\\) enthalten sind, aber nicht in der Schnittmenge von \\(A\\) und \\(B\\): \\[\nA \\Delta B = (A \\cup B) \\backslash (A \\cap B)=(A \\backslash B) \\cup (B \\backslash A)\n\\]\n\n\nDiese Mengenoperationen können mit einem sogenannten Venn-Diagramm veranschaulicht werden, in dem die Ergebnismenge einer Operation entsprechend eingefärbt wird (in diesem Beispiel in Rot):\n\n\n\n\n\n\nAbbildung 2: Venn-Diagramm der Operationen auf Mengen\n\n\n\nWir können auch in Python mit Mengen rechnen (wir beschränken uns dabei auf ganze Zahlen). Dazu müssen wir die Zahlen, die zu einer Menge gehören sollen, in einem Datentyp set zusammenfassen, der weitgehend unserem Mengenbegriff entpricht. Da alle Schlüsselwörter in Python (und damit auch die Bezeichnungen der Datentypen) in englischer Sprache angegeben werden, verwenden wir in diesem Tutorial ausschließlich die englischen Bezeichnungen.\n\n1A = {1,2,3}\n2B = set()\n3assert (len(A), len(B)) == (3, 0)\n\n\n1\n\nDefinition eines set A mit Mengenklammern\n\n2\n\nDefinition eines leeren set B\n\n3\n\nDie Anzahl der Elemente eines set (auch die Kardinalität einer Menge genannt) wird mit der Funktion len() berechnet. Wir haben hier auf der linken und rechten Seite des == jeweils zwei Werte zu einem sogenannten tuple zusammengeführt, einem anderen Datentyp, bei dem die Elemente in runden Klammern angegeben werden. Auch ein tuple kann offensichtlich auf Gleichheit getestet werden.\n\n\n\n\nDer Test auf Mitgliedschaft in einer Menge (\\(\\in\\)) wird mit dem Schlüsselwort in durchgeführt, das Gegenstück (\\(\\notin\\)) mit not in, wobei not ein sogenannter Bool’scher Operator ist, der das gegebene Argument verneint:\n\nassert 1 in A\nassert 1 not in B\n\nDie beiden anderen Bool’schen Operatoren in Python sind and und or mit denen wir zwei Wahrheitsaussagen verknüpfen können:\n\n1assert (1 in A) or (1 in B)\n2B.add(1)\n3assert (1 in A) and (1 in B)\n\n\n1\n\nWenn (mindestens) eine der beiden Aussagen wahr ist, dann ist auch die mit or verknüpfte Aussage wahr.\n\n2\n\nWir fügen dem set B das Element 1 hinzu.\n\n3\n\nNur wenn beide Aussagen wahr sind, dann ist auch die mit and verknüpfte Aussage wahr.\n\n\n\n\nOb ein set B eine echte Teilmenge vom set A ist (\\(B\\subset A\\)), kann mit dem Operator B &lt; A getstet werden. Das ist dann gleichbedeutend mit A &gt; B, d.h. A ist die Obermenge von B:\n\nassert B &lt; A\nassert A &gt; B\n\nUnd schließlich können wir auch die Mengenoperationen auf set A und B ausführen:\n\nB.add(-1)\nprint(\"A = \", A)\nprint(\"B = \", B)\n\n# Vereinigungsmenge A ∪ B\nprint(\"A ∪ B = \", A.union(B))\nassert A.union(B) == A | B\n\n# Schnittmenge A ∩ B\nprint(\"A ∩ B = \", A.intersection(B))\nassert A.intersection(B) == A & B\n\n# Differenz A \\ B\nprint(\"A \\\\ B = \", A.difference(B))\nassert A.difference(B) == A - B\n\n# Symmetrische Differenz A ∆ B\nprint(\"A ∆ B = \", A.symmetric_difference(B))\nassert A.symmetric_difference(B) == A ^ B\n\nA =  {1, 2, 3}\nB =  {1, -1}\nA ∪ B =  {1, 2, 3, -1}\nA ∩ B =  {1}\nA \\ B =  {2, 3}\nA ∆ B =  {2, 3, -1}",
    "crumbs": [
      "Arithmetik",
      "Zahlenbereiche und Zahlensysteme"
    ]
  },
  {
    "objectID": "arithmetik/3-mengen.html#zahlenbereiche",
    "href": "arithmetik/3-mengen.html#zahlenbereiche",
    "title": "Zahlenbereiche und Zahlensysteme",
    "section": "2 Zahlenbereiche",
    "text": "2 Zahlenbereiche\nDie Zahlen, mit denen wir rechnen, lassen sich in Teilmengen einteilen, die Zahlenbereiche genannt werden und üblicherweise in Mengenschreibweise dargestellt werden.\n\n\n\n\n\n\nAbbildung 3: Die Zahlenbereiche in Mengendarstellung\n\n\n\n\n2.1 Natürliche Zahlen\nDie einfachsten Zahlen sind die, mit denen wir als Kind zählen gelernt haben: die Menge der natürlichen Zahlen. Wir benutzen diese Zahlen, um die Anzahl von Objekten einer Menge zu bestimmen, also zum Zählen.\n\n\n\n\n\n\nNatürliche Zahlen\n\n\n\nDie Menge der natürlichen Zahlen sind die ganzen positiven Zahlen: \\[\n\\mathbb{N} = \\{1,2,3,\\dots\\},\n\\] wobei die drei Punkte anzeigen, dass die Folge der Zahlen nach dem gegeben Muster fortgeführt wird.\n\n\n\n\n2.2 Ganze Zahlen\n\n\n\n\n\n\nGanze Zahlen\n\n\n\nDie Menge der ganzen Zahlen ist wie folgt definiert: \\[\n\\mathbb{Z}=\\{\\dots,-3,-2,-1,0,1,2,3,\\dots\\}\n\\] Das lässt sich dann unter Verwendung von Eigenschaften so schreiben: \\[\n\\mathbb{Z}=\\{z \\mid abs(z) \\in \\mathbb{N}\\} \\cup \\{0\\},\n\\] wobei \\(abs(z)\\) für den absoluten Wert von \\(z\\) steht, also \\(z\\) ohne Vorzeichen.\n\n\nEs hat in Europa bis zum Ende des Mittelalters gedauert, bis sich die Verwendung von 0 als Zahl und die Rechnung mit negativen Zahlen durchgesetzt hat. Das erscheint auf den ersten Blick verwunderlich, da wir heute ganz selbstverständlich mit negativen Zahlen rechnen. Folgender Witz illustriert, was für ein großer intellektueller Schritt das war:\n\n\n\n\n\n\nMathematiker Witz\n\n\n\nStehen ein Theologe, ein Physiker und ein Mathematiker vor einem leeren Raum. Gemeinsam beobachten sie, wie drei Personen den Raum betreten und kurze Zeit fünf Personen wieder herauskommen.\n“Ein Wunder!”, ruft der Theologe.\n“Muss sich um einen Messfehler handeln”, murmelt der Physiker.\nDer Mathematiker entgegnet nur trocken: “Jetzt müssen nur zwei Leute wieder hineingehen, damit der Raum wieder leer ist”.\n\n\nMit der Mengenschreibweise können wir jetzt auch etwas komliziertere Mengen darstellen, zum Beispiel:\n\n\n\n\n\n\nGerade und ungerade Zahlen\n\n\n\n\nMenge der geraden natürlichen Zahlen: \\(\\{2n \\mid n \\in \\mathbb{N}\\}\\)\nMenge der ungeraden ganzen Zahlen: \\(\\{2z-1 \\mid z \\in \\mathbb{Z}\\}\\)\n\n\n\nSolche Zahlenmengen lassen sich auch in Python mit sogenannten set comprehensions erstellen, die eng an die mathematische Schreibweise von Mengen angelehnt sind:\n\n# Menge der geraden natürlichen Zahlen bis 20\nN = {1,2,3,4,5,6,7,8,9,10}\n{2*n for n in N}\n\n{2, 4, 6, 8, 10, 12, 14, 16, 18, 20}\n\n\nHier haben wir gegenüber der mathematischen Notation lediglich den vertikalen Strich \\(\\mid\\) durch das Schlüsselwort for ersetzt, und die Menge der natürlichen Zahlen, für die die Anweisung gelten soll, zuvor explizit als set definiert.\nNatürlich ist es etwas umständlich, die Elemente der Ausgangsmenge konkret aufzuzählen; Python bieter daher eine range() Funktion an, die zwei ganze Zahlen als Argumente akzeptiert und daraus ein Intervall berechnet, das als Ausgangsmenge dienen kann:\n\n# Menge der ungeraden Zahlen im Intervall [-5, 17)\n{2*z-1 for z in range(-2, 9)}\n\n{-5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15}\n\n\nUm zu verstehen was hier passiert, müssen wir uns mit der Intervallschreibweise von Zahlenmengen vertraut machen:\n\n\n\n\n\n\nIntervalle\n\n\n\nZahlenmengen können mit Hilfe von Intervallen beschrieben werden. Wenn die Intervallgrenzen mit den ganzen Zahlen \\(a,b\\) angegeben werden, dann besteht ein Intervall aus allen ganzen Zahlen \\(x\\), die zwischen diesen Grenzen liegen. Für so beschränkte Intervalle gelten folgende Regeln:\n\n\\([a,b]= \\{x \\mid x \\in \\mathbb{Z} \\ \\mathrm{und} \\ a \\leq x \\leq b\\}\\) (geschlossenes Intervall)\n\\((a,b)= \\{x \\mid x \\in \\mathbb{Z} \\ \\mathrm{und} \\ a &lt; x &lt; b\\}\\) (offenes Intervall)\n\n\n\nEckige Klammern \\([]\\) bedeuten also, dass der jeweilige Begrenzer mit zur Menge gehört, runde Klammern \\(()\\)dagegen, dass der Begrenzer nicht mehr zur Menge gehört. In Python erzeugt der Aufruf von range(a, b) immer ein halboffenes Intervall in der Form \\([a, b)\\), so dass also a zur Menge gehört, b aber nicht. Das erklärt, warum im letzten Code-Beispiel das Intervall \\([-5, 17)\\) angegeben wurde, mit dem Ergebnis \\(\\{-5,-3,\\dots,13,15\\}\\), da 17 nicht mehr zum Intervall gehört.\nDie Angabe der range mit range(-2, 9) ist trotzdem etwas verwirrend, liegt aber daran, dass \\(2\\cdot -2-1=-5\\) und \\(2\\cdot 8-1=15\\) ist (die 9 in der range gehört nicht mehr zum Intervall und Python wählt den nächstkleineren Wert 8).\nUm diese Verwirrung auszuschließen, können wir eine set comprehension auch anders definieren, und zwar indem wir die Forderung für ungerade als zusätzliche Bedingung formulieren:\n\n# Menge der ungeraden Zahlen im Intervall [-5, 17)\n{z for z in range(-5, 17) if z % 2 != 0}\n\n{-5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15}\n\n\nHier haben wir den Modulo Operator % verwendet, der den Rest einer ganzzahligen Division ausgibt, um zu testen, ob z eine ungerade Zahl ist.\n\n\n2.3 Rationale Zahlen\nEine rationale Zahl ist eine Zahl, die als Verhältnis (lateinisch ratio) zweier ganzer Zahlen dargestellt werden kann. Um die Menge aller rationalen Zahlen zu bezeichnen, wird das Zeichen \\(\\mathbb{Q}\\) verwendet (von Quotient). \\(\\mathbb{Q}\\) umfasst alle Zahlen, die sich als Bruch darstellen lassen, der sowohl im Zähler als auch im Nenner ganze Zahlen enthält.\n\n\n\n\n\n\nRationale Zahlen\n\n\n\nDie Menge der rationalen Zahlen ist wie folgt definiert: \\[\n\\mathbb{Q}=\\left\\{\\frac{m}{n} \\mid m, n \\in \\mathbb{Z}, n \\neq 0\\right\\}\n\\]\n\n\nDer Nenner darf dabei nicht Null sein, da die Division durch 0 nicht definiert ist. Wir werden im Rahmen der Lektion Bruchrechnung näher auf das Rechnen mit Brüchen und damit auf das Rechnen mit rationalen Zahlen eingehen.\nJede rationale Zahl kann als endlicher oder unendlich periodischer Dezimalbruch dargestellt werden.\n\n\n\n\n\n\nDezimalbruch\n\n\n\nDer Dezimalbruch einer rationalen Zahl ist die Darstellung der rationalen Zahl als Dezimalzahl, aslo als Zahl mit Stellen hinter dem Komma. Bei einem endlichen Dezimalbruch ist die Anzahl der Stellen hinter dem Komma endlich, bei einem periodischen Dezimalbruch wiederholen sich die Stellen nach dem Komma nach einem gewissen Muster (Periode).\n\n\n\n\n\n\n\n\nBeispiele für Dezimalbrüche\n\n\n\n\n\\(\\frac{3}{2}=1,5\\)\n\\(-\\frac{1}{8}=-0,125\\)\n\\(\\frac{4}{3}=1,33333=1,\\overline{3}\\) (der periodische Teil wird überstrichen)\n\\(-\\frac{16}{11}=-1,454545=-1,\\overline{45}\\)\n\n\n\nIn Python erzeugt der Divisionsoperator / eine Dezimalzahl, die hier allerdings floating point number genannt wird und dem Datentyp float zugeordnet ist. Beachte den point in der englischen Bezeichnung: das deutsche Dezimalkomma wird zum Dezimalpunkt im gesamten englischen Sprachraum: \\(1,5 (de)= 1.5(en)\\).\n\nprint(\"3/2 =\", 3 / 2)\nprint(\"-1/8 =\", -1 / 8)\nprint(\"4/3 =\", 4 / 3)\n\n# eine periodische Darstellung ist nicht möglich, aber wir können runden\nprint(\"-16/11 =\", round(-16/11, 2)) # runden auf 2 Stellen nach dem Punkt\n\n3/2 = 1.5\n-1/8 = -0.125\n4/3 = 1.3333333333333333\n-16/11 = -1.45\n\n\n\n\n2.4 Reelle Zahlen\nDie Menge der reellen Zahlen erweitert den Zahlenbereich der rationalen Zahlen um die irrationalen Zahlen, also Zahlen, die sich nicht als Bruch zweier ganzer Zahlen darstellen lassen, und damit auch nicht als endliche oder periodische Dezimalzahl. Die Menge der reellen Zahlen wird mit \\(\\mathbb{R}\\) bezeichnet.\n\n\n\n\n\n\nIrrationale Zahlen\n\n\n\nAls irrationale Zahlen bezeichnen wir die Menge aller Elemente von \\(\\mathbb{R}\\), die nicht in \\(\\mathbb{Q}\\) liegen: \\[\n\\mathrm{irrationale \\ Zahlen:} \\quad \\mathbb{R} \\ \\backslash \\ \\mathbb{Q}\n\\]\n\n\nIn der Antike hatten die Pythagoräer (die Schüler des berühmten Mathematikers Pythagoras) angenommen, dass sich alles im Universum mit rationalen Zahlen darstellen lässt. Betrachtet man aber ein Quadrat der Seitenlänge eins, so sollte die Länge \\(x\\) von dessen Diagonale, folgend dem Satz des Pythagoras, die Gleichung \\(x^2 = 2\\) erfüllen, und damit \\(x=\\sqrt{2}\\).\nAus rein geometrischen Überlegungen sollte es also eine Zahl geben, die diese Darstellung besitzt. Tragischerweise hat ausgerechnet Hippasos, ein Schüler des Pythagoras, mit Hilfe dessen Satzes bewiesen, dass \\(\\sqrt{2}\\) keine rationale Zahl sein kann. (siehe ???).\nDie erste bekannte irrationale Zahl ist also \\(\\sqrt{2}\\); aus der Wurzelrechnung ??? folgt aber, dass es noch unendlich viele weitere solcher irrationaler Zahlen gibt, die auch als algebraische irrationale Zahlen bezeichnet werden.\nAlgebraisch deshalb, weil sie als Lösung einer “gewöhnlichen” algebraischen Gleichung angegben werden können, zum Beispiel ist \\(\\sqrt{5}\\) die Lösung der Gleichung \\(x^2=5\\).\nEs gibt aber auch irrationale Zahlen, die nicht als Lösung einer algebraischen Gleichung angegeben werden können, man sagt, sie “übersteigen” (transzendieren) die Möglichkeiten der Algebra, und nennt sie daher transzendente Zahlen. Die bekanntesten dieser transzendenten Zahlen sind die Kreiszahl \\(\\pi\\) und die eulersche Zahl \\(e\\).\nDie Zahlen in \\(\\mathbb{R}\\) können in einer Zahlengeraden veranschaulicht werden, die verdeutlicht, dass die Menge der reelen Zahlen über die Vergleiche \\(&lt; \\mathrm{und}&gt;\\) eine lineare Ordnung bildet. Das beudeutet, dass wir für zwei verschiedene reelle Zahlen immer sagen können, welche von beiden größer bzw. kleiner ist:\n\n\n\n\n\n\nAbbildung 4: Ausschnitt der Zahlengeraden der reellen Zahlen\n\n\n\nInfolge dieser linearen Ordung sind Intervalle (siehe Kapitel 2.2) auch in \\(\\mathbb{R}\\) eindeutig definiert, z.B. enthält das Intervall \\((e, \\pi)\\) alle reellen Zahlen, die größer als \\(e\\) und kleiner als \\(\\pi\\) sind.",
    "crumbs": [
      "Arithmetik",
      "Zahlenbereiche und Zahlensysteme"
    ]
  },
  {
    "objectID": "arithmetik/3-mengen.html#zahlensysteme",
    "href": "arithmetik/3-mengen.html#zahlensysteme",
    "title": "Zahlenbereiche und Zahlensysteme",
    "section": "3 Zahlensysteme",
    "text": "3 Zahlensysteme\nEs gibt verschiedene Möglichkeiten zur Darstellung von Zahlen. Die einzelnen Zeichen zur Darstellung von Zahlen sind die Ziffern. Grundsätzlich unterscheidet man zwischen sogenannten Positionssystemen und Additionssystemen.\n\n\n\n\n\n\nPositions- und Additionssysteme\n\n\n\nBei einem Positionssystem (auch Stellenwertsystem genannt) ist der Wert einer Ziffer abhängig von der Position dieser Ziffer innerhalb der Zahl.\nBei Additionssystemen wird der Wert aller Ziffern einfach addiert, um den Wert der Zahl festzulegen.\n\n\n\n3.1 Römische Zahlen\nRömische Zahlen sind ein Beispiel eines Additionssytems. Die Ziffern sind hier lateinische Großbuchstaben, denen ein fester Wert zugewiesen wird:\n\n\n\nTabelle 1: Römische Ziffern\n\n\n\n\n\nBuchstabe\nI\nV\nX\nL\nC\nD\nM\n\n\n\n\nWert\n1\n5\n10\n50\n100\n500\n1000\n\n\n\n\n\n\nDa die Werte der Ziffern bei einem Additionssystem einfach zusammengezählt werden, ist z.B. der Wert der römischen Zahl XVII gleich 17.\n\n\n\n\n\n\nSubtraktionsregel\n\n\n\nDie Subtraktionsregel ist eine übliche, verkürzende Schreibweise, mit der vermieden wird, vier gleiche Ziffern in direkter Aufeinanderfolge zu schreiben.\nDie Subtraktionsregel besagt, dass die Ziffern I, X und C einer ihrer beiden jeweils nächstgrößeren Ziffern vorangestellt werden dürfen und dann in ihrem Zahlwert von dessen Wert abzuziehen sind:\n\nI vor V oder X: IV = 4, IX = 9\nX vor L oder C: XL = 40, XC = 90\nC vor D oder M: CD = 400, CM = 900\n\n\n\n\n\n\n\n\n\nDer Wert der römischen Zahl MCMLXXXIV\n\n\n\nMCMLXXXIV = \\(1000+(1000-100)+50+(3\\cdot10)+(5-1)=1984\\)\n\n\nDas Rechnen mit römischen Zahlen ist allerdings recht schwierig; hierfür wurden Hilfsmittel wie das Rechenbrett und der Abakus verwendet. Dabei werden die römischen Zahlen in ein Positionssystem überführt und Werten in der Form von Rechenmünzen oder Kugeln zugeordnet, mit denen dann die Rechenoperationen durchgeführt werden. Das Rechnen mit Rechenbrett und Abakus war bis zum Ende des Mittelalters weit verbreitet und wurde erst durch die Einführung der indischen Zahlenschrift und des heute gebräuchlichen Dezimalsystems (siehe Kapitel 3.2) abgelöst.\nWir wollen aber nicht mit dem Abakus rechnen, sondern mit Python; dazu entwickeln wir eine Funktion, die römische Zahlen in das Dezimalsystem überführt. Als ersten Schritt definieren wir hierzu ein dictionary, ein Objekt mit dem Datentyp dict:\n\nrom = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n\nEin dict ist ein Objekt, dessen Elemente sogenannte key-value pairs sind, also Paare von Schlüsseln und zugehörigen Werten. Diese Paare werden in Mengenklammern geschrieben und mit einem Komma voneinander getrennt. Ein einzelnes Paar wird dabei in Form k: v geschrieben, also Schlüssel, gefolgt von Doppelpunkt, gefolgt von zugeordnetem Wert. Das Leerzeichen ist optional und kann weggelassen werden. Wir haben unser dictionary rom mit den Werten aus Tabelle 1 initialisiert.\nDie Elemente können dann in einer for Schleife durchlaufen und ausgegeben oder manipuliert werden:\n\nfor (k, v) in rom.items():\n  print(\"Schlüssel: \", k, \", \",\"Wert: \", v)\n\nSchlüssel:  I ,  Wert:  1\nSchlüssel:  V ,  Wert:  5\nSchlüssel:  X ,  Wert:  10\nSchlüssel:  L ,  Wert:  50\nSchlüssel:  C ,  Wert:  100\nSchlüssel:  D ,  Wert:  500\nSchlüssel:  M ,  Wert:  1000\n\n\nDamit können wir dann die eigentliche Funktion definieren:\n\n1def roman_to_decimal(roman):\n2  res = 0\n3  for i in range(len(roman)):\n4    if i &gt; 0 and rom[roman[i]] &gt; rom[roman[i-1]]:\n5      res += rom[roman[i]] - 2 * rom[roman[i-1]]\n    else:\n6      res += rom[roman[i]]\n7  return res\n\nassert roman_to_decimal(\"MCMLXXXIV\") == 1984\n\n\n1\n\nSignatur der Funktion roman_to_decimal. Wir könnten die Bezeichner in Python auch in Deutsch angeben. Um nicht deutschsprachigen Entwicklern aber die Möglichkeit zu geben, unsere Programme zu verstehen, verwenden wie lieber aussagekräftige englische Bezeichner. Der Python Konvention folgend, verwenden wir dabei für zusammengesetzte Wörter die sogenannte snake case Schreibweise, bei der die einzelnen Worte mit Unterstich verbunden werden.\n\n2\n\nInitialisierung des Ergebnisses mit 0. Wir verwenden hier den Bezeichner res, als Kurzform des englischen result.\n\n3\n\nBeginn der for Schleife: wenn wir uns in der Schleife auf den Index des zu durchlaufenden Objekts beziehen (also auf die Position des aktuellen Wertes in dem Objekt), dann bezeichen wir die Schleifenvariable meist mit i. Das zu durchlaufende Objekt ist in diesem Fall eine range, also ein Intervall. Wenn die range() Funktion mit nur einem Argument \\(a\\) aufgerufen wird (hier die Länge der Zeichenkette (engl. string) roman), dann erzeugt Python ein Intervall \\([0, a)\\).\n\n4\n\nWir testen, ob der Wert der aktuellen Ziffer größer ist als der Wert der vorhergehenden Ziffer. In diesem Fall müssen wir die Subtraktionsregel anwenden. Der Test wird nicht für die erste Ziffer durchgeführt.\n\n5\n\nWenn die Subtraktionsregel greift, dann ziehen wir zweimal den Wert der vorhergehenden Ziffer vom bisherigen Resultat ab. Wir müssen zweimal abziehen, da im vorangehenden Schleifendurchlauf dieser Wert fälschlicherweise addiert statt subtrahiert wurde.\n\n6\n\nWenn die Subtraktionsregel nicht greift, dann addieren wir einfach den Wert der aktuellen Ziffer zum bisherigen Ergebnis.\n\n7\n\nRückgabe des Ergebnisses als Wert der Funktion.\n\n\n\n\n\n\n3.2 Dezimalsystem\nDas Dezimalsystem ist ein Positionssystem mit zehn Ziffern (von lateinisch decem, zehn) und ist die heute gebräuchliche Darstellung der Zahlen. Das Dezimalsystem hat sich aus dem indischen Zahlensystem entwickelt, das bereits ab dem 3. Jahrhundert v. Chr. in Indien in Gebrauch war. Im Jahr 628 n. Chr. führte der indische Mathematiker Brahmagupta die 0 als vollwertige Ziffer ein.\nWir verwenden heute aber nicht indische, sondern arabischen Ziffern. Das liegt daran, das sich das indische Zahlensystem im Mittelalter über den arabischen Sprachraum nach Europa ausgebreitet hat. Die Regeln für das Rechnen mit arabischen Zahlen wurden in Europa erstmals von dem italienischen Mathematiker Leonardo da Pisa (besser bekannt als Fibonacci) beschrieben, die er in seinem “Rechenbuch” Liber abbaci im Jahr 1201 zusammengefasst hat.\nDer Wert einer Ziffer in einer Dezimalzahl ergibt sich durch die Position der Ziffer innerhalb der Zahl. Um diesen Wert zu bestimmen, multiplizieren wir die Ziffer mit einer Zehnerpotenz \\(10^i\\), wobei \\(i\\) die Position der Ziffer in der Zahl ist. Bei ganzen Zahlen wird dabei der Einerstelle (die letzte Ziffer ganz rechts in der Zahl) der Wert \\(i=0\\) zugeordnet, der Zehnerstelle der Wert \\(i=1\\), der Hunderterstelle der Wert \\(i=2\\), usw. Die sich daraus ergebenden Werte werden dann addiert:\n\n\n\n\n\n\nBerechnung des Wertes einer ganzen Zahl\n\n\n\n\\(1984 = 4\\cdot10^0+8\\cdot 10^1+9\\cdot10^2+1\\cdot10^3=4+80+900+1000\\)\n\n\nDie Berechnung des Wertes eines Dezimalbruchs (einer Dezimalzahl mit Stellen nach dem Komma) erfolgt analog: der Wert einer Ziffer innerhalb der Zahl ergibt sich dadurch, dass die \\(n\\)-te Stelle vor dem Komma mit \\(10^{n-1}\\) und die \\(m\\)-te Stelle nach dem Komma mit \\(10^{-m}\\) multipliziert wird.\n\n\n\n\n\n\nDer Wert einer Dezimalzahl\n\n\n\nIst \\(a\\) eine Zahl mit den Ziffern \\(a_n,a_{n-1},\\cdots,a_1,a_0\\) vor dem Komma und den Ziffern \\(a_{-1},a_{-2},\\cdots,a_{-m}\\) nach dem Komma, dann gilt: \\[\na=\\sum_{i=-m}^n a_i\\cdot 10^i\n\\tag{1}\\] Die Stellen mit \\(i \\geq 0\\) bilden den ganzen Teil, die mit \\(i&lt;0\\) den gebrochenen Teil der Zahl.\n\n\n\n\n\n\n\n\nBerechnung des Wertes einer Dezimalzahl\n\n\n\n\\[\n\\begin{align}\n486,25 &= 4\\cdot10^2+8\\cdot10^1+6\\cdot10^0+2\\cdot10^{-1}+5\\cdot10^{-2}\\\\\n&= 400+80+6+0,2+0,05\n\\end{align}\n\\]\n\n\nAus diesem gleichförmigen Aufbau der Dezimalzahlen ergeben sich dann die einfachen Rechenoperationen, die wir schon aus der Grundschule kennen. Zum Beispiel können wir Dezimalzahlen addieren, indem wir ihre jeweiligen Dezimalstellen addieren und bei einem Ergbnis \\(\\geq 10\\) die \\(1\\) auf die nächste Stelle übertragen:\n\n\n\n\n\n\nAbbildung 5: Addition mit Übertrag\n\n\n\nHier sehen wir auch die besondere Rolle der \\(0\\): obwohl sie selbst keinen Wert besitzt, ist sie doch als Platzhalter in einem Positionssystem unentbehrlich.\n\n\n3.3 Dualsystem\nDas Dualsystem ist ein Positionssystem zur Basis 2, es gibt also nur zwei Ziffern \\(0,1\\). Es wird deshalb auch Binärsystem oder Zweiersystem genannt.\nDas Dualsystem spielt eine entscheidende Rolle in der Digitaltechnik, in der Zahlen durch elektrische Zustände dargestellt werden. In einem elektronischen Schaltkreis gibt es nur zwei Zustände: entweder es liegt ein Signal vor (Strom an), oder eben nicht (Strom aus). Diese Zustände werden zu Binärzahlen kombiniert, mit denen dann ein Computer “rechnet”.\nInformatiker (Menschen, die Computerwissenschaften studiert haben) erzählen sich gerne folgenden Witz:\n\n\n\n\n\n\nInformatiker Witz\n\n\n\nEs gibt 10 Arten von Menschen:\n\ndiejenigen, die das Binärsystem verstanden haben\ndiejenigen, die es nicht verstanden haben\n\n\n\nWenn du darüber lachen kannst, dann hast du es verstanden.\nAuch Python rechnet intern mit Binärzahlen, d.h. jede Eingabe von Dezimalzahlen wird in Binärzahlen umgewandelt, mit denen die notwendigen Berechnungen durchgeführt werden. Bei der Ausgabe des Ergebnisses werden diese Binärzahlen dann wieder zurück ins Dezimalsystem konvertiert.\nDieser Vorgang ist für den Anwender transparent, d.h. wir als Programmierer merken nichts von der internen Umwandlung. Für die Berechnung des Wertes einer ganzen Binärzahl gelten die Regeln aus Kapitel 3.2 analog, nur dass wir jede Ziffer nun mit einer Zweierpotenz \\(2^i\\) multiplizieren; jede Ziffer hat dann den doppelten Stellenwert der ihr rechts folgenden Ziffer:\n\n\n\n\n\n\nBerechnung des Wertes einer Dualzahl\n\n\n\n\\[\n\\begin{align}\n0100\\ 1101_2&=0\\cdot2^7+1\\cdot2^6+0\\cdot2^5+0\\cdot2^4+1\\cdot2^3+1\\cdot2^2+0\\cdot2^1+1\\cdot2^0\\\\\n&=0+64+0+0+8+4+0+1=77_{10}\n\\end{align}\n\\]\n\n\nWerden mehrere Zahlensysteme gleichzeitig benutzt, so ist es zur Vermeidung von Irrtümern üblich, die Basis als Index anzuhängen. Dualzahlen stellen wir zur besseren Lesbarkeit in Vierer-Blöcken dar.\nDie Berechnung reeller Zahlen im Dualsystem erfolgt analog zu Gleichung 1. Der Wert einer Ziffer im Dualsytem (engl. bit, als Kurzform für binary digit) ergibt sich dadurch, dass die \\(n\\)-te Stelle mit \\(2^{n-1}\\) und die \\(m\\)-te Stelle nach dem Komma mit \\(2^{-m}\\) multipliziert wird:\n\n\n\n\n\n\nDer Wert einer Dualzahl\n\n\n\n\\[\nb=\\sum_{i=-m}^n b_i\\cdot 2^i\n\\tag{2}\\]\n\n\n\n\n\n\n\n\nBerechnung einer reellen Zahl im Dualsystem\n\n\n\n\\[\n\\begin{align}\n1011,01_2&=1\\cdot2^3+0\\cdot2^2+1\\cdot2^1+1\\cdot2^0+0\\cdot2^{-1}+1\\cdot2^{-2}\\\\\n&=8+2+1+\\frac{1}{4}=11,25_{10}\n\\end{align}\n\\]\n\n\nMit der Berechnung des Wertes einer Dualzahl haben wir diese Zahl in eine Dezimalzahl umgerechnet; dies wird auch als Konvertierung bezeichnet. Mit diesen Regeln können wir jetzt eine Dualzahl mit Python in eine Dezimalzahl konvertieren:\n\ndef bin_to_dec(binary):\n1  assert type(binary) == str\n2  s = binary.split(',')\n3  n = len(s[0])\n  m = 1\n  decimal = 0\n4  for bit in s[0]:\n    decimal += int(bit) * 2**(n-1)\n    n -= 1\n5  for bit in s[1]:\n    decimal += int(bit) * 2**(-m)\n    m += 1\n  return decimal\n\nassert bin_to_dec(\"1011,01\") == 11.25\n\n\n1\n\nWir erwarten, dass die Funktion mit einem Argument vom Typ str (also einer Zeichenkette) aufgerufen wird. Wenn nicht, dann ergeben die nachfolgenden Berechnungen keinen Sinn, und wir brechen das Programm ab.\n\n2\n\nTeilen des Eingabestrings in zwei Hälften, den Teil vor dem Komma und den Teil nach dem Komma. Das Ergebnis ist eine Liste mit zwei Teilstrings.\n\n3\n\nBelegen der Variablen n mit der Länge des ersten Teilstrings (zur Erinnerung: der Index in Python beginnt mit 0).\n\n4\n\nWir durchlaufen die Zeichen im ersten Teilstring (die Ziffern vor dem Komma) und berechnen den Wert der jeweiligen Ziffer nach der Formel von Gleichung 2. Die Schleifenvariable haben wir hier bit genannt. Nach jedem Durchlauf verringern wir den Wert von n um 1.\n\n5\n\nBerechnung der Werte für die bits nach dem Komma. Hier erhöhen wir den Wert von m nach jedem Durchlauf um 1.\n\n\n\n\nFür das Rechnen mit Binärzahlen stellt Python sogenannte bitwise operations bereit:\n\n\n\nOperation\nErgebnis\n\n\n\n\nx | y\nbitwise or  von x und y\n\n\nx ^ y\nbitwise exclusive or  von x und y\n\n\nx & y\nbitwise and  von x und y\n\n\nx &lt;&lt; n\nx um n bits nach links verschoben\n\n\nx &gt;&gt; n\nx um n bits nach rechts verschoben\n\n\n~x\nbitwise not  : die bits von x umgekehrt\n\n\n\nBinärzahlen werden in der Regel zu Einheiten von acht bits zusammengefasst, die wir dann byte nennen. Wenn wir ein byte in der Form \\(b=b_7 \\ b_6 \\ b_5 \\ b_4 \\ b_3 \\ b_2 \\ b_1 \\ b_0\\) darstellen, dann können wir die bitwise operations als Mengenoperationen (siehe Kapitel 1) auf bytes begreifen, indem wir jedes gesetzte bit über seinen Index darstellen:\n\n1x = 0b10000010\ny = 0b10010000\n2print(f\"x = {x:#0b}\", \"= {7, 1}\")\nprint(f\"y = {y:#0b}\", \"= {7, 4}\")\n\n\n1\n\nDefinition von x als Binärzahl: wir verwenden hierzu das Präfix 0b.\n\n2\n\nAusgabe von x im Binärformat und der Menge der gesetzten Indizes, das sind die Stellen der Binärzahl, an denen ein bit auf 1 gesetzt ist. Wir verwenden hierzu einen sogenannten f-string für engl. formatted string.\n\n\n\n\nx = 0b10000010 = {7, 1}\ny = 0b10010000 = {7, 4}\n\n\nDie Mengenoperationen können dann so ausgeführt werden:\n\n# bitwise or\nprint(f\"Vereinigungsmenge (x|y): {x|y:#0b}\", \"= {7, 4, 1}\")\n\n# bitwise and\nprint(f\"Schnittmenge (x&y): {x&y:#0b}\", \"= {7}\")\n\n# bit clear (and not)\nprint(f\"Differenz (x&~y): {x&~y:#0b}\", \"= {1}\")\n\n# bitwise xor\nprint(f\"Symmetrische Differenz (x^y): {x^y:#0b}\", \"= {4, 1}\")\n\nVereinigungsmenge (x|y): 0b10010010 = {7, 4, 1}\nSchnittmenge (x&y): 0b10000000 = {7}\nDifferenz (x&~y): 0b10 = {1}\nSymmetrische Differenz (x^y): 0b10010 = {4, 1}\n\n\nDie shift Operatoren &lt;&lt; und &gt;&gt; verschieben die bits einer Binärzahl um \\(n\\) Stellen nach links bzw. rechts. Dabei wird die Zahl bei links-shift mit &lt;&lt; von rechts mit 0-bits aufgefüllt, der Wert der Zahl verdoppelt sich also mit jedem shift. Demnach ist z.B. x &lt;&lt; 3 gleichbedeutend mit \\(x\\cdot2^3\\).\n\na = 5\nprint(f\"a = {a:#0b} = {a}\")\nb = a &lt;&lt; 3\nprint(f\"b = {b:#0b} = {b}\")\nassert b == a * 2**3\n\na = 0b101 = 5\nb = 0b101000 = 40\n\n\nBei einem rechts-shift mit x &gt;&gt; n werden n Stellen am rechten Ende von x abgeschnitten, der Wert der Zahl halbiert sich also mit jedem shift. Wenn das letzte bit \\(b_0\\) dabei gesetzt ist, die Zahl also ungerade ist, dann geht der Rest der Division durch 2 dabei verloren; es gilt also: x &gt;&gt; 1 ist gleichbedeutend mit x // 2.\n\nprint(f\"a = {a:#0b} = {a}\")\nc = a &gt;&gt; 1\nprint(f\"c = {c:#0b} = {c}\")\nassert c == a // 2\n\na = 0b101 = 5\nc = 0b10 = 2",
    "crumbs": [
      "Arithmetik",
      "Zahlenbereiche und Zahlensysteme"
    ]
  },
  {
    "objectID": "arithmetik/3-mengen.html#übungen",
    "href": "arithmetik/3-mengen.html#übungen",
    "title": "Zahlenbereiche und Zahlensysteme",
    "section": "4 Übungen",
    "text": "4 Übungen\nDie Übungen dieser Lektion findest du im Notebook arithmetik/_mengen.ipynb. Öffne diese Datei in Jupyter und erforsche des Rechnen mit verschiedenen Zahlensystemen.",
    "crumbs": [
      "Arithmetik",
      "Zahlenbereiche und Zahlensysteme"
    ]
  },
  {
    "objectID": "arithmetik/2-teiler.html",
    "href": "arithmetik/2-teiler.html",
    "title": "Teiler und Vielfache",
    "section": "",
    "text": "In diesem Kapitel machen wir einen kleinen Ausflug in die Welt der Zahlen und beschäftigen uns mit der Teilbarkeit natürlicher Zahlen. Außerdem wollen wir unsere ersten Funktionen in Python definieren und einen ersten Algorithmus implementieren.",
    "crumbs": [
      "Arithmetik",
      "Teiler und Vielfache"
    ]
  },
  {
    "objectID": "arithmetik/2-teiler.html#sec-primfaktor",
    "href": "arithmetik/2-teiler.html#sec-primfaktor",
    "title": "Teiler und Vielfache",
    "section": "1 Primfaktorzerlegung",
    "text": "1 Primfaktorzerlegung\nPrimzahlen spielen in der Mathematik eine erstaunlich große Rolle, wir wollen sie hier aber nur im Rahmen der Teilbarkeit von natürlichen Zahlen betrachten.\nEine Primzahl ist eine natürliche Zahl, die genau zwei Teiler hat (und somit größer als 1 ist). Diese zwei Teiler sind 1 und die Zahl selber. Eine Primzahl kann daher nicht als das Produkt zweier kleineren Zahlen geschrieben werden, also nicht in Faktoren zerlegt werden. Alle anderen natürlichen Zahlen können dagegen in Primfaktoren zerlegt werden, d.h. sie können als das Produkt von zwei oder mehr Primzahlen geschrieben werden.\n\n\n\n\n\n\nFundamentalsatz der Arithmetik\n\n\n\nJede natürliche Zahl \\(n&gt;1\\) besitzt eine (bis auf die Reihenfolge) eindeutige Primfakorzerlegung, d.h. zwei unterschiedliche Zerlegungen unterscheiden sich nur in der Reihenfolge der Faktoren.\n\n\n\n\n\n\n\n\nBeispiele für Primfaktorzerlegungen\n\n\n\n\n\\(30=2\\cdot 3 \\cdot 5\\)\n\\(37=37\\) (Primzahl)\n\\(1001=7\\cdot 11 \\cdot 13\\)\n\\(1024=\\underbrace{2\\cdots 2}_\\text{10 mal}=2^{10}\\) (Zweierpotenz)\n\\(6936=2\\cdot 2\\cdot 2\\cdot 3\\cdot 17\\cdot 17=2^3\\cdot 3\\cdot 17^2\\)\n\\(10000=2^4\\cdot 5^4\\) (Zehnerpotenz)\n\n\n\nWenn du mit der Potenzdartsellung von Zahlen noch nicht vertraut bist, schaue dir ??? an; dort erhältst du eine Einführung in Potenzrechnung.\n\n\n\n\n\n\nZwischenübung\n\n\n\nZerlege die Zahlen 12, 60, 128 und 1.000 in ihre Primfaktoren und stelle sie in Potenzen dieser Faktoren dar.\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\n\\(12=2\\cdot 2\\cdot 3=2^2\\cdot 3^1\\)\n\\(60=2\\cdot 2\\cdot 3\\cdot 5=2^2\\cdot 3^1\\cdot 5^1\\)\n\\(128=\\underbrace{2\\cdots 2}_\\text{7 mal}=2^7\\) (Zweierpotenz)\n\\(1.000=2^3\\cdot 5^3=10\\cdot 10\\cdot 10=10^3\\) (Zehnerpotenz: die drei Nullen der Ausgangszahl führen zur dritten Potenz von 10)",
    "crumbs": [
      "Arithmetik",
      "Teiler und Vielfache"
    ]
  },
  {
    "objectID": "arithmetik/2-teiler.html#sec-division",
    "href": "arithmetik/2-teiler.html#sec-division",
    "title": "Teiler und Vielfache",
    "section": "2 Division mit Rest",
    "text": "2 Division mit Rest\nWenn zwei natürliche Zahlen, der Dividend \\(n\\), und der Divisor \\(m\\) (ungleich 0) mit Rest dividiert werden sollen, wenn also \\(n\\div m\\) berechnet werden soll, so wird gefragt, wie man die Zahl \\(n\\) als Vielfaches von \\(m\\) und einem Rest darstellen kann:\n\n\n\n\n\n\nDivision mit Rest\n\n\n\n\\[\nn = m \\cdot q + r, \\quad 0 \\leq r &lt; m.\n\\tag{1}\\] Hier ist \\(q\\) der sogenannte Ganzzahlqotient und \\(r\\) der Rest der Division. Entscheidende Nebenbedingung ist, dass \\(r\\) eine ganze Zahl größer oder gleich 0 und kleiner \\(m\\) ist.\n\n\nDer Rest ist also die Differenz zwischen dem Dividenden \\(n\\) und dem größten Vielfachen des Divisors \\(m\\), das höchstens so groß ist wie der Dividend: \\(\\ r=n-m\\cdot q\\).\nEin Rest ungleich 0 ergibt sich folglich genau dann, wenn der Dividend kein Vielfaches des Divisors ist. Man sagt auch: Der Dividend ist nicht durch den Divisor teilbar, weshalb ein Rest übrigbleibt.\n\n\n\n\n\n\nBeispiele für Division mit Rest\n\n\n\n\n\\(9 \\div 4 = 2 \\ \\) mit Rest \\(1\\), weil \\(\\ 9=4\\cdot 2 + 1\\) (vier passt zweimal in neun und es bleibt eins übrig)\n\\(2 \\div 4 = 0 \\ \\) mit Rest \\(2\\), weil \\(\\ 2=4\\cdot 0 + 2\\)\n\\(4 \\div 4 = 1 \\ \\) mit Rest \\(0\\), weil \\(\\ 4=4\\cdot 1 + 0\\)\n\n\n\n\n\n\n\n\n\nZwischenübung\n\n\n\nStelle das Ergebnis der fogenden Divisionen als ganze Zahl mit Rest dar:\n\n\\(128\\div 127\\)\n\\(127\\div 128\\)\n\\(777\\div 11\\)\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\n\\(128\\div 127=1\\), Rest 1\n\\(127\\div 128=0\\), Rest 127\n\\(777\\div 11=70\\), Rest 7\n\n\n\n\nMan kann eine Funktion definieren, die jedem Zahlenpaar \\((n, m)\\) einen eindeutigen Teilerrest \\(r\\) zuordnet. Diese Funktion nennt man Modulo und kürzt sie meistens mit mod ab.\nWir werden uns in späteren Kapiteln ausführlich mit Funktionen beschäftigen (siehe ???); ohne auf die Details einzugehen, wollen wir an dieser Stelle die Funktion Modulo in Python implementieren, um uns mit der Syntax einer Funktionsdefinition vertraut zu machen. Vergegenwärtigen wir uns hierzu nochmal die obige Definition des Restes einer ganzzahligen Division: \\[\nr=n-m\\cdot q,\n\\] wobei \\(q\\) der ganzzahlige Quotient von \\(n \\div m\\) ist.\n\n1def mod(n, m):\n2  q = n // m\n3  r = n - m * q\n4  return r\n\nassert mod(9,4) == 1\nassert mod(2,4) == 2\nassert mod(4,4) == 0\n\n\n1\n\nEine Funtionsdefinition wird eingeleitet mit dem Schlüsselwort def, gefolgt von den Parametern der Funktion in Klammern und einem Doppelpunkt :, der den Beginn eines Code-Blocks signalisiert. Alle nachfolgenden Zeilen, die zu diesem Code-Block gehören sollen, werden um die selbe Anzahl von Stellen eingerückt.\n\n2\n\nZuweisung des Ergebnisses der ganzzahligen Division \\(n \\div m\\) an den Bezeichner q. Wir wählen hier die selben Bezeichner, die wir auch in der mathematischen Definition verwendet haben.\n\n3\n\nBerechnung des Restes der Division gemäß der mathematischen Definition und Zuweisung an den Bezeichner r.\n\n4\n\nDie Funtion liefert den Rest der Division r als ihr Ergebnis zurück. Dies wird mit dem Schlüsselwort return angezeigt.",
    "crumbs": [
      "Arithmetik",
      "Teiler und Vielfache"
    ]
  },
  {
    "objectID": "arithmetik/2-teiler.html#sec-ggT",
    "href": "arithmetik/2-teiler.html#sec-ggT",
    "title": "Teiler und Vielfache",
    "section": "3 Gößter gemeinsamer Teiler",
    "text": "3 Gößter gemeinsamer Teiler\nDer größte gemeinsame Teiler (ggT) ist die größte natürliche Zahl, durch die sich zwei ganze Zahlen jeweils ohne Rest teilen lassen. Der ggT zweier ganzer Zahlen \\(a\\) und \\(b\\) ist demnach eine ganze Zahl \\(m\\) mit der Eigenschaft, dass sie Teiler sowohl von \\(a\\) als auch von \\(b\\) ist und dass jede ganze Zahl, die ebenfalls die Zahlen \\(a\\) und \\(b\\) teilt, auch Teiler von \\(m\\) ist.\nMan kann den ggT über die Primfaktorzerlegung der beiden gegebenen Zahlen bestimmen. Wir wollen das einmal exemplarisch für die beiden Zahlen 3528 und 3780 durchführen:\n\n\n\n\n\n\nPrimfaktozerlegung für 3528 und 3780\n\n\n\n\n\\(3528=2^3\\cdot 3^2\\cdot 5^0\\cdot 7^2\\)\n\\(3780=2^2\\cdot 3^3\\cdot 5^1\\cdot 7^1\\)\n\n\n\n\nassert 2**3 * 3**2 * 5**0 * 7**2 == 3528\nassert 2**2 * 3**3 * 5**1 * 7**1 == 3780\n\nPrimfaktoren, die in einer der beiden Zahlen nicht vorkommen, können wir dabei in der Form \\(x^0\\) darstellen, um einen besseren Überblick über die Faktoren zu erhalten. \\(x^0\\) ergibt immer 1, daher hat dieser zusätzliche Faktor keinen Einfluß auf das ensprechende Produkt.\nFür den ggT nimmt man die Primfaktoren, die in beiden Zerlegungen vorkommen, und als zugehörigen Exponenten den jeweils kleineren der Ausgangsexponenten:\n\n\n\n\n\n\nGrößter gemeinsamer Teiler für 3528 und 7380\n\n\n\n\\(ggT(3528, 3780)=2^2\\cdot 3^2\\cdot 5^0\\cdot 7^1=252\\)\n\n\n\nassert 2**2 * 3**2 * 5**0 * 7**1 == 252\n\nDie Berechnung der Primfaktorzerlegung großer Zahlen und damit auch die Bestimmung des größten gemeinsamen Teilers über die Primfaktorzerlegungen ist sehr aufwändig. Mit dem euklidischen Algorithmus existiert jedoch auch ein effizientes Verfahren, um den größten gemeinsamen Teiler zweier Zahlen zu berechnen.\nUnter einem Algorithmus verstehen wir eine detaillierte, schrittweise Rechenvorschrift, in der sich möglichweise einige Schritte wiederholen, die am Ende das gewünschte Resultat ausgibt.\n\n\n\n\n\n\nKlassischer euklidischer Algorithmus\n\n\n\nDer klassische euklidische Algorithmus berechnet den größten gemeinsamen Teiler, indem er nach einem gemeinsamen Maß für die Längen zweier Linien sucht:\n\nDie kleinere zweier Längen wird von der größeren mehrfach abgezogen, bis ein Ergebnis übrig bleibt, das kleiner als die kleinere Länge ist.\nBei einer Differenz von 0 ist man fertig und die kleinere Länge das Ergebnis.\nAndernfalls wiederholt man dieses Abziehen – jetzt aber mit der kleineren Länge anstelle der größeren und der letzten Differenz anstelle der kleineren Länge.\n\n\n\n\n\n\n\n\n\nBerechnung des ggT von 143 und 65\n\n\n\n\n\\(143-65=78\\)\n\\(78-65=13, \\quad (&lt;65)\\)\n\\(65-13=52\\)\n\\(52-13=39\\)\n\\(39-13=26\\)\n\\(26-13=13\\)\n\\(13-13=0, \\quad ggT = 13\\)\n\n\n\n\n\n\n\n\n\nZwischenübung\n\n\n\nPrüfe, ob du diese Rechenvorschrift verstanden hast, indem du sie mit den Werten 60 und 24 selbst durchführst.\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\n\\(60-24=36\\)\n\\(36-24=12, \\quad (&lt;24)\\)\n\\(24-12=12\\)\n\\(12-12=0, \\quad ggt = 12\\)\n\n\n\n\nMit diesem Wissen können wir jetzt den Algorithmus in Python implementieren:\n\n1def euklid_klassisch(a, b):\n2  if b &gt; a: a, b = b, a\n3  zähler = 1\n4  d = a - b\n5  while d &gt; 0:\n6    if d &lt; b: a, b = b, d\n7    else: a = d\n8    d = a - b\n9    zähler += 1\n10  print(zähler)\n11  return b\n\n\n1\n\nDefinition der Funktion euklid_klassisch. Um genau zu sein, bezeichen wir diese Zeile als die Signatur der Funktion, die den Namen der Funktion und deren Parameter enthält. Der nachfolgende (eingerückte) Code-Block gehört ebenfalls zur Funktionsdefinition.\n\n2\n\nWir wollen immer die kleinere von der größeren Länge abziehen. Da wir aber nicht wissen, welche der gegebenen Funktionsparameter der größere ist, testen wir das mit if b &gt; a: wenn b größer ist als a, dann vertauschen wir die Parameter. Auf diese Weise stellen wir sicher, dass a immer die größere Länge bezeichnet.\n\n3\n\nDiese Zeile ist für den Algorithmus eigentlich nicht notwendig. Wir wollen aber die Anzahl der durchgeführten Subtraktionen nachverfolgen, um eine Aussage über die Effizienz des Algorithmus machen zu können. Also legen wir einen Zähler an, den wir mit 1 initialisieren, da wir in der folgenden Zeile gleich die erste Subtraktion durchführen.\n\n4\n\nBestimmen der ersten Differenz zwischen a und b. Wir wissen aus (2), dass a immer die größere Länge ist.\n\n5\n\nDer Algorithmus besagt in seinem 1. Schritt, das wir wiederholt die kleinere von der größeren Länge abziehen müssen. Daher starten wir eine Programm-Schleife mit dem Schlüsselwort while und geben als Schleifenbedingung d &gt; 0 an. Damit werden die Anweisungen in der Schleife solange wiederholt bis die Differenz gleich 0 ist. Wir wissen aus Schritt 2 des Algorithmus, dass wir dann fertig sind.\n\n6\n\nInnerhalb der Schleife prüfen wir zuerst, ob die letzte Differenz kleiner ist als die kleinere Länge (b). Falls ja, vertauschen wir a mit b, und b mit d, so wie in Schritt 3 des Algorithmus gefordert.\n\n7\n\nAnderenfalls ersetzen wir a mit d, wie in Schritt 1 des Algorithmus gefordert.\n\n8\n\nIn beiden Fällen berechnen wir schließlich die Differenz der neuen großen und kleinen Länge.\n\n9\n\nAls letzte Anweisung in der Schleife erhöhen wir den Zähler um 1.\n\n10\n\nNach der Schleife geben wir die Gesamtanzahl der durchgeführten Subtraktionen aus.\n\n11\n\nDie letze Anweisung der Funktion gibt die aktuelle kleinere Länge als Funktionswert zurück. Gemäß Schritt 2 des Algorithmus ist das unser Ergebnis: der kleinste gemeinsame Teiler von a und b.\n\n\n\n\n\nassert euklid_klassisch(143, 65) == 13\nassert euklid_klassisch(3528, 3780) == 252\n\n7\n15\n\n\nWir sehen, dass es keine Rolle spielt, in welcher Reihenfolge wir die Argumente der Funktion angeben, es wird immer das korrekte Ergebnis ausgegeben.\n\n\n\n\n\n\nParameter und Argumente\n\n\n\nDie Variablen, die wir in der Funktionsdefinition in Klammern angeben, heißen Parameter der Funktion. Wenn wir eine Funktion dann mit konkreten Werten aufrufen, nennen wir diese Werte Argumente der Funktion.\n\n\nWir sehen aber auch, dass die Anzahl der notwendigen Operationen (in diesem Fall Subtraktionen) zunimmt, wenn die Argumente größer werden. Dies kann bei sehr großen Zahlen zu Effizienzproblemen führen, im schlimmsten Fall dazu, dass die Funktion kein Ergebnis mehr liefert. Wenn wir Algorithmen in einer Programmiersprache implementieren, wollen wir also auch immer darauf achten, eine möglichst effiziente Lösung zu finden, d.h. eine Lösung, die mit weniger Operationen auskommt.\nIn unserem Beispiel euklid_klassisch(143, 65) sehen wir, dass die Funktion 7 Subtraktionen für die Berechnung des Ergebnisses benötigt; das stimmt mit unserer manuellen Berechnung überein, die nachfolgend noch einmal angegeben wird:\n\n\n\n\n\n\nBerechnung des ggT von 143 und 65\n\n\n\n\n\\(143-65=78\\)\n\\(78-65=13, \\quad (&lt;65)\\)\n\\(65-13=52\\)\n\\(52-13=39\\)\n\\(39-13=26\\)\n\\(26-13=13\\)\n\\(13-13=0, \\quad ggT = 13\\)\n\n\n\nBei näherer Betrachtung erkennen wir, dass zunächst zweimal 65 von 143 abgezogen wird, und dann fünfmal 13 von 65 abgezogen wird. Das ist kein Zufall, denn 65 passt zweimal in 143 und 13 passt fünfmal in 143, da \\(2\\cdot 65+rest=143\\) und \\(5\\cdot 13+rest=65\\), wobei der Rest im ersten Fall 13 ist und im zweiten Fall 0, d.h. 13 passt genau fünfmal in 65. Das erinnert doch sehr an die Division mit Rest aus Kapitel 2.\nAnstatt also \\(n\\)-mal b von a abzuziehen , können wir a durch b teilen, mit dem Ergebnis \\(n\\) und Rest \\(r\\). Am ganzzahligen Quotienten \\(n\\) sind wir gar nicht interessiert, sondern wir können gleich mit dem Rest \\(r\\) weiterrechnen, so wie in den Zeilen 3 bis 7 der manuellen Berechnung (der Rest \\(r\\) ist hier 13).\nDiese Überlegungen führen zum sogenannten modernen euklidischen Algorithmus:\n\n\n\n\n\n\nModerner euklidischer Algorithmus\n\n\n\nIn den aufeinanderfolgenden Schritten wird jeweils eine Division mit Rest durchgeführt, wobei im nächsten Schritt der Divisor zum neuen Dividenden und der Rest zum neuen Divisor wird. Der Divisor, bei dem sich Rest 0 ergibt, ist der größte gemeinsame Teiler der Ausgangszahlen.\n\n\nFür unsere Beispielzahlen ergibt sich daraus folgende Berechnung:\n\n\n\n\n\n\nBerechnung des ggT nach dem modernen euklidischen Algorithmus\n\n\n\n\n\\(143\\div 65=2, \\quad\\mathrm{Rest} \\ 13\\)\n\\(65\\div 13=5, \\quad\\mathrm{Rest } \\ 0\\)\n\\(ggT(143, 65)=13\\)\n\n\n\nWir brauchen also nur zwei Schritte zur Berechnung des ggT mit dem modernen Algorithmus, genauso wie für unser Beispiel aus der Primfaktorzerlegung:\n\n\n\n\n\n\nZwischenübung\n\n\n\nFühre die Berechnung des ggT für die Werte 3780 und 3528 gemäß dem letzten Beispiel durch.\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\n\\(3780\\div 3528=1, \\quad\\mathrm{Rest} \\ 252\\)\n\\(3528\\div 252=14, \\quad\\mathrm{Rest} \\ 0\\)\n\\(ggT(3780, 3528)=252\\)\n\n\n\n\nMit diesem Wissen können wir den modernen euklidischen Algorithmus in Python implementieren:\n\ndef euklid_modern(a, b):\n  zähler = 0\n1  while b != 0:\n2    r = mod(a, b)\n3    a = b\n4    b = r\n    zähler += 1\n  print(zähler)\n5  return a\n\n\n1\n\nBeginn der Programmschleife mit Schleifenbedingung b != 0; die Schleife wird also ausgeführt, solange b nicht 0 ist.\n\n2\n\nWir führen eine Division mit Rest aus und verwenden dafür unsere mod() Funktion aus Kapitel 2.\n\n3\n\nDann machen wir den Divisor zum neuen Dividenden…\n\n4\n\nund den Rest der Division r zum neuen Divisor.\n\n5\n\nEigentlich sollten wir den letzten Divisor b als Ergebnis ausgeben, wenn mod(a, b) gleich 0 ist. Da dieser Test aber erst vor dem nächsten Schleifendurchlauf durchgeführt wird (1), wird im letzten Durchlauf nochmal a = b (2) und b = r (3) gesetzt. Das führt dazu, dass nach Beendigung der Schleife b immer gleich 0 ist; wir müssen also a als letzten Divisor ausgeben.\n\n\n\n\n\nassert euklid_modern(143, 65) == 13\nassert euklid_modern(3780, 3528) == 252\n\n2\n2\n\n\nAufgrund der Möglichkeit, in Python mehrere Zuweisungen gleichzeitig vorzunehmen, indem wir die Bezeichner und die zugewiesen Werte jeweils mit einem Komma trennen, hätten wir den kompletten Algorithmus der Zeilen (2) bis (4) auch in eine Zeile schreiben können:\na, b = b, mod(a, b).\nAuch bei dieser Implementierung spielt die Reihenfolge der Argumente keine Rolle:\n\nassert euklid_modern(143, 65) == euklid_modern(65, 143)\n\n2\n3\n\n\nWir sehen aber, dass eine zusätzliche Operation notwendig wird, wenn das kleinere Argument zuerst kommt. Das liegt daran, dass \\(65 \\div 143\\) gleich 0, mit Rest 65 ist, d.h. beim nächsten Schleifendurchlauf wird mod(143, 65) aufgerufen, die Variante mit dem größeren Argument zuerst. Die zusätzliche Operation können wir aus Effizienzsicht gut verkraften, da wir uns ja den Test auf b &gt; a sparen.\nDer ggT wird häufig auch als rekursive Funktion realisiert. Wir werden Rekursion in einer späteren Lektion ausführlich behandeln; ich möchte die Implementierung eines rekursiven ggT hier aber schon als kleinen Vorgeschmack vorstellen:\n\ndef ggT(a, b):\n1  if b == 0:\n2    return a\n  else:\n3    return ggT(b, mod(a, b))\n\n\n1\n\nAbbruchbedingung: wenn b gleich 0 ist, dann wird die Rekursion gestoppt.\n\n2\n\nWenn die Abbruchbedingung greift, geben wir a als Ergebnis der Berechnung aus, und der Programmablauf ist beendet.\n\n3\n\nRekursiver Aufruf: die Funktion ruft sich selbst mit neuen Argumenten auf. Die Argumente werden entsprechend dem Algorithmus gesetzt: der Divisor wird zum neuen Dividenden und der Rest zum neuen Divisor.\n\n\n\n\n\nassert ggT(143, 65) == 13\nassert ggT(3780, 3528) == 252\n\nDie rekursive Implementierung kommt ohne zusätzliche Variablen aus, und wir benötigen auch keine explizite Schleife, da diese durch den rekursiven Aufruf ersetzt wird. Das kann zu einem sehr übesichtlichen und eleganten Programm führen, dessen Bedeutung sich dem Leser sofort erschließt. Viele erfahrene Programmierer bevorzugen daher eine rekursive Implementierung.\nAuf der anderen Seite ist es nicht immer sofort ersichtlich, wie eine iterative Implementierung (d.h. eine Implementierung mit Schleifen) in eine rekursive Variante überführt werden kann. Dazu bedarf es einiger Erfahrung; ich erwarte nicht, dass du jetzt bereits eigene rekursive Programme schreiben kannst.",
    "crumbs": [
      "Arithmetik",
      "Teiler und Vielfache"
    ]
  },
  {
    "objectID": "arithmetik/2-teiler.html#kleinstes-gemeinsames-vielfaches",
    "href": "arithmetik/2-teiler.html#kleinstes-gemeinsames-vielfaches",
    "title": "Teiler und Vielfache",
    "section": "4 Kleinstes gemeinsames Vielfaches",
    "text": "4 Kleinstes gemeinsames Vielfaches\n\n4.1 Das kgV von zwei Zahlen\nDas kleinste gemeinsame Vielfache (kgV) zweier ganzer Zahlen \\(m\\) und \\(n\\) ist die kleinste positive natürliche Zahl, die sowohl Vielfaches von \\(m\\) als auch Vielfaches von \\(n\\) ist. Zusätzlich wird für den Fall \\(m = 0\\) oder \\(n = 0\\) das kgV definiert als: \\(kgV ⁡(m, n) = 0\\).\n\n\n\n\n\n\nBerechnung des kgV von 12 und 18 über die Vielfachen\n\n\n\n\nDie Vielfachen von 12 sind: 12, 24, 36, 48, 60, 72, 84, 96, 108,…\nDie Vielfachen von 18 sind: 18, 36, 54, 72, 90, 108, …\nDie gemeinsamen Vielfachen von 12 und 18 sind also: 36, 72, 108, …\nund das kleinste von diesen ist 36: \\(kgV(12, 18)=36\\).\n\n\n\nMan kann das kgV über die Primfaktorzerlegung (siehe Kapitel 1) der beiden gegebenen Zahlen bestimmen. Wir nehmen hierzu wieder das Beispiel aus Kapitel 2:\n\n\n\n\n\n\nPrimfaktozerlegung für 3528 und 3780\n\n\n\n\n\\(3528=2^3\\cdot 3^2\\cdot 7^2\\)\n\\(3780=2^2\\cdot 3^3\\cdot 5^1\\cdot 7^1\\)\n\n\n\nFür das kgV nimmt man die Primfaktoren, die in mindestens einer der beiden Zerlegungen vorkommen, und als zugehörigen Exponenten den jeweils größeren der Ausgangsexponenten:\n\n\n\n\n\n\nKleinstes gemeinsames Vielfaches für 3528 und 7380\n\n\n\n\\(kgV(3528, 3780)=2^3\\cdot 3^3\\cdot 5^1\\cdot 7^2=52.920\\)\n\n\n\nassert 2**3 * 3**3 * 5**1 * 7**2 == 52920\n\n\n\n\n\n\n\nZwischenübung\n\n\n\nBestimme das kgV von 60 und 24 über die Primfaktorzerlegung.\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\n\\(60=2^2\\cdot 3^1\\cdot 5^1\\)\n\\(24=2^3\\cdot 3^1\\cdot 5^0\\)\n\\(kgV(60, 24)=2^3\\cdot 3^1\\cdot 5^1=120\\)\n\n\n\n\nMan kann das kgV aber auch mit Hilfe des ggT berechnen; es gilt der folgende Grundsatz:\n\n\n\n\n\n\nProdukt von ggT und kgV\n\n\n\nDas Produkt des ggT und des kgV zweier natürlicher Zahlen ist gleich dem Produkt beider Zahlen: \\[\nggT(m, n) \\cdot kgV(m, n) = m \\cdot n\n\\tag{2}\\]\n\n\nWenn der ggT zweier Zahlen bekannt ist, dann kann man das kgV also wie folgt berechnen:\n\n\n\n\n\n\nBerechnung des kgV aus dem ggT\n\n\n\n\\[\nkgV(m, n)=(m\\cdot n)\\div ggT(m, n)\n\\tag{3}\\]\n\n\nFür die Zahlen 12 und 18 ergibt sich also folgende Berechnung:\n\n\n\n\n\n\nBerechnung des kgV von 12 und 18 über den ggT\n\n\n\n\n\\(ggT(12, 18)=6\\)\n\\(kgV(12, 18)=(12\\cdot 18)\\div 6=12\\cdot 3=36\\)\n\n\n\n\n\n\n\n\n\nZwischenübung\n\n\n\nBestimme das kgV von 60 und 24 über den ggT.\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\n\\(ggT(60, 24)=12\\)\n\\(kgV(60, 24)=(60\\cdot 24)\\div 12=60\\cdot 2=120\\)\n\n\n\n\nDa wir aus Kapitel 3 bereits über eine Funktion zur Berechnung des ggT verfügen, ist die Implementierung des kgV in Python einfach:\n\ndef kgv_2(m, n): return m * n // ggT(m, n)\n\nassert kgv_2(12, 18) == 36\nassert kgv_2(60, 24) == 120\nassert kgv_2(3528, 3780) == 52920\n\n\n\n4.2 Das kgV von mehreren Zahlen\nMan verwendet zur Berechnung des kgV mehrerer Zahlen alle Primfaktoren, die in mindestens einer der Zahlen vorkommen, mit der jeweils höchsten vorkommenden Potenz, zum Beispiel:\n\n\n\n\n\n\nkgV der Zahlen 144, 160 und 175\n\n\n\n\n\\(144=2^4\\cdot 3^2\\)\n\\(160=2^5\\cdot 5^1\\)\n\\(175=5^2\\cdot 7^1\\)\n\\(kgV(144, 160, 175)=2^5\\cdot 3^2\\cdot 5^2\\cdot 7^1=50.400\\)\n\n\n\n\nassert 2**5 * 3**2 * 5**2 * 7**1 == 50400\n\nWir könnten auch zunächst \\(kgV ⁡(144, 160)=1440\\) berechnen und danach \\(kgV(1440, 175)= 50.400\\), denn als eine zweistellige Verknüpfung auf den ganzen Zahlen ist das kgV assoziativ:\n\n\n\n\n\n\nAssoziativität des kgV\n\n\n\n\\[\nkgv(m, kgV(n, p))=kgV(kgV(m, n), p)\n\\tag{4}\\]\n\n\nWir machen uns diesen Umstand zunütze und definieren eine neue Funktion in Python für die Berechnung des kgV für drei Zahlen:\n\n1def kgv_3(m, n, p):\n2  kgv_mn = kgv_2(m, n)\n3  return kgv_2(kgv_mn, p)\n\nassert kgv_3(144, 160, 175) == 50400\n\n\n1\n\nSignatur für die Funktion kgv_3 mit drei Parametern\n\n2\n\nBerechnung des kgV für die ersten beiden Parameter\n\n3\n\nBerechnung und Rückgabe des kgV mit dem dritten Parameter\n\n\n\n\nPython unterstützt nicht das Überladen von Funktionen. Wenn wir zwei verschiedene Varianten einer Funktion definieren wollen (z.B. eine Variante, die zwei Argumente akzeptiert und eine Variante, die drei Argumente akzeptiert, wie in unserem Fall), dann müssen wir diesen Funktionen in Python verschiedene Namen geben. Das ist der Grund, weshalb ich die Variante für zwei Argumente kgv_2 genannt habe, und die Variante für drei Argumente kgv_3.\n\n\n\n\n\n\nÜberladen von Funktionen\n\n\n\nEinige statisch kompilierte Programmiersprachen (z.B. Java und C++) bieten die Möglichkeit, denselben Funtionsnamen für verwandte Funtionen zu verwenden. Das nennt man dann Überladen der Funktion.\nDie Signaturen der Funktionen müssen sich dann aber unterscheiden lassen: entweder durch die Anzahl der zugelassenen Parameter, oder dadurch, dass den Parametern unterschiedliche Datentypen zugeordnet werden.\nDa Python aber eine dynamische Spache ist (d.h. eine Funktion wird erst dann kompiliert, wenn sie aufgerufen wird), und weil die Datentypen der Parameter zum Zeitpunkt der Kompilierung noch nicht bekannt sind, ist es in Python nicht möglich, Funktionen zu überladen.\n\n\nWir können das Problem aber umgehen, indem wir einen zusätzlichen Standardparameter definieren und innerhalb der Funktion prüfen, ob dieser beim Aufruf der Funktion gesetzt wurde:\n\n1def kgV(m, n, p=None):\n2  if p:\n3    kgv_mn = kgV(m, n)\n    return kgV(kgv_mn, p)\n  else:\n4    return m * n // ggT(m, n)\n\nassert kgV(144, 160, 175) == 50400\n\n\n1\n\nSignatur der Funktion kgV mit drei Parameterm. Der dritte Parameter p wird als Standardparameter definiert, indem wir ihm den Wert None zuweisen. Wenn wir später die Funktion mit nur zwei Argumenten aufrufen, dann ist p undefiniert. Wenn wir sie mit drei Argumenten aufrufen, dann ist p gleich dem dritten Argument.\n\n2\n\nTest, ob p gesetzt ist, d.h. ob drei Argumente angegeben wurden.\n\n3\n\nFalls ja, berechnen wir das Ergebnis so wie in kgv_3, nur dass wir eben wieder kgV mit zwei Argumenten aufrufen.\n\n4\n\nFalls p nicht gesetzt ist, berechnen wir das kgV wie in kgv_2.\n\n\n\n\nOb diese Lösung dann leichter verständlich ist, kannst für dich selbst entscheiden; grundsätzlich sind beide Varianten gleichwertig und führen zum selben Ergebnis.",
    "crumbs": [
      "Arithmetik",
      "Teiler und Vielfache"
    ]
  },
  {
    "objectID": "arithmetik/2-teiler.html#übungen",
    "href": "arithmetik/2-teiler.html#übungen",
    "title": "Teiler und Vielfache",
    "section": "5 Übungen",
    "text": "5 Übungen\nDu bist jetzt bereit, deine ersten mathematischen Probleme mit Python zu lösen.\nFalls du Python und Jupyter noch nicht installiert hast, dann sieh in Lektion Rechenregeln nach und richte deine Arbeitsumgebung ein.\nUm mit den Jupyter-Notebooks dieses Tutorials arbeiten zu können, musst du sie dir zunächst herunterladen. Dafür brauchst du das Programm Git, dass du gemäß diesen Installationsanleitungen installieren kannst.\nWenn Git installiert ist, setze in deiner Kommandozeile den Befehl git clone https://github.com/okrischer/matheKapierenMitPython.git ab. Wechsle dann in das Verzeichnis matheKapierenMitPython und aktiviere deine Arbeitsumgebung mit conda activate matheKapieren.\nJetzt kannst du mit jupyter lab Jupyter starten, und es sollte sich ein neues Browser-Fenster öffnen. Öffne dort im File Browser (der Spalte ganz links im Browser-Fenster) das Verzeichnis arithmetik und dann mit einem Doppel-Klick das Notebook _teiler.ipynb. Folge dann den Anweisungen im Notebook.",
    "crumbs": [
      "Arithmetik",
      "Teiler und Vielfache"
    ]
  },
  {
    "objectID": "arithmetik/1-rechenregeln.html",
    "href": "arithmetik/1-rechenregeln.html",
    "title": "Grundlegende Rechenregeln",
    "section": "",
    "text": "Um mit Zahlen rechnen zu können, verknüpfen wir sie mit mathematischen Operatoren. Ein Operator in diesem Sinn ist nichts anders als ein Symbol für die beabsichtigte Berechnung. So werden zum Beispiel die vier Grundrechenarten Addition, Subtraktion, Multiplikation und Division durch die Operatoren \\(+, \\ -, \\ \\cdot, \\ \\div\\) ausgedrückt, während das Gleichheitszeichen (\\(=\\)) das Ergebnis der Berechnung angibt.\nIn diesem Kapitel werden wir untersuchen, wie wir verschiedene Operatoren miteinander verknüpfen können, um sinnvolle Ergebnisse für unsere Berechnungen zu erhalten.",
    "crumbs": [
      "Arithmetik",
      "Grundlegende Rechenregeln"
    ]
  },
  {
    "objectID": "arithmetik/1-rechenregeln.html#buchstabenrechnen",
    "href": "arithmetik/1-rechenregeln.html#buchstabenrechnen",
    "title": "Grundlegende Rechenregeln",
    "section": "1 Buchstabenrechnen",
    "text": "1 Buchstabenrechnen\nBuchstabenrechnen ist das Rechnen mit unbestimmten Zahlen. Wenn wir eine mathematische Aussage formulieren, die nicht nur für eine bestimmte Zahl, sondern für einen ganzen Zahlenbereich oder sogar für alle Zahlen gilt, dann benutzen wir statt einer Zahl einen Buchstaben. Der Buchstabe heißt dann Variable.\nAuch in Python können wir Variablen anlegen und ihnen gleichzeitig mit = einen Wert zuweisen. Das Gleichheitszeichen in Python darf also nicht mit dem mathematischen Gleichheitszeichen verwechselt werden. Wenn Variablen einmal angelegt sind, können wir mit ihnen wie mit Zahlen rechnen:\n\n1a = 3\n2b = 4\n3c = a + b - 2\n4# Die nächste Zeile gibt den Wert von c aus\nc\n\n\n1\n\nZuweisung der Zahl 3 an die Variable a\n\n2\n\nZuweisung der Zahl 4 an die Variable b\n\n3\n\nBerechnung von a + b - 2 und Zuweisung des Ergebnisses an die Variable c\n\n4\n\nEingaben, die nach dem # Zeichen erfolgen, werden als Kommentar gewertet. Kommentare bleiben bei der Auswertung eines Programms in Python unberücksichtigt.\n\n\n\n\n5\n\n\nWenn wir nun mehrere Berechnungen gleichzeitig durchführen wollen, dann verknüpfen wir Zahlen und Variablen mit den entsprechenden Operatoren und erhalten einen zusammengesetzten Ausdruck, den wir Term nennen.\n\n\n\n\n\n\nTerm\n\n\n\nEin Term ist ein mathematischer Ausdruck, der aus Zahlen, Variablen, mathematischen Operatoren und möglicherweise noch anderen mathematischen Symbolen besteht.\n\n\nDiese Definition führt uns gleich zur nächsten:\n\n\n\n\n\n\nGleichung\n\n\n\nWill man ausdrücken, dass ein Term \\(T_1\\) zu einem anderen Term \\(T_2\\) gleichwertig ist, so schreibt man \\[\nT_1 = T_2\n\\] Eine solche Darstellung heißt Gleichung. Die linke Seite der Gleichung ist \\(T_1\\), die rechte Seite ist \\(T_2\\).\n\n\nWir sehen hier die wahre Bedeutung des Gleichheitszeichen in der Mathematik: der Term auf der linken Seite von \\(=\\) ist gleichbedeutend mit dem Term auf der rechten Seite.\nIn Python können wir auch Terme definieren; allerdings wertet Python solche Terme sofort aus, d.h. es wird das Ergebnis berechnet, wenn alle Variablen bekannt sind:\n\nT_1 = a * c + b * c - c\nT_1\n\n30\n\n\nBei der Auswertung geht die ursprüngliche Form des Terms \\(T_1 = a \\cdot c + b \\cdot c - c\\) unwiederbringlich verloren, es bleibt nur das Ergebnis, in diesem Fall die Zahl \\(30\\). Aus diesem Grund ist Standard-Python nicht besonders gut für das Betreiben von Mathematik geeignet; seine Stärke liegt in der schnellen Berechnung von Ausdrücken, nicht in deren mathematischer Umformung.\nWir werden in einer späteren Lektion (siehe ???) sehen, wie wir diese Beschränkung umgehen können, indem wir eine zusätzliche Bibliothek (engl. library) installieren.\nIm letzten Code-Beispiel haben wir ein unbekanntes Zeichen * gesehen. Das liegt daran, dass die Operatoren in Python nicht eins zu eins den mathematischen Operatoren entsprechen. Die folgende Tabelle zeigt die Entsprechungen einiger mathematischer Operatoren mit denen in Python:\n\n\n\nBedeutung\nmathematischer Operator\nPython Operator\n\n\n\n\nAddition\n\\(+\\)\n+\n\n\nSubtraktion\n\\(-\\)\n-\n\n\nMultiplikation\n\\(\\cdot\\)\n*\n\n\nDivision\n\\(\\div\\)\n/\n\n\nganzzahlige Division\n\n//\n\n\nRest der Division\n\\(n \\mod{m}\\)\nn % m\n\n\nPotenz\n\\(a^x\\)\na**x",
    "crumbs": [
      "Arithmetik",
      "Grundlegende Rechenregeln"
    ]
  },
  {
    "objectID": "arithmetik/1-rechenregeln.html#teilbarkeitsregeln",
    "href": "arithmetik/1-rechenregeln.html#teilbarkeitsregeln",
    "title": "Grundlegende Rechenregeln",
    "section": "2 Teilbarkeitsregeln",
    "text": "2 Teilbarkeitsregeln\nWir werden uns in der Lektion Teiler und Vielfache ausführlich mit der Teilbarkeit natürlicher Zahlen befassen. An dieser Stelle wollen wir aber schon einige grundlegende Teilbarkeitsregeln betrachten.\nDie einzelnen Zeichen einer Zahl sind ihre Ziffern: \\(0,1,2,3,4,5,6,7,8,9\\). Aus den Eigenschaften der Ziffern lassen sich Teilbarkeitseigenschaften der Zahlen ableiten:\n\n\n\n\n\n\nTeilbarkeitsregeln\n\n\n\nEine ganze Zahl ist teilbar durch\n\n2, wenn die letzte Ziffer durch 2 teilbar ist\n3, wenn die Quersumme der Zahl (also die Summe der Ziffern) durch 3 teilbar ist\n4, wenn die Zahl aus den letzten beiden Ziffern durch 4 teilbar ist\n5, wenn die letzte Ziffer durch 5 teilbar ist (also 0 oder 5 ist)\n6, wenn die letzte Ziffer durch 2 und die Quersumme der Zahl durch 3 teilbar ist\n8, wenn die Zahl aus den letzten 3 Ziffern durch 8 teilbar ist\n9, wenn die Quersumme der Zahl durch 9 teilbar ist\n11, wenn die alternierende Quersumme der Zahl (also die Summe der Ziffern, die abwechselnd positives und negatives Vozeichen erhalten) durch 11 teilbar ist.\n\n\n\n\n\n\n\n\n\nBeispiele für Teilbarkeit\n\n\n\n\n2486 ist teilbar durch 2, denn 6 ist teilbar durch 2\n263.451 ist teilbar durch 3, denn die Quersumme \\(2+6+3+4+5+1=21\\) ist teilbar druch 3\n2.563.488 ist teilbar durch 4, denn 88 ist teilbar durch 4 (\\(22\\cdot4=88\\))\n823.620 ist teilbar durch 5, denn die letzte Ziffer ist 0\n2.598.018 ist teilbar durch 6, denn 8 ist teilbar durch 2 und die Quersumme \\(2+5+9+8+0+1+8=33\\) ist teilbar durch 3\n524.299.168 ist teilbar durch 8, denn 168 ist teilbar durch 8 (\\(21\\cdot8=168\\))\n11.929.545 ist teilbar durch 9, denn die Quersumme \\(1+1+9+2+9+5+4+5=36\\) ist teilbar durch 9 (\\(4\\cdot9=36\\))\n14.739.296 ist teilbar durch 11, denn die alternierende Quersumme \\(+1-4+7-3+9-2+9-6=11\\) ist teilbar durch 11",
    "crumbs": [
      "Arithmetik",
      "Grundlegende Rechenregeln"
    ]
  },
  {
    "objectID": "arithmetik/1-rechenregeln.html#grundgesetze-der-addition-und-multiplikation",
    "href": "arithmetik/1-rechenregeln.html#grundgesetze-der-addition-und-multiplikation",
    "title": "Grundlegende Rechenregeln",
    "section": "3 Grundgesetze der Addition und Multiplikation",
    "text": "3 Grundgesetze der Addition und Multiplikation\nWenn wir einen Term betrachten, wie z.B. im letzten Code-Beispiel \\(T_1=a \\cdot c + b \\cdot c - c\\), dann ist nicht sofort offensichtlich, wie wir das Ergebnis am besten berechnen. In diesem Abschnitt wollen wir erkunden, wie wir solche komplexe Ausdrücke vereinfachen können, um uns Rechenarbeit zu ersparen.\nEin erstes Beispiel in Python:\n\nT_2 = c*(a+b-1)\nassert T_1 == T_2\n\nWir sehen hier eine neue Anweisung assert, deren Bedeutung so zu verstehen ist:\n\n\n\n\n\n\nGleichheit mit assert\n\n\n\nDie assert Anweisung in Python prüft, ob der nachfolgend angegebene Ausdruck wahr ist. Um zwei Werte auf Gleichheit zu überprüfen, verwenden wir in Python das doppeltes Gleichheitsyeichen ==, das einen Wahrheitswert True oder False zurückliefert.\nWenn der Wahrheitswert True ist, dann passiert beim Aufruf von assert gar nichts, anderenfalls wird ein Fehler ausgegeben.\n\n\nOffensichtlich gilt also die Gleichung \\(T_1=T_2\\) und damit \\(a \\cdot c + b \\cdot c - c = c \\cdot(a+b-1)\\), zumindest für die gegebenen Werte von \\(a, b\\) und \\(c\\). Wir wollen in der Mathematik aber zeigen, dass die Gleichung für alle möglichen Werte von \\(a, b\\) und \\(c\\) gilt. Deshalb brauchen wir Rechengesetze, die eine äquivalente Umformung eines Ausdrucks in einen anderen Ausdruck ermöglichen, d.h. eine Umformung, die die Bedeutung (oder den Wert) eines Ausdrucks nicht verändert.\n\n\n\n\n\n\nKommutativgesetz\n\n\n\nFür reelle Zahlen gilt bezüglich der Addition und Multiplikation das Kommutativgesetz: \\[\n\\begin{align}\na + b &= b + a\\\\\na \\cdot b &= b \\cdot a\n\\end{align}\n\\tag{1}\\] Bei der Addition kann man also die Summanden vertauschen und bei der Multiplikation die Faktoren.\n\n\n\nassert a + b == b + a\nassert a * b == b * a\n\n\n\n\n\n\n\nAssoziativgestz\n\n\n\nFür reelle Zahlen gilt bezüglich der Addition und Multiplikation das Assoziativgesetz: \\[\n\\begin{align}\n(a + b) + c &= a + (b + c)\\\\\n(a \\cdot b) \\cdot c &= a \\cdot (b \\cdot c)\n\\end{align}\n\\tag{2}\\] Bei der Addition kann man also die Summanden beliebig zusammenfassen, bei der Multiplikation die Faktoren beliebig verknüpfen.\n\n\n\nassert (a + b) + c == a + (b + c)\nassert (a * b) * c == a * (b * c)\n\n\n\n\n\n\n\nDistributivgesetze\n\n\n\nFür reelle Zahlen gelten die Distributivgesetze: \\[\n\\begin{align}\n(a + b) \\cdot c &= a \\cdot c + b \\cdot c\\\\\na \\cdot (b + c) \\cdot c &= a \\cdot b + a \\cdot c\\\\\n\\end{align}\n\\tag{3}\\]\n\n\n\nassert (a + b) * c == a*c + b*c\nassert a * (b + c) == a*b + a*c\n\n\n\n\n\n\n\nPunktrechnung vor Strichrechnung\n\n\n\nDie Rechenzeichen \\(\\cdot\\) und \\(\\div\\) binden stärker als \\(+\\) und \\(-\\), das heißt, Multiplikation und Division müssen vor Addition und Subtraktion ausgeführt werden. \\[\n\\begin{align}\na + b \\cdot c &= a + (b \\cdot c)\\\\\na - b \\div c &= a - (b \\div c)\n\\end{align}\n\\] Python berücksichtigt diese Regeln automatisch, so dass wir im letzten Codebeispiel die Klammern auf der rechten Seite weglassen konnten.",
    "crumbs": [
      "Arithmetik",
      "Grundlegende Rechenregeln"
    ]
  },
  {
    "objectID": "arithmetik/1-rechenregeln.html#grundregeln-der-klammerrechnung",
    "href": "arithmetik/1-rechenregeln.html#grundregeln-der-klammerrechnung",
    "title": "Grundlegende Rechenregeln",
    "section": "4 Grundregeln der Klammerrechnung",
    "text": "4 Grundregeln der Klammerrechnung\nAus den Grundgesetzen der Addition und Multiplikation ergeben sich die wichtigen Regeln der Klammerrechnung, die wir in diesem Abschnitt untersuchen wollen. Zuvor aber noch einen Hinweis für die mathematische Schreibweise von Produkten:\n\n\n\n\n\n\nSchreibweise von Produkten\n\n\n\nBeim Aufschreiben von Produkten in der Form \\(a \\cdot b\\) lassen wir oft den Operator für die Multiplikation weg. Das heißt, \\(a \\cdot b\\) ist gleichbedeutend mit \\(ab\\).\nDas gilt aber nicht für Python-Code: hier muss ein Produkt immer in der Form a * b angegeben werden; die Leerzeichen können aber auch weggelassen werden: a*b.\n\n\nAußerdem ist noch eine Warnung angebracht: das Distributivgestz (Gleichung 3) gilt nicht für die reine Multiplikation:\n\n\n\n\n\n\nWarnung\n\n\n\n\\[\n(a\\cdot b)\\cdot c\\neq ac\\cdot bc, \\ \\mathrm{sondern} \\ (a\\cdot b)\\cdot c=abc\n\\]\n\n\n\nassert (a*b)*c == a*b*c\n(a*b) * c == a*c * b*c\n\nFalse\n\n\n\n4.1 Multiplikation mit Klammern\nSummen und Differenzen von Produkten können vereinfacht werden, indem man gemeinsame Faktoren ausklammert.\n\n\n\n\n\n\nAusklammern\n\n\n\nEnthalten alle Glieder einer Summe oder Differenz den gleichen Faktor so kann man diesen ausklammern: \\[\n\\begin{align}\nab + ac &= a(b+c)\\\\\nac - bc &= (a-b)c\n\\end{align}\n\\]\n\n\nProdukte von Summen und Differenzen werden berechnet, indem man ihre Glieder multipliziert.\n\n\n\n\n\n\nAusmultiplizieren\n\n\n\nMan multipliziert zwei Summen (bzw. Differenzen) miteinander, indem man jedes Glied der einen Summe mit jedem Glied der anderen Summe multipliziert und die erhaltenen Produkte addiert (bzw. subtrahiert): \\[\n\\begin{align}\n(a+b)(c+d) &= ac+ad+bc+bd\\\\\n(a+b)(c-d) &= ac-ad+bc-bd\\\\\n(a-b)(c+d) &= ac+ad-bc-bd\\\\\n(a-b)(c-d) &= ac-ad-bc+bd\n\\end{align}\n\\]\n\n\nDie grundsätzlich Bedeutung von Klammern ist, dass Teilausdrücke, die innerhalb einer Klammer stehen, vor allen anderen Operationen ausgewertet werden. Bei verschachtelten Klammern sind die Klammern immer von innen nach außen aufzulösen:\n\\[\na(b+c(d+e))=a(b+cd+ce)=ab+acd+ace\n\\]\n\n\n4.2 Binomische Formeln\nEin Binom ist ein zweigliedriger Ausdruck in der Form \\(a+b\\) oder \\(a-b\\). Die Multiplikation von Binomen führt zu den Binomischen Formeln (mit zwei Faktoren). Sie heißen daher auch binomische Gleichungen 2. Grades.\nBevor wir uns diese Gleichungen anschauen, wollen wir erst den Begiff der Quadratzahl einführen:\n\n\n\n\n\n\nQuadratzahl\n\n\n\nEine reelle Zahl \\(a\\), multipliziert mit sich selbst, heißt Quadratzahl von \\(a\\) (gesprochen a Quadrat): \\[\na \\cdot a = a^2\n\\]\n\n\n\n\n\n\n\n\nBinomische Formeln\n\n\n\nDie binomischen Formeln für zwei beliebige reelle Zahlen lauten: \\[\n\\begin{align}\n(a+b)^2 &= a^2+2ab+b^2\\\\\n(a-b)^2 &= a^2-2ab+b^2\\\\\n(a+b)(a-b) &= a^2-b^2\n\\end{align}\n\\tag{4}\\]\n\n\n\nassert (a+b)**2 == a**2 + 2*a*b + b**2\nassert (a-b)**2 == a**2 - 2*a*b + b**2\nassert (a+b)*(a-b) == a**2 - b**2\n\nDiese Formeln sind keine Hexerei, sondern können mit den jetzt bekannten Rechenregeln hergeleitet werden. Für die erste binomische Formel könnte das so aussehen: \\[\n(a+b)^2=(a+b)(a+b)=aa+ab+ba+bb=a^2+2ab+b^2\n\\]\n\n\n\n\n\n\nWarnung\n\n\n\n\\[\n(a+b)^2 \\neq a^2+b^2, \\ \\mathrm{sondern} \\ (a+b)^2=a^2+2ab+b^2\n\\]\n\n\n\n(a+b)**2 == a**2 + b**2\n\nFalse",
    "crumbs": [
      "Arithmetik",
      "Grundlegende Rechenregeln"
    ]
  },
  {
    "objectID": "arithmetik/1-rechenregeln.html#indizes-und-summenzeichen",
    "href": "arithmetik/1-rechenregeln.html#indizes-und-summenzeichen",
    "title": "Grundlegende Rechenregeln",
    "section": "5 Indizes und Summenzeichen",
    "text": "5 Indizes und Summenzeichen\nEin Index (Plural Indizes) ist ein Zeichen, das an Symbole für Variable, Funktionen oder Operationen angebracht wird. Bezeichnet man z.B. Variable mit \\(x\\), dann kennzeichent man verschiedene Variable dudurch, dass man an das \\(x\\) verschiedene tiefgestellte Indizes anhängt: \\(x_1, x_2, x_3, \\dots\\)\nDas Summenzeichen, (entstanden aus dem griechischen Buchstaben für S) dient zur vereinfachten Darstellung von Summen:\n\n\n\n\n\n\nSummenzeichen\n\n\n\n\\[\n\\sum_{k=1}^n = a_k=a_1+a_2+a_3+\\cdots+a_n,\n\\tag{5}\\] gespochen als: Summe über \\(a_k\\) von \\(k=1\\) bis \\(k=n\\).\n\n\nMan erhält alle Summanden der Summe, wenn man in \\(a_k\\) für den Index \\(k\\) zunächst 1, dann 2 usw. und schließlich \\(n\\) setzt. Dieser Buchstabe \\(k\\) heißt Summationsindex und kann durch einen beleibigen anderen Buchstaben ersetzt werden.\n\n\n\n\n\n\nBeispiel für Summen\n\n\n\n\\(\\sum_{k=1}^6 k^2= 1^2+2^2+3^2+4^2+5^2+6^2=1+4+9+16+25+36=91\\)\n\n\nIn Python können wir Summen auf verschiedene Weisen berechnen:\n\n# manuelles Addieren\nsum_1 = 1**2 + 2**2 + 3**2 + 4**2 + 5**2 + 6**2\nassert sum_1 == 91\n\n# Addieren in einer for-Schleife\nsum_2 = 0\n1ks = [1,2,3,4,5,6]\n2for s in ks:\n3  sum_2 += s**2\n\n## Addieren über den Index\nsum_3 = 0\n4for i in range(len(ks)):\n5  sum_3 += ks[i]**2\n\nassert sum_1 == sum_2 == sum_3\n\n\n1\n\nDefinition der Werte für den Summationsindex \\(k\\) als Python Liste. Zur Erstellung einer Liste geben wir die Werte, getrennt durch ein Komma, in eckigen Klammern an. Das Ergebis dieser Definition ist Objekt des Datentyps list.\n\n2\n\nBeginn einer for Schleife mit s als Schleifenvariable und dem Objekt ks. Diese Anweisung führt dazu, dass die nächste Code-Zeile (3) für jedes Element in ks einmal ausgeführt wird.\n\n3\n\nDer Wert von sum_2 wird um das Quadrat des jeweiligen Elements s erhöht.\n\n4\n\nPython erzeugt automatisch einen Index für jedes list Objekt. Wir können mit dem Ausdruck range(len(ks)) eine neue Liste dieser Indizes erzeugen. Die Indizes in Python beginnen, abweichend von der mathematischen Definition, mit 0 und enden demgemäß mit \\(n-1\\), in unserem Beispiel mit 5. Wir werden in der Lektion Zahlenbereiche und Zahlensyteme sehen, wie wir die Funktion range() korrekt anwenden.\n\n5\n\nAuf das \\(i\\)-te Element einer Liste kann mit list[i] zugegriffen werden. Der Ausdruck ks[i] ist also synonym zum Ausdruck s im vorangehenden Code-Beispiel.",
    "crumbs": [
      "Arithmetik",
      "Grundlegende Rechenregeln"
    ]
  },
  {
    "objectID": "arithmetik/1-rechenregeln.html#sec-ubung",
    "href": "arithmetik/1-rechenregeln.html#sec-ubung",
    "title": "Grundlegende Rechenregeln",
    "section": "6 Übungen",
    "text": "6 Übungen\nWir werden in dieser Lektion ein paar einfache Rechenübungen durchführen, bevor wir dann ab der nächsten Lektion mit Jupyter Notebooks arbeiten werden. Deine erste Aufgabe besteht also darin, dir eine entsprechende Arbeitsumgebung einzurichten. Falls du noch kein Python auf deinem Rechner hast, empfehle ich dir, zuerst Miniconda entsprechend diesen Anleitungen zu installieren. Wenn das geschafft ist, dann kannst du mit einem Befehl wie\nconda create -n matheKapieren python=3.12\nin deiner Kommandozeile eine neue Arbeitsumgebung einrichten und Python installieren. Um die Arbeitsumgebung zu aktivieren, setze den Befehl conda activate matheKapieren ab, dann kannst du auf alle Python Werkzeuge zugreifen. Schließlich kannstdu mit conda install -c conda-forge jupyter Jupyter und später noch weitere Pakete installieren.\nNun aber zu den Übungen: wenn du bei einer Aufgabe Schwierigkeiten hast, schau dir den entsprechenden Lösungshinweis an, und vergleiche dann deine Lösung mit meinem Lösungsvorschlag. Mache dir aber auf jeden Fall Gedanken, wie du die Aufgabe lösen kannst. Wenn du gleich zur Lösung springst, wirst du nichts lernen.\n\n\n\n\n\n\nAufgabe 1\n\n\n\nBerechne die Quersumme von \\(1.234.567.890\\).\n\n\n\n\n\n\n\n\nHinweis\n\n\n\n\n\nDie Quersumme einer Zahl ist die Summe ihrer Ziffern.\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\\[\n1+2+3+4+5+6+7+8+9+0=45\n\\]\n\n\n\n\n\n\n\n\n\nAufgabe 2\n\n\n\nLeite die 2. binomische Formel her.\n\n\n\n\n\n\n\n\nHinweis\n\n\n\n\n\nGehe genauso vor wie bei der Herleitung der 1. binomischen Formel in Kapitel 4.2.\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\\[\n(a-b)^2=(a-b)(a-b)=aa-ab-ba+bb=a^2-2ab+b^2\n\\]\n\n\n\n\n\n\n\n\n\nAufgabe 3\n\n\n\nLeite die 3. binomische Formel her.\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\\[\n(a+b)(a-b)=aa-ab+ba-bb=aa-bb=a^2-b^2\n\\]\n\n\n\n\n\n\n\n\n\nAufgabe 4\n\n\n\nBerechne \\(3(200+7)\\).\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\\[\n3(200+7)=3\\cdot 200+3\\cdot 7= 600+21=621\n\\]\n\n\n\n\n\n\n\n\n\nAufgabe 5\n\n\n\nVereinfache den Term: \\(abc-acd+ace\\).\n\n\n\n\n\n\n\n\nHinweis\n\n\n\n\n\nKlammere die gemeinsamen Faktoren aus.\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\\[\nabc-acd+ace=ac(b-d+e)\n\\]\n\n\n\n\n\n\n\n\n\nAufgabe 6\n\n\n\nVereinfache den Term: \\(-5x^2+25xy-35zx\\).\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\\[\n-5x^2+25xy-35zx=-5x(x-5y+7z)\n\\]\n\n\n\n\n\n\n\n\n\nAufgabe 7\n\n\n\nIst 11.543.711 durch 11 teilbar?\n\n\n\n\n\n\n\n\nHinweis\n\n\n\n\n\nVerwende die alternierende Quersumme.\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n11.513.511 ist nicht durch 11 teilbar, denn die alternierende Quersumme \\(+1-1+5-1+3-5+1-1=2\\) ist nicht teilbar durch 11.\n\n\n\n\n\n\n\n\n\nAufgabe 8\n\n\n\nBerechne \\(21^2\\).\n\n\n\n\n\n\n\n\nHinweis\n\n\n\n\n\nVersuche, die 1. binomische Formel anzuwenden.\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\\[\n21^2=(20+1)^2=20^2+2\\cdot 20\\cdot 1+1^2=400+40+1=441\n\\]\n\n\n\n\n\n\n\n\n\nAufgabe 9\n\n\n\nBerechne \\(19^2\\).\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\\[\n19^2=(20-1)^2=20^2-2\\cdot 20\\cdot 1+1^2=400-40+1=361\n\\]\n\n\n\n\n\n\n\n\n\nAufgabe 10\n\n\n\nVereinfache den Term: \\(5(x-2(x-y-3y-6x-3y)+2y)\\).\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\\[\n\\begin{align}\n5(x-2(x-y-3y-6x-3y)+2y) &= 5(x-2(-5x-7y)+2y)\\\\\n&=5(x+10x+14y+2y)\\\\\n&=5(11x+16y)\\\\\n&=55x+80y\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nAufgabe 11\n\n\n\nBerechne \\(21\\cdot 19\\).\n\n\n\n\n\n\n\n\nHinweis\n\n\n\n\n\nVersuche, die 3. binomische Formel anzuwenden.\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\\[\n21 \\cdot 19=(20+1)(20-1)=20^2-1^2=400-1=399\n\\]\n\n\n\n\n\n\n\n\n\nAufgabe 12\n\n\n\nBerechne \\(17\\cdot 23\\).\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\\[\n17 \\cdot 23=(20-3)(20+3)=20^2-3^2=400-9=391\n\\]",
    "crumbs": [
      "Arithmetik",
      "Grundlegende Rechenregeln"
    ]
  }
]